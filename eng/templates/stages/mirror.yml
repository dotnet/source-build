parameters:
- name: dotnetMajorVersion
  displayName: Major .NET version being released
  type: string
- name: releaseBranchName
  displayName: Release branch name (e.g. release/8.0.1xx-preview1)
  type: string
- name: useCustomTag
  type: boolean
  default: false
- name: customTag
  type: string
- name: isDryRun
  type: boolean
  default: false
- name: dotnetStagingPipelineResource
  type: string

stages:
- stage: Mirror
  displayName: Mirror to DSP
  dependsOn:
  - PreRelease
  - MirrorApproval

  jobs:
  - job: Mirror
    displayName: Mirror ${{ parameters.releaseBranchName }} and packages.
    variables:
    - group: DotNet-Source-Build-All-Orgs-Source-Access
    - name: RepoDir
      value: vmr
    - name: GitUser
      value: dn-bot
    - name: GitEmail
      value: dn-bot@microsoft.com
    - name: destinationUrl
      value: https://dotnet-security-partners@dev.azure.com/dotnet-security-partners/dotnet/_git/dotnet
    - name: sdkVersion
      value: $[ stageDependencies.PreRelease.PreRelease.outputs['ReadReleaseInfo.SdkVersion'] ]
    - ${{ if or(eq(parameters.dotnetMajorVersion, '6.0'), eq(parameters.dotnetMajorVersion, '7.0')) }}:
      - name: sourceUrl
        value: https://dnceng@dev.azure.com/dnceng/internal/_git/security-partners-dotnet
      - name: sourceVersion
        value: $[ stageDependencies.PreRelease.PreRelease.outputs['AssociatedPipelineRuns.InstallerCommit'] ]
    - ${{ else }}:
      - name: sourceUrl
        value: https://dnceng@dev.azure.com/dnceng/internal/_git/dotnet-dotnet
      - name: sourceVersion
        value: $[ stageDependencies.PreRelease.PreRelease.outputs['AssociatedPipelineRuns.DotnetDotnetCommit'] ]
    # Destination package feed. If this feed changes, you must also change feedServiceConnection to point to that feed.
    - name: destinationPackageFeed
      value: https://pkgs.dev.azure.com/dotnet-security-partners/dotnet/_packaging/dotnet/nuget/v3/index.json
    - name: feedServiceConnection
      value: 'dotnet-security-partners-dotnet-dotnet feed'
    - name: packagesArtifactName
      value: signed
    - name: shippingPackages
      value: 'shipping/packages'
    - name: packagesDownloadLocation
      value: $(PIPELINE.WORKSPACE)/${{ parameters.dotnetStagingPipelineResource }}/$(packagesArtifactName)/$(shippingPackages)

    steps:
    - checkout: none

    - script: |
        set -euo pipefail

        repo_dir="$(Pipeline.Workspace)/$(RepoDir)"
        git init "$repo_dir"
        cd "$repo_dir"

        echo "Setting up git in $repo_dir repo for ${{ variables.sourceUrl }} -> ${{ variables.destinationUrl }}"

        git config --global user.name '${{ variables.GitUser }}'
        git config --global user.email '${{ variables.GitEmail }}'

        source_url=$(echo '${{ variables.sourceUrl }}' | sed "s,https://.*@,https://${{ variables.GitUser }}:${AZDO_PAT}@,g")
        destination_url=$(echo '${{ variables.destinationUrl }}' | sed "s,https://.*@,https://${{ variables.GitUser }}:${AZDO_PAT}@,g")

        git remote add source "${source_url}"
        git remote add destination "${destination_url}"
      displayName: Initialize repository
      env:
        AZDO_PAT: $(dn-bot-all-orgs-build-rw-code-rw)

    - script: |
        set -euo pipefail

        branch_name="${{ parameters.releaseBranchName }}"
        if [[ "$branch_name" == internal/* ]]; then
          branch_name="${branch_name#internal/}"
        fi

        echo "Mirroring $branch_name from ${{ variables.sourceUrl }} to ${{ variables.destinationUrl }}"

        if [[ "${{ parameters.dotnetMajorVersion }}" == '6.0' || "${{ parameters.dotnetMajorVersion }}" == '7.0' ]]; then
          # For 6.0 and 7.0 we tag the release branch into which we merged the release PR
          ref_to_tag="$branch_name"
        else
          # For 8.0+ we tag a given VMR commit
          ref_to_tag="$(sourceVersion)"
        fi

        git fetch source "$ref_to_tag"
        git checkout "$ref_to_tag"

        if [ "${{ parameters.useCustomTag }}" = "True" ] ; then
          tag_name="${{ parameters.customTag }}"
          echo "Using custom tag ${tag_name}"
        else
          tag_name="v$(SdkVersion)"
          echo "Using tag ${tag_name}"
        fi

        # Check if the tag already exists and points to the same commit
        sha=$(git rev-parse HEAD)
        if git ls-remote --tags destination | grep -q "$tag_name"; then
          echo "Tag $tag_name already exists, checking if it points to the same commit"

          if git ls-remote --tags destination | grep "$tag_name" | grep -q "$sha"; then
            echo "Tag $tag_name already exists at $sha, skipping"
            exit 0
          else
            echo "Tag $tag_name already exists but does not point to a $sha, aborting"
            echo "Existing tags:"
            git ls-remote --tags destination
            exit 1
          fi
        fi

        message=".NET Source-build $(sdkVersion)-SDK"
        git tag "$tag_name" "$ref_to_tag" -m "$message"

        if [ "${{ parameters.isDryRun }}" = "True" ]; then
          set +x
          echo "Doing a dry run, not pushing the tag $tag_name / $ref_to_tag to ${{ variables.destinationUrl }}"
        else
          echo "Pushing tag $tag_name to ${{ variables.destinationUrl }}"
          git push destination "$tag_name"
        fi
      workingDirectory: $(Pipeline.Workspace)/$(RepoDir)
      displayName: Mirror and tag

    # Download all shipping nupks from the staging pipeline.
    # These should come from the signed directory, because in 6.0 post-build signing
    # means that the 'signed' and 'shipping' artifacts are different in content.
    - download: ${{ parameters.dotnetStagingPipelineResource }}
      artifact: ${{ variables.packagesArtifactName }}
      patterns: ${{ variables.shippingPackages }}/*
      displayName: Download shipping packages

    # Then, upload these to DSP.
    - ${{ if parameters.isDryRun }}:
      # List the packages that would be pushed
      - script: |
          echo "Would push the following packages to $(destinationPackageFeed)"
          find $(packagesDownloadLocation) -name '*.nupkg'
        displayName: Publish packages to ${{ variables.destinationPackageFeed }}

    - ${{ else }}:
      - task: NuGetCommand@2
        displayName: Publish packages to ${{ variables.destinationPackageFeed }}
        continueOnError: true
        inputs:
          command: push
          packagesToPush: '${{ variables.packagesDownloadLocation }}/*.nupkg'
          nuGetFeedType: external
          publishFeedCredentials: ${{ variables.feedServiceConnection }}
          allowPackageConflicts: true 

