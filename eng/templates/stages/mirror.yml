parameters:
- name: dotnetMajorVersion
  type: string
- name: releaseBranchName
  type: string
- name: isPreviewRelease
  type: boolean
- name: useCustomTag
  type: boolean
- name: skipPackageMirroring
  type: boolean
- name: isDryRun
  type: boolean
  default: false
- name: dotnetStagingPipelineResource
  type: string

stages:
- stage: Mirror
  displayName: Mirror sources & packages
  dependsOn:
  - PreRelease
  - MirrorApproval

  jobs:
  - job: Mirror
    displayName: Mirror sources & packages
    variables:
    - template: ../variables/pipelines.yml
    - template: ../variables/msrc-storage-variables.yml
      parameters:
        isDryRun: ${{ parameters.isDryRun }}
    - group: DotNet-Source-Build-All-Orgs-Source-Access
    - name: RepoDir
      value: vmr
    - name: GitUser
      value: dn-bot
    - name: GitEmail
      value: dn-bot@microsoft.com
    - name: destinationUrl
      value: https://dotnet-security-partners@dev.azure.com/dotnet-security-partners/dotnet/_git/dotnet
    # Destination package feed. If this feed changes, you must also change feedServiceConnection to point to that feed.
    - name: destinationPackageFeed
      value: https://pkgs.dev.azure.com/dotnet-security-partners/dotnet/_packaging/dotnet/nuget/v3/index.json
    - name: feedServiceConnection
      value: 'dotnet-security-partners-dotnet-dotnet feed'
    - name: packagesArtifactName
      value: signed
    - name: shippingPackages
      value: 'shipping/packages'
    - name: packagesDownloadLocation
      value: $(PIPELINE.WORKSPACE)/${{ parameters.dotnetStagingPipelineResource }}/$(packagesArtifactName)/$(shippingPackages)
    - name: releaseTag
      value: $[ stageDependencies.PreRelease.PreRelease.outputs['ReadReleaseInfo.ReleaseTag'] ]
    - name: sdkVersion
      value: $[ stageDependencies.PreRelease.PreRelease.outputs['ReadReleaseInfo.SdkVersion'] ]
    - name: runtimeVersion
      value: $[ stageDependencies.PreRelease.PreRelease.outputs['ReadReleaseInfo.RuntimeVersion'] ]
    - name: releaseChannel
      value: $[ stageDependencies.PreRelease.PreRelease.outputs['ReadReleaseInfo.ReleaseChannel'] ]
    - name: combinedSmokeTestPrereqsTarballPath
      value: $(Pipeline.Workspace)/dotnet-smoke-test-prereqs-$(sdkVersion).tar.gz

    - ${{ if eq(parameters.dotnetMajorVersion, '6.0') }}:
      - name: smokeTestPreReqsArtifactNameX64
        value: Build_Tarball_x64 CentOSStream9-Offline_Artifacts
      - name: smokeTestPreReqsArtifactNameArm64
        value: Build_Tarball_arm64 Debian11-Offline_Artifacts
    - ${{ if eq(parameters.dotnetMajorVersion, '7.0') }}:
      - name: smokeTestPreReqsArtifactNameX64
        value: Build_Tarball_x64 CentOSStream9-Offline_Artifacts
      - name: smokeTestPreReqsArtifactNameArm64
        value: Build_Tarball_arm64 Debian11-Offline_Artifacts
    - ${{ if eq(parameters.dotnetMajorVersion, '8.0') }}:
      - name: smokeTestPreReqsArtifactNameX64
        value: CentOSStream9_Offline_MsftSdk_x64_Artifacts
      - name: smokeTestPreReqsArtifactNameArm64
        value: Ubuntu2204Arm64_Offline_MsftSdk_arm64_Artifacts

    - ${{ if or(eq(parameters.dotnetMajorVersion, '6.0'), eq(parameters.dotnetMajorVersion, '7.0')) }}:
      - name: sourceUrl
        value: https://dnceng@dev.azure.com/dnceng/internal/_git/security-partners-dotnet
      - name: sourceVersion
        value: $[ stageDependencies.PreRelease.PreRelease.outputs['AssociatedPipelineRuns.InstallerCommit'] ]
      - name: officialBuildPipelineId
        value: $(INSTALLER_TARBALL_BUILD_CI_PIPELINE_ID)
      - name: officialBuildRunId
        value: $[ stageDependencies.PreRelease.PreRelease.outputs['AssociatedPipelineRuns.InstallerTarballBuildRunId'] ]
    - ${{ else }}:
      - name: sourceUrl
        value: https://dnceng@dev.azure.com/dnceng/internal/_git/dotnet-dotnet
      - name: sourceVersion
        value: $[ stageDependencies.PreRelease.PreRelease.outputs['AssociatedPipelineRuns.DotnetDotnetCommit'] ]
      - name: officialBuildPipelineId
        value: $(DOTNET_DOTNET_CI_PIPELINE_ID)
      - name: officialBuildRunId
        value: $[ stageDependencies.PreRelease.PreRelease.outputs['AssociatedPipelineRuns.DotnetDotnetRunId'] ]

    # We're using a different pool than the rest of the pipeline here to get more disk space
    # More information here: https://github.com/dotnet/arcade/issues/13036
    pool:
      name: NetCore1ESPool-Svc-Internal
      demands: ImageOverride -equals Build.Ubuntu.2004.Amd64

    steps:
    - script: |
        set -euo pipefail

        repo_dir="$(Pipeline.Workspace)/$(RepoDir)"
        git init "$repo_dir"
        cd "$repo_dir"

        echo "Setting up git in $repo_dir repo for ${{ variables.sourceUrl }} -> ${{ variables.destinationUrl }}"

        git config --global user.name '${{ variables.GitUser }}'
        git config --global user.email '${{ variables.GitEmail }}'

        source_url=$(echo '${{ variables.sourceUrl }}' | sed "s,https://.*@,https://${{ variables.GitUser }}:${AZDO_PAT}@,g")
        destination_url=$(echo '${{ variables.destinationUrl }}' | sed "s,https://.*@,https://${{ variables.GitUser }}:${AZDO_PAT}@,g")

        git remote add source "${source_url}"
        git remote add destination "${destination_url}"
      displayName: Initialize repository
      env:
        AZDO_PAT: $(dn-bot-all-orgs-build-rw-code-rw)

    - script: |
        set -euo pipefail

        branch_name="${{ parameters.releaseBranchName }}"
        if [[ "$branch_name" == internal/* ]]; then
          branch_name="${branch_name#internal/}"
        fi

        echo "Mirroring $branch_name from ${{ variables.sourceUrl }} to ${{ variables.destinationUrl }}"

        if [[ "${{ parameters.dotnetMajorVersion }}" == '6.0' || "${{ parameters.dotnetMajorVersion }}" == '7.0' ]]; then
          # For 6.0 and 7.0 we tag the release branch into which we merged the release PR
          ref_to_tag="$branch_name"
        else
          # For 8.0+ we tag a given VMR commit
          ref_to_tag="$(sourceVersion)"
        fi

        git fetch source "$ref_to_tag"
        git checkout "$ref_to_tag"

        tag_name="$(releaseTag)"
        echo "Tagging $ref_to_tag as $tag_name"

        # Check if the tag already exists and points to the same commit
        sha=$(git rev-parse HEAD)

        # When querying for tags we need to ensure match the whole line and not just a substring
        # of the tag name. This avoids accidentally matching a new tag of v8.0.0 with an existing
        # tag of v8.0.0-rc.2.23479.6, for example. This is accomplished by including the '$' character
        # at the end of the query so that it matches the end of the line. We also need to account for
        # recursive tags, which is why we use the '^{}' syntax. For example, the tags that we create
        # actually have two tags associated with them:
        #   083b8b9fe09d04205e87bca0b378e4a3ad74a239        refs/tags/v8.0.0-rc.1.23419.4
        #   113d797bc90104bb4f1cc51e1a462cf3d4ef18fc        refs/tags/v8.0.0-rc.1.23419.4^{}
        # We want to match on both.
        tagGrepQuery="refs/tags/$tag_name\(\^{}\)\?$"

        # `grep -q` exits as soon as a match is found; if there are multiple matches
        # `git ls-remote` would continue to output even after grep exits, resulting in a
        # broken pipe error (exit code 141). Saving the result in a var fixes the issue
        tags=$(git ls-remote --tags destination)
        if echo "$tags" | grep -q "$tagGrepQuery"; then
          echo "Tag $tag_name already exists, checking if it points to the same commit"

          if echo "$tags" | grep "$tagGrepQuery" | grep -q "$sha"; then
            echo "Tag $tag_name already exists at $sha, skipping"
            exit 0
          else
            echo "Tag $tag_name already exists but does not point to a $sha, aborting"
            echo "Existing tags:"
            echo "$tags"
            exit 1
          fi
        fi

        message=".NET Source-build $(releaseTag)"
        git tag "$tag_name" "$ref_to_tag" -m "$message"

        if [ "${{ parameters.isDryRun }}" = "True" ]; then
          set +x
          echo "Doing a dry run, not pushing the tag $tag_name / $ref_to_tag to ${{ variables.destinationUrl }}"
        else
          echo "Pushing tag $tag_name to ${{ variables.destinationUrl }}"
          git push destination "$tag_name"
        fi
      workingDirectory: $(Pipeline.Workspace)/$(RepoDir)
      displayName: Mirror & tag sources

    - ${{ if not(parameters.skipPackageMirroring) }}:
      # Download all shipping nupks from the staging pipeline.
      # These should come from the signed directory, because in 6.0 post-build signing
      # means that the 'signed' and 'shipping' artifacts are different in content.
      - download: ${{ parameters.dotnetStagingPipelineResource }}
        artifact: ${{ variables.packagesArtifactName }}
        patterns: ${{ variables.shippingPackages }}/*
        displayName: Download shipping packages

      # Then, upload these to DSP.
      - ${{ if parameters.isDryRun }}:
        # List the packages that would be pushed
        - script: |
            echo "Would push the following packages to $(destinationPackageFeed)"
            find $(packagesDownloadLocation) -name '*.nupkg'
          displayName: Publish packages to ${{ variables.destinationPackageFeed }}

      - ${{ else }}:
        - script: sudo apt update && DEBIAN_FRONTEND=noninteractive sudo apt install -y apt-transport-https mono-complete nuget
          displayName: Install NuGet and dependencies
        - task: NuGetAuthenticate@1
          displayName: Authenticate to ${{ variables.destinationPackageFeed }}
          inputs:
            nuGetServiceConnections: ${{ variables.feedServiceConnection }}
        - task: NuGetCommand@2
          displayName: Publish packages to ${{ variables.destinationPackageFeed }}
          inputs:
            command: push
            packagesToPush: '${{ variables.packagesDownloadLocation }}/*.nupkg'
            nuGetFeedType: external
            publishFeedCredentials: ${{ variables.feedServiceConnection }}
            allowPackageConflicts: true

    - template: ../steps/download-smoke-test-prereqs.yml
      parameters:
        officialBuildPipelineId: $(officialBuildPipelineId)
        officialBuildRunId: $(officialBuildRunId)
        taskLabel: x64
        artifactName: $(smokeTestPreReqsArtifactNameX64)

    - template: ../steps/download-smoke-test-prereqs.yml
      parameters:
        officialBuildPipelineId: $(officialBuildPipelineId)
        officialBuildRunId: $(officialBuildRunId)
        taskLabel: arm64
        artifactName: $(smokeTestPreReqsArtifactNameArm64)

    - script: |
        "$(Build.SourcesDirectory)/eng/combine-tarballs.sh" \
          --output "$(combinedSmokeTestPrereqsTarballPath)" \
          $(Pipeline.Workspace)/dotnet-smoke-test-prereqs.*.tar.gz
      displayName: Combine smoke test prereqs tarballs

    # Install requirements needed to upload to blob storage
    # These aren't included by default in the agent image
    - script: |
        curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash && \
          sudo apt-get update && \
          sudo apt-get install -y \
            jq
      displayName: Install upload prereqs

    - template: ../steps/upload-to-blob-storage.yml
      parameters:
        file: $(combinedSmokeTestPrereqsTarballPath)
        accountName: $(storageAccountName)
        containerName: $(blobContainerName)
        uploadPath: $(blobContainerUploadBaseFilePath)/$(releaseChannel)/$(runtimeVersion)-$(sdkVersion)
        azureStorageKey: $(dotnetclimsrc-access-key)
        contentType: $(TARBALL_BLOB_CONTENT_TYPE)
