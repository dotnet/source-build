From dbfc81661b601c92a3fec164a80d910f0a62911c Mon Sep 17 00:00:00 2001
From: Viktor Hofer <viktor.hofer@microsoft.com>
Date: Tue, 15 Sep 2020 23:52:33 +0200
Subject: [PATCH] Merge pull request #42269 from ViktorHofer/sdkupdate-RC2

[release/5.0-rc2] - Update SDK to final P8/RC1 and unpin compiler version
Conflicts:
	src/libraries/externals.csproj
---
 Directory.Build.props                              |   3 -
 eng/Configurations.props                           |   2 +
 eng/Versions.props                                 |   2 -
 eng/depProj.common.targets                         |   5 -
 eng/depProj.targets                                | 156 ---------------------
 eng/restore/repoRestore.targets                    |   9 +-
 global.json                                        |   8 +-
 .../Runtime/InteropServices/Marshal.CoreCLR.cs     |   6 +-
 src/coreclr/tests/issues.targets                   |   5 +
 src/libraries/Directory.Build.props                |   3 +-
 src/libraries/Directory.Build.targets              |   2 +-
 .../RuntimeBinder/ComInterop/ComRuntimeHelpers.cs  |   4 +-
 .../System.Formats.Cbor.Tests.DataModel.fsproj     |   4 +-
 .../Windows/WebSockets/HttpWebSocket.Windows.cs    |   2 +
 .../src/System/Diagnostics/Tracing/EventCounter.cs |   2 +-
 src/libraries/externals.csproj                     |  94 +++++++++++++
 .../frameworkSettings/netcore50/settings.targets   |   5 +
 .../portable-net45+win8+wp8+wpa81/settings.targets |   7 +
 .../portable-net45+win8+wpa81/settings.targets     |   7 +
 .../portable-net45+win8/settings.targets           |   7 +
 .../portable45-net45+win8/settings.targets         |   7 +
 .../portable46-net451+win81/settings.targets       |   7 +
 .../netcoreapp/DisableVerifyClosure.targets        |   7 +
 src/libraries/pkg/test/packageTest.targets         |   2 +
 src/libraries/pkg/test/project.csproj.template     |   2 +
 src/libraries/pretest.proj                         |  18 +--
 src/libraries/restore/Directory.Build.props        |  23 ---
 src/libraries/restore/Directory.Build.targets      |   7 -
 .../restore/runtime/Directory.Build.props          |   7 -
 src/libraries/restore/runtime/runtime.depproj      | 110 ---------------
 .../UnmanagedCallersOnly/InvalidCSharp.ilproj      |   8 ++
 .../UnmanagedCallersOnly/InvalidCallbacks.il       |  75 ++++++++++
 .../UnmanagedCallersOnlyTest.cs                    |  54 +++----
 .../UnmanagedCallersOnlyTest.csproj                |   2 +-
 .../JIT/Directed/tailcall/mutual_recursion.fsproj  |   2 +-
 35 files changed, 289 insertions(+), 375 deletions(-)
 delete mode 100644 eng/depProj.common.targets
 delete mode 100644 eng/depProj.targets
 create mode 100644 src/libraries/externals.csproj
 create mode 100644 src/libraries/pkg/test/frameworkSettings/netcore50/settings.targets
 create mode 100644 src/libraries/pkg/test/frameworkSettings/portable-net45+win8+wp8+wpa81/settings.targets
 create mode 100644 src/libraries/pkg/test/frameworkSettings/portable-net45+win8+wpa81/settings.targets
 create mode 100644 src/libraries/pkg/test/frameworkSettings/portable-net45+win8/settings.targets
 create mode 100644 src/libraries/pkg/test/frameworkSettings/portable45-net45+win8/settings.targets
 create mode 100644 src/libraries/pkg/test/frameworkSettings/portable46-net451+win81/settings.targets
 create mode 100644 src/libraries/pkg/test/packageSettings/System.Utf8String.Experimental/netcoreapp/DisableVerifyClosure.targets
 delete mode 100644 src/libraries/restore/Directory.Build.props
 delete mode 100644 src/libraries/restore/Directory.Build.targets
 delete mode 100644 src/libraries/restore/runtime/Directory.Build.props
 delete mode 100644 src/libraries/restore/runtime/runtime.depproj
 create mode 100644 src/tests/Interop/UnmanagedCallersOnly/InvalidCSharp.ilproj
 create mode 100644 src/tests/Interop/UnmanagedCallersOnly/InvalidCallbacks.il

diff --git a/Directory.Build.props b/Directory.Build.props
index b580851..db2a42a 100644
--- a/Directory.Build.props
+++ b/Directory.Build.props
@@ -108,9 +108,6 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <!-- Determine what architecture we are building on. -->
     <BuildArchitecture>$([System.Runtime.InteropServices.RuntimeInformation]::ProcessArchitecture.ToString().ToLowerInvariant())</BuildArchitecture>
-    
-    <!-- Turn off end of life target framework check as we still build for nca2.0 and nca3.0 some OOB libraries -->
-    <CheckEolTargetFramework>false</CheckEolTargetFramework>
   </PropertyGroup>
 
   <Import Project="$(RepositoryEngineeringDir)Analyzers.props" />
diff --git a/eng/Configurations.props b/eng/Configurations.props
index 3d123f8..532b746 100644
--- a/eng/Configurations.props
+++ b/eng/Configurations.props
@@ -68,5 +68,7 @@
     <EnableNgenOptimization Condition="'$(EnableNgenOptimization)' == '' and '$(Configuration)' == 'Release'">true</EnableNgenOptimization>
     <!-- Enable NuGet static graph evaluation to optimize incremental restore -->
     <RestoreUseStaticGraphEvaluation>true</RestoreUseStaticGraphEvaluation>
+    <!-- Turn off end of life target framework checks as we intentionally build older .NETCoreApp configurations. -->
+    <CheckEolTargetFramework>false</CheckEolTargetFramework>
   </PropertyGroup>
 </Project>
diff --git a/eng/Versions.props b/eng/Versions.props
index 07fa462..6fcbcfe 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -48,8 +48,6 @@
     <ProjectServicingConfiguration Include="Microsoft.NETCore.App.Ref" PatchVersion="0" />
   </ItemGroup>
   <PropertyGroup>
-    <!-- Pin compiler version to workaround: https://github.com/dotnet/runtime/issues/41100 -->
-    <MicrosoftNetCompilersToolsetVersion>3.8.0-2.20403.2</MicrosoftNetCompilersToolsetVersion>
     <!-- Arcade dependencies -->
     <MicrosoftDotNetApiCompatVersion>5.0.0-beta.20431.1</MicrosoftDotNetApiCompatVersion>
     <MicrosoftDotNetBuildTasksFeedVersion>5.0.0-beta.20431.1</MicrosoftDotNetBuildTasksFeedVersion>
diff --git a/eng/depProj.common.targets b/eng/depProj.common.targets
deleted file mode 100644
index b6d7360..0000000
--- a/eng/depProj.common.targets
+++ /dev/null
@@ -1,5 +0,0 @@
-<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
-<Project>
-  <Import Condition="'$(IsCrossTargetingBuild)' != 'true'" Project="depProj.targets" />
-  <Import Condition="'$(IsCrossTargetingBuild)' == 'true'" Project="$(MSBuildExtensionsPath)\Microsoft.Common.CrossTargeting.targets" />
-</Project>
diff --git a/eng/depProj.targets b/eng/depProj.targets
deleted file mode 100644
index 7cb63b0..0000000
--- a/eng/depProj.targets
+++ /dev/null
@@ -1,156 +0,0 @@
-<!--
-***********************************************************************************************
-depProj.targets
-
-WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
-          created a backup copy.  Incorrect changes to this file will make it
-          impossible to load or build your projects from the command-line or the IDE.
-
-This file defines the steps in the standard build process specific for NuGet deployment
-projects. The remainder of the build process is defined in Microsoft.Common.targets, 
-which is imported by this file.
-
-Licensed to the .NET Foundation under one or more agreements.
-The .NET Foundation licenses this file to you under the MIT license.
-***********************************************************************************************
--->
-<Project InitialTargets="RemoveImplicitPackageReferences">
-
-  <!-- Deployment project
-       Restores NuGet dependencies and copies them to the output directory.
-       
-       NuGetTargetMoniker - determined by the TargetFramework* and TargetPlatform* 
-                            properties of the project, can be overidden.
-       NuGetRuntimeIdentifier - defaults to <empty> (""), can be overidden.
-       NuGetDeploySourceItem - defaults to ReferenceCopyLocalPaths, can be overidden to
-                               specify Reference (for compile assets) or Analyzer(for
-                               analyzer assets)
-                         
-       For the appropriate behavior of P2P references the project should set the 
-       TargetName and TargetExt to match one of the files that will be copied
-       from the packages.
-  -->
-
-  <PropertyGroup>
-    <!-- Always raise runtime/lib items even for frameworks that may not use them -->
-    <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
-    <!-- We don't need the SDK to validate that we get runtime packages -->
-    <EnsureRuntimePackageDependencies>false</EnsureRuntimePackageDependencies>
-    <!-- don't generate netcoreapp files -->
-    <GenerateDependencyFile>false</GenerateDependencyFile>
-    <GenerateRuntimeConfigurationFiles>false</GenerateRuntimeConfigurationFiles>
-  </PropertyGroup>
-
-  <PropertyGroup>
-    <NuGetDeploySourceItem Condition="'$(NuGetDeploySourceItem)' == ''">ReferenceCopyLocalPaths</NuGetDeploySourceItem>
-
-    <!-- suppress the attempt to copy build output. -->
-    <CopyBuildOutputToOutputDirectory>false</CopyBuildOutputToOutputDirectory>
-
-    <!-- Unless overridden, use no runtime identifier. This is transformed in packageresolve.targets. 
-         We specify "None" here to avoid being assigned the default runtime for projects which set CopyNuGetImplementations=true. -->
-    <NuGetRuntimeIdentifier Condition="'$(NuGetRuntimeIdentifier)' == ''">None</NuGetRuntimeIdentifier>
-
-    <!-- make sure we tell nuget targets to copy, even if output type would not by default -->
-    <CopyNuGetImplementations>true</CopyNuGetImplementations>
-  </PropertyGroup>
-
-  <!-- This file results in importing the Build Target. -->
-  <Import Project="$(MSBuildToolsPath)\Microsoft.Common.targets" />
-
-  <Target Name="RemoveImplicitPackageReferences">
-    <ItemGroup>
-      <!-- Remove all implicit framework packages, depprojs are meant to be wholly explicit -->
-      <PackageReference Remove="@(PackageReference)" Condition="'%(PackageReference.IsImplicitlyDefined)' == 'true'" />
-    </ItemGroup>
-  </Target>
-
-  <Target Name="RunRestoreDuringBuild"
-          DependsOnTargets="Restore"
-          BeforeTargets="ResolvePackageAssets"
-          Condition="'$(VSDesignTimeBuild)' != 'true'" />
-
-  <Target Name="CoreCompile">
-
-    <Error Condition="'$(NuGetDeploySourceItem)' != 'ReferenceCopyLocalPaths' and
-                      '$(NuGetDeploySourceItem)' != 'Reference' and
-                      '$(NuGetDeploySourceItem)' != 'Analyzer'"
-           Text="Unexpected value for NuGetDeploySourceItem:'$(NuGetDeploySourceItem)'.  Expected ReferenceCopyLocalPaths, Reference, or Analyzer." />
-
-    <ItemGroup>
-      <!-- Don't set IntermediateAssembly since this is not produced -->
-      <IntermediateAssembly Remove="@(IntermediateAssembly)" />
-
-      <NuGetDeploy Include="@($(NuGetDeploySourceItem))"/>
-
-      <!-- filter to only items that came from packages -->
-      <!-- the following condition must be applied after the include because msbuild doesn't seem
-           to support property-defined-item-names in a metadata statement -->
-      <NuGetDeploy Remove="@(NuGetDeploy)" Condition="'%(NuGetDeploy.NuGetPackageId)' == ''" />
-
-      <!-- remove all existing items from NuGet packages we'll be defining these in our own item -->
-      <ReferenceCopyLocalPaths Remove="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.NuGetPackageId)' != ''"/>
-      <Reference Remove="@(Reference)" Condition="'%(Reference.NuGetPackageId)' != ''"/>
-      <Analyzer Remove="@(Analyzer)" Condition="'%(Analyzer.NuGetPackageId)' != ''"/>
-
-      <!-- add items defined by NuGetDeployItem property to Content so that we get clean behavior -->
-      <ContentWithTargetPath Include="@(NuGetDeploy)">
-        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-        <TargetPath>%(NuGetDeploy.SubFolder)%(FileName)%(Extension)</TargetPath>
-      </ContentWithTargetPath>
-    </ItemGroup>
-
-    <Message Importance="High"
-             Condition="'@(NuGetDeploy)' == ''"
-             Text="$(MSBuildProjectFile): No assets were resolved from NuGet packages." />
-    <Message Importance="High"
-             Condition="'@(NuGetDeploy)' != ''"
-             Text="%(FullPath) (%(NuGetPackageId).%(NuGetPackageVersion)) -&gt; @(NuGetDeploy->'$(TargetDir)%(SubFolder)%(FileName)%(Extension)')" />
-
-    <!-- Include marker files if an extension has been provided -->
-    <!-- internal builds use this to distinguish files which have already been signed -->
-    <Touch Condition="'$(DeployMarkerExtension)' != ''" Files="@(NuGetDeploy->'$(TargetDir)%(FileName)$(DeployMarkerExtension)')" AlwaysCreate="true">
-      <Output TaskParameter="TouchedFiles" ItemName="FileWrites"/>
-    </Touch>
-  </Target>
-
-  <!-- Required by Common.Targets but not used for depproj -->
-  <Target Name="CreateManifestResourceNames" />
-  
-  <Target Name="RemoveFrameworkReferences"
-          AfterTargets="ResolvePackageAssets">
-    <ItemGroup>
-      <ResolvedFrameworkAssemblies Remove="@(ResolvedFrameworkAssemblies)" Condition="'%(ResolvedFrameworkAssemblies.NuGetIsFrameworkReference)' == 'true'" />
-    </ItemGroup>
-  </Target>
-
-  <!-- Support filtering to a subset of packages or files -->
-  <Target Name="FilterNugetPackages" 
-          BeforeTargets="ResolveAssemblyReferences"
-          DependsOnTargets="ResolvePackageAssets"
-          Condition="'@(PackageToInclude)' != '' or '@(PackageToExclude)' != '' or '@(FileToInclude)' != '' or '@(FileToExclude)' != ''">
-    <ItemGroup>
-      <_nuGetDeploy Include="@($(NuGetDeploySourceItem))"/>
-      <_nuGetDeployByFileName Include="@(_nuGetDeploy->'%(FileName)')">
-        <OriginalItemSpec>%(Identity)</OriginalItemSpec>
-      </_nuGetDeployByFileName>
-
-      <_nuGetDeployByFileNameToRemove Include="@(_nuGetDeployByFileName)" Exclude="@(FileToInclude)" Condition="'@(FileToInclude)' != ''" />
-      <_filteredNuGetDeployByFileName Include="@(_nuGetDeployByFileName)" Exclude="@(_nuGetDeployByFileNameToRemove);@(FileToExclude)" />
-      
-      <_nuGetDeployByPackageId Include="@(_filteredNuGetDeployByFileName->'%(NuGetPackageId)')" />
-
-      <_nuGetDeployByPackageIdToRemove Include="@(_nuGetDeployByPackageId)" Exclude="@(PackageToInclude)" Condition="'@(PackageToInclude)' != ''" />
-      <_filteredNuGetDeployByPackageId Include="@(_nuGetDeployByPackageId)" Exclude="@(_nuGetDeployByPackageIdToRemove);@(PackageToExclude)" />
-
-      <ReferenceCopyLocalPaths Condition="'$(NuGetDeploySourceItem)' == 'ReferenceCopyLocalPaths'" Remove="@(ReferenceCopyLocalPaths)" />
-      <Reference Condition="'$(NuGetDeploySourceItem)' == 'Reference'" Remove="@(Reference)" />
-      <Analyzer Condition="'$(NuGetDeploySourceItem)' == 'Analyzer'" Remove="@(Analyzer)" />
-    </ItemGroup>
-    
-    <CreateItem Include="@(_filteredNuGetDeployByPackageId->'%(OriginalItemSpec)')">
-      <Output TaskParameter="Include" ItemName="$(NuGetDeploySourceItem)" />
-    </CreateItem>
-  </Target>
-
-</Project>
diff --git a/eng/restore/repoRestore.targets b/eng/restore/repoRestore.targets
index a430b67..d350ef5 100644
--- a/eng/restore/repoRestore.targets
+++ b/eng/restore/repoRestore.targets
@@ -1,7 +1,7 @@
 <Project InitialTargets="_ClearResolvePackageAssets" TreatAsLocalProperty="ExcludeRestorePackageImports">
   <PropertyGroup>
     <!-- Disable restoring of package references in our projects -->
-    <RestoreProjectStyle Condition="'$(MSBuildProjectExtension)' != '.depproj'">Unknown</RestoreProjectStyle>
+    <RestoreProjectStyle>Unknown</RestoreProjectStyle>
   </PropertyGroup>
 
   <PropertyGroup>
@@ -21,12 +21,9 @@
   Hack workaround for not restoring each project. Instead, we turn off all the targets
   that require a `project.assets.json`, since ours will be empty anyway.
   -->
-  <Target Name="_ClearResolvePackageAssets"
-          Condition="'$(MSBuildProjectExtension)' != '.depproj'">
-
+  <Target Name="_ClearResolvePackageAssets">
     <PropertyGroup>
-      <ResolvePackageDependenciesForBuildDependsOn></ResolvePackageDependenciesForBuildDependsOn>
+      <ResolvePackageDependenciesForBuildDependsOn />
     </PropertyGroup>
-
   </Target>
 </Project>
diff --git a/global.json b/global.json
index 18a166d..9e5f3f4 100644
--- a/global.json
+++ b/global.json
@@ -1,11 +1,11 @@
 {
   "sdk": {
-    "version": "5.0.100-preview.8.20362.3",
+    "version": "5.0.100-preview.8.20417.9",
     "allowPrerelease": true,
     "rollForward": "major"
   },
   "tools": {
-    "dotnet": "5.0.100-preview.8.20362.3"
+    "dotnet": "5.0.100-rc.1.20454.5"
   },
   "native-tools": {
     "cmake": "3.14.5",
@@ -18,7 +18,7 @@
     "Microsoft.DotNet.Helix.Sdk": "5.0.0-beta.20431.1",
     "Microsoft.FIX-85B6-MERGE-9C38-CONFLICT": "1.0.0",
     "Microsoft.NET.Sdk.IL": "5.0.0-preview.8.20359.4",
-    "Microsoft.Build.NoTargets": "1.0.53",
-    "Microsoft.Build.Traversal": "2.0.52"
+    "Microsoft.Build.NoTargets": "2.0.1",
+    "Microsoft.Build.Traversal": "2.1.1"
   }
 }
diff --git a/src/coreclr/src/System.Private.CoreLib/src/System/Runtime/InteropServices/Marshal.CoreCLR.cs b/src/coreclr/src/System.Private.CoreLib/src/System/Runtime/InteropServices/Marshal.CoreCLR.cs
index e81335a..b7da71c 100644
--- a/src/coreclr/src/System.Private.CoreLib/src/System/Runtime/InteropServices/Marshal.CoreCLR.cs
+++ b/src/coreclr/src/System.Private.CoreLib/src/System/Runtime/InteropServices/Marshal.CoreCLR.cs
@@ -729,7 +729,7 @@ public static unsafe int QueryInterface(IntPtr pUnk, ref Guid iid, out IntPtr pp
             fixed (Guid* pIID = &iid)
             fixed (IntPtr* p = &ppv)
             {
-                return ((delegate * stdcall <IntPtr, Guid*, IntPtr*, int>)(*(*(void***)pUnk + 0 /* IUnknown.QueryInterface slot */)))(pUnk, pIID, p);
+                return ((delegate* unmanaged<IntPtr, Guid*, IntPtr*, int>)(*(*(void***)pUnk + 0 /* IUnknown.QueryInterface slot */)))(pUnk, pIID, p);
             }
         }
 
@@ -739,7 +739,7 @@ public static unsafe int AddRef(IntPtr pUnk)
             if (pUnk == IntPtr.Zero)
                 throw new ArgumentNullException(nameof(pUnk));
 
-            return ((delegate * stdcall <IntPtr, int>)(*(*(void***)pUnk + 1 /* IUnknown.AddRef slot */)))(pUnk);
+            return ((delegate* unmanaged<IntPtr, int>)(*(*(void***)pUnk + 1 /* IUnknown.AddRef slot */)))(pUnk);
         }
 
         [SupportedOSPlatform("windows")]
@@ -748,7 +748,7 @@ public static unsafe int Release(IntPtr pUnk)
             if (pUnk == IntPtr.Zero)
                 throw new ArgumentNullException(nameof(pUnk));
 
-            return ((delegate * stdcall <IntPtr, int>)(*(*(void***)pUnk + 2 /* IUnknown.Release slot */)))(pUnk);
+            return ((delegate* unmanaged<IntPtr, int>)(*(*(void***)pUnk + 2 /* IUnknown.Release slot */)))(pUnk);
         }
 
         [SupportedOSPlatform("windows")]
diff --git a/src/coreclr/tests/issues.targets b/src/coreclr/tests/issues.targets
index 7dc5be5..93e4127 100644
--- a/src/coreclr/tests/issues.targets
+++ b/src/coreclr/tests/issues.targets
@@ -2719,4 +2719,9 @@
         </ExcludeList>
         <!-- End interpreter issues -->
     </ItemGroup>
+    <ItemGroup Condition=" '$(TargetArchitecture)' == 'wasm' " >
+        <ExcludeList Include = "$(XunitTestBinBase)/Interop/UnmanagedCallersOnly/UnmanagedCallersOnlyTest/**">
+            <Issue>https://github.com/dotnet/runtime/issues/41519</Issue>
+        </ExcludeList>
+    </ItemGroup>
 </Project>
diff --git a/src/libraries/Directory.Build.props b/src/libraries/Directory.Build.props
index 023ee93..74d1771 100644
--- a/src/libraries/Directory.Build.props
+++ b/src/libraries/Directory.Build.props
@@ -13,7 +13,6 @@
     <BeforeTargetFrameworkInferenceTargets>$(RepositoryEngineeringDir)BeforeTargetFrameworkInference.targets</BeforeTargetFrameworkInferenceTargets>
     <IsSourceProject>$([System.Text.RegularExpressions.Regex]::IsMatch($(MSBuildProjectDirectory), 'src%24'))</IsSourceProject>
     <IsReferenceAssembly Condition="'$(IsReferenceAssembly)' == '' and ($(MSBuildProjectFullPath.Contains('\ref\')) or $(MSBuildProjectFullPath.Contains('/ref/')))">true</IsReferenceAssembly>
-    <LanguageTargets Condition="'$(MSBuildProjectExtension)' == '.depproj'">$(RepositoryEngineeringDir)depProj.common.targets</LanguageTargets>
     <RuntimeGraph>$(LibrariesProjectRoot)OSGroups.json</RuntimeGraph>
     <ShouldUnsetParentConfigurationAndPlatform>false</ShouldUnsetParentConfigurationAndPlatform>
     <!-- Remove once is fixed: https://github.com/dotnet/roslyn/issues/42344 -->
@@ -287,7 +286,7 @@
   <Import Project="$(RepositoryEngineeringDir)referenceAssemblies.props" Condition="'$(IsReferenceAssembly)' == 'true'" />
 
   <PropertyGroup>
-    <DisableProjectRestore Condition="'$(MSBuildProjectExtension)' == '.depproj' or '$(MSBuildProjectExtension)' == '.pkgproj'">true</DisableProjectRestore>
+    <DisableProjectRestore Condition="'$(MSBuildProjectExtension)' == '.pkgproj'">true</DisableProjectRestore>
   </PropertyGroup>
 
   <Import Project="$(RepositoryEngineeringDir)restore\repoRestore.props" Condition="'$(DisableProjectRestore)' == 'true'" />
diff --git a/src/libraries/Directory.Build.targets b/src/libraries/Directory.Build.targets
index f171304..0ee2ea6 100644
--- a/src/libraries/Directory.Build.targets
+++ b/src/libraries/Directory.Build.targets
@@ -268,7 +268,7 @@
 
   <!-- The Default behavior in VS is to show files for the first target framework in TargetFrameworks property.
         This is required to show all the files corresponding to all target frameworks in VS. -->
-  <ItemGroup>
+  <ItemGroup Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(DesignTimeBuild)' == 'true'">
     <None Include="$(MSBuildProjectDirectory)\**\*.cs"
           Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder);@(Compile)" />
   </ItemGroup>
diff --git a/src/libraries/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/ComInterop/ComRuntimeHelpers.cs b/src/libraries/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/ComInterop/ComRuntimeHelpers.cs
index 0814a30..475c2c5 100644
--- a/src/libraries/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/ComInterop/ComRuntimeHelpers.cs
+++ b/src/libraries/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/ComInterop/ComRuntimeHelpers.cs
@@ -262,7 +262,7 @@ public static object GetObjectForVariant(Variant variant)
         // This method is intended for use through reflection and should only be used directly by IUnknownReleaseNotZero
         public static unsafe int IUnknownRelease(IntPtr interfacePointer)
         {
-            return ((delegate* stdcall<IntPtr, int>)(*(*(void***)interfacePointer + 2 /* IUnknown.Release slot */)))(interfacePointer);
+            return ((delegate* unmanaged<IntPtr, int>)(*(*(void***)interfacePointer + 2 /* IUnknown.Release slot */)))(interfacePointer);
         }
 
         // This method is intended for use through reflection and should not be used directly
@@ -291,7 +291,7 @@ public static void IUnknownReleaseNotZero(IntPtr interfacePointer)
             fixed (ExcepInfo* pExcepInfo = &excepInfo)
             fixed (uint* pArgErr = &argErr)
             {
-                var pfnIDispatchInvoke = (delegate* stdcall <IntPtr, int, Guid*, int, ushort, ComTypes.DISPPARAMS*, Variant*, ExcepInfo*, uint*, int>)
+                var pfnIDispatchInvoke = (delegate* unmanaged<IntPtr, int, Guid*, int, ushort, ComTypes.DISPPARAMS*, Variant*, ExcepInfo*, uint*, int>)
                     (*(*(void***)dispatchPointer + 6 /* IDispatch.Invoke slot */));
 
                 int hresult = pfnIDispatchInvoke(dispatchPointer,
diff --git a/src/libraries/System.Formats.Cbor/tests/CborDocument/System.Formats.Cbor.Tests.DataModel.fsproj b/src/libraries/System.Formats.Cbor/tests/CborDocument/System.Formats.Cbor.Tests.DataModel.fsproj
index 94a84cc..d534e09 100644
--- a/src/libraries/System.Formats.Cbor/tests/CborDocument/System.Formats.Cbor.Tests.DataModel.fsproj
+++ b/src/libraries/System.Formats.Cbor/tests/CborDocument/System.Formats.Cbor.Tests.DataModel.fsproj
@@ -2,6 +2,8 @@
 
   <PropertyGroup>
     <TargetFrameworks>$(NetCoreAppCurrent)</TargetFrameworks>
+    <!-- NuGet restore issue with TargetFrameworks in f# projects: https://github.com/NuGet/Home/issues/10005 -->
+    <TargetFramework>$(NetCoreAppCurrent)</TargetFramework>
   </PropertyGroup>
 
   <ItemGroup>
@@ -13,4 +15,4 @@
   <ItemGroup>
       <ProjectReference Include="..\..\src\System.Formats.Cbor.csproj" />
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/libraries/System.Net.HttpListener/src/System/Net/Windows/WebSockets/HttpWebSocket.Windows.cs b/src/libraries/System.Net.HttpListener/src/System/Net/Windows/WebSockets/HttpWebSocket.Windows.cs
index 18c1787..6eb7bd0 100644
--- a/src/libraries/System.Net.HttpListener/src/System/Net/Windows/WebSockets/HttpWebSocket.Windows.cs
+++ b/src/libraries/System.Net.HttpListener/src/System/Net/Windows/WebSockets/HttpWebSocket.Windows.cs
@@ -3,6 +3,7 @@
 
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
 using System.Runtime.CompilerServices;
@@ -197,6 +198,7 @@ internal static void ThrowIfConnectionAborted(Stream connection, bool read)
             }
         }
 
+        [DoesNotReturn]
         internal static void ThrowPlatformNotSupportedException_WSPC()
         {
             throw new PlatformNotSupportedException(SR.net_WebSockets_UnsupportedPlatform);
diff --git a/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventCounter.cs b/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventCounter.cs
index 54660aa..9d14c88 100644
--- a/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventCounter.cs
+++ b/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventCounter.cs
@@ -42,7 +42,7 @@ public EventCounter(string name, EventSource eventSource) : base(name, eventSour
             {
                 bufferedValues[i] = UnusedBufferSlotValue;
             }
-            Volatile.Write(ref _bufferedValues, bufferedValues);
+            _bufferedValues = bufferedValues;
 
             Publish();
         }
diff --git a/src/libraries/externals.csproj b/src/libraries/externals.csproj
new file mode 100644
index 0000000..3c79111
--- /dev/null
+++ b/src/libraries/externals.csproj
@@ -0,0 +1,94 @@
+﻿<Project Sdk="Microsoft.Build.NoTargets">
+  <PropertyGroup>
+    <!-- Set the RuntimeIdentifier so that the DotNetHost and DotNetHostPolicy packages resolve for the corresponding runtime. -->
+    <RuntimeIdentifier>$(PackageRID)</RuntimeIdentifier>
+    <SwapNativeForIL Condition="'$(SwapNativeForIL)' == '' and ('$(Configuration)' == 'Debug' or '$(Coverage)' == 'true') and '$(RuntimeFlavor)' != 'Mono'">true</SwapNativeForIL>
+    <TargetFrameworks>$(NetCoreAppCurrent)</TargetFrameworks>
+    <!-- Binplace properties -->
+    <BinPlaceForTargetVertical>false</BinPlaceForTargetVertical>
+    <BinPlaceNative>true</BinPlaceNative>
+    <BinPlaceRuntime>false</BinPlaceRuntime>
+    <DisableImplicitFrameworkReferences>true</DisableImplicitFrameworkReferences>
+    <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
+  </PropertyGroup>
+
+  <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true'">
+    <PackageReference Include="Microsoft.DiaSymReader.Native"
+                      Version="$(MicrosoftDiaSymReaderNativeVersion)" />
+  </ItemGroup>
+
+  <ItemGroup Condition="'$(TargetsMobile)' != 'true'">
+    <PackageReference Include="Microsoft.NETCore.DotNetHost"
+                      Version="$(MicrosoftNETCoreDotNetHostVersion)" />
+    <PackageReference Include="Microsoft.NETCore.DotNetHostPolicy"
+                      Version="$(MicrosoftNETCoreDotNetHostPolicyVersion)" />
+    <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.0" PrivateAssets="All" />
+  </ItemGroup>
+
+  <!-- Setup the testing shared framework host -->
+  <Target Name="SetupTestingHost"
+          AfterTargets="AfterResolveReferences">
+    <PropertyGroup>
+      <UseHardlink>true</UseHardlink>
+      <!-- workaround core-setup problem for hardlinking dotnet executable to testhost: core-setup #4742 -->
+      <UseHardlink Condition="'$(_runtimeOSFamily)' == 'FreeBSD'">false</UseHardlink>
+    </PropertyGroup>
+
+    <!-- We do not need apphost.exe.
+         Exclude here so that when building with the 2.x SDK we don't place it in the test shared framework. -->
+    <ItemGroup>
+      <ReferenceCopyLocalPaths Remove="@(ReferenceCopyLocalPaths)" Condition="'%(Filename)' == 'apphost'" />
+    </ItemGroup>
+
+    <ItemGroup>
+      <HostFxFile Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.Filename)' == 'hostfxr' or
+                                                                  '%(ReferenceCopyLocalPaths.Filename)' == 'libhostfxr'" />
+      <DotnetExe Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.Filename)' == 'dotnet'" />
+    </ItemGroup>
+
+    <Copy SourceFiles="@(HostFxFile)"
+          DestinationFolder="$(TestHostRootPath)host\fxr\$(ProductVersion)"
+          SkipUnchangedFiles="true"
+          UseHardlinksIfPossible="$(UseHardlink)" />
+
+    <Copy SourceFiles="@(DotnetExe)"
+          DestinationFolder="$(TestHostRootPath)"
+          SkipUnchangedFiles="true"
+          UseHardlinksIfPossible="$(UseHardlink)" />
+
+    <Exec Command="chmod +x $(TestHostRootPath)%(DotnetExe.Filename)%(DotnetExe.Extension) || true" Condition="'$(TargetOS)' != 'Windows_NT' and '$(OS)' != 'Windows_NT'"/>
+  </Target>
+
+  <Target Name="OverrideRuntimeCoreCLR"
+          DependsOnTargets="ResolveRuntimeFilesFromLocalBuild"
+          AfterTargets="AfterResolveReferences"
+          Condition="'$(RuntimeFlavor)' != 'Mono'">
+    <ItemGroup>
+      <!-- CoreRun is not used for testing anymore, but we still use it for benchmarking and profiling -->
+      <RuntimeFiles Include="$(CoreCLRArtifactsPath)\corerun*" />
+      <RuntimeFiles Include="$(CoreCLRArtifactsPath)\PDB\corerun*" />
+      <ReferenceCopyLocalPaths Include="@(RuntimeFiles)" />
+    </ItemGroup>
+    <ItemGroup Condition="'$(SwapNativeForIL)' == 'true'">
+      <CoreCLRILFiles Include="$(CoreCLRArtifactsPath)\IL\*.*" />
+      <ReferenceCopyLocalPaths Remove="@(ReferenceCopyLocalPaths)" Condition="'@(CoreCLRILFiles->'%(FileName)%(Extension)')' == '%(FileName)%(Extension)'" />
+      <ReferenceCopyLocalPaths Remove="@(ReferenceCopyLocalPaths)" Condition="'@(CoreCLRILFiles->'%(FileName).ni%(Extension)')' == '%(FileName)%(Extension)'" />
+      <ReferenceCopyLocalPaths Include="@(CoreCLRILFiles)" />
+    </ItemGroup>
+    <Error Condition="'$(SwapNativeForIL)' == 'true' and '@(CoreCLRILFiles)' == ''" Text="Could not locate CoreCLR IL files." />
+  </Target>
+
+  <Target Name="OverrideRuntimeMono"
+          DependsOnTargets="ResolveRuntimeFilesFromLocalBuild"
+          AfterTargets="AfterResolveReferences"
+          Condition="'$(RuntimeFlavor)' == 'Mono'">
+    <ItemGroup>
+      <ReferenceCopyLocalPaths Include="@(RuntimeFiles)" />
+      <!-- Setup runtime pack native. -->
+      <ReferenceCopyLocalPaths Include="@(MonoCrossFiles)"
+                               DestinationSubDirectory="cross/" />
+      <ReferenceCopyLocalPaths Include="@(MonoIncludeFiles)"
+                               DestinationSubDirectory="include/%(RecursiveDir)" />
+    </ItemGroup>
+  </Target>
+</Project>
diff --git a/src/libraries/pkg/test/frameworkSettings/netcore50/settings.targets b/src/libraries/pkg/test/frameworkSettings/netcore50/settings.targets
new file mode 100644
index 0000000..b54cf42
--- /dev/null
+++ b/src/libraries/pkg/test/frameworkSettings/netcore50/settings.targets
@@ -0,0 +1,5 @@
+<Project>
+  <PropertyGroup>
+    <TargetPlatformMinVersion>10.0.0</TargetPlatformMinVersion>
+  </PropertyGroup>
+</Project>
\ No newline at end of file
diff --git a/src/libraries/pkg/test/frameworkSettings/portable-net45+win8+wp8+wpa81/settings.targets b/src/libraries/pkg/test/frameworkSettings/portable-net45+win8+wp8+wpa81/settings.targets
new file mode 100644
index 0000000..72095ad
--- /dev/null
+++ b/src/libraries/pkg/test/frameworkSettings/portable-net45+win8+wp8+wpa81/settings.targets
@@ -0,0 +1,7 @@
+<Project>
+  <PropertyGroup>
+    <TargetFrameworkIdentifier>.NETPortable</TargetFrameworkIdentifier>
+    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile>Profile259</TargetFrameworkProfile>
+  </PropertyGroup>
+</Project>
\ No newline at end of file
diff --git a/src/libraries/pkg/test/frameworkSettings/portable-net45+win8+wpa81/settings.targets b/src/libraries/pkg/test/frameworkSettings/portable-net45+win8+wpa81/settings.targets
new file mode 100644
index 0000000..77255b7
--- /dev/null
+++ b/src/libraries/pkg/test/frameworkSettings/portable-net45+win8+wpa81/settings.targets
@@ -0,0 +1,7 @@
+<Project>
+  <PropertyGroup>
+    <TargetFrameworkIdentifier>.NETPortable</TargetFrameworkIdentifier>
+    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile>Profile111</TargetFrameworkProfile>
+  </PropertyGroup>
+</Project>
\ No newline at end of file
diff --git a/src/libraries/pkg/test/frameworkSettings/portable-net45+win8/settings.targets b/src/libraries/pkg/test/frameworkSettings/portable-net45+win8/settings.targets
new file mode 100644
index 0000000..e488ebf
--- /dev/null
+++ b/src/libraries/pkg/test/frameworkSettings/portable-net45+win8/settings.targets
@@ -0,0 +1,7 @@
+<Project>
+  <PropertyGroup>
+    <TargetFrameworkIdentifier>.NETPortable</TargetFrameworkIdentifier>
+    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile>Profile7</TargetFrameworkProfile>
+  </PropertyGroup>
+</Project>
\ No newline at end of file
diff --git a/src/libraries/pkg/test/frameworkSettings/portable45-net45+win8/settings.targets b/src/libraries/pkg/test/frameworkSettings/portable45-net45+win8/settings.targets
new file mode 100644
index 0000000..e488ebf
--- /dev/null
+++ b/src/libraries/pkg/test/frameworkSettings/portable45-net45+win8/settings.targets
@@ -0,0 +1,7 @@
+<Project>
+  <PropertyGroup>
+    <TargetFrameworkIdentifier>.NETPortable</TargetFrameworkIdentifier>
+    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+    <TargetFrameworkProfile>Profile7</TargetFrameworkProfile>
+  </PropertyGroup>
+</Project>
\ No newline at end of file
diff --git a/src/libraries/pkg/test/frameworkSettings/portable46-net451+win81/settings.targets b/src/libraries/pkg/test/frameworkSettings/portable46-net451+win81/settings.targets
new file mode 100644
index 0000000..463ffc6
--- /dev/null
+++ b/src/libraries/pkg/test/frameworkSettings/portable46-net451+win81/settings.targets
@@ -0,0 +1,7 @@
+<Project>
+  <PropertyGroup>
+    <TargetFrameworkIdentifier>.NETPortable</TargetFrameworkIdentifier>
+    <TargetFrameworkVersion>v4.6</TargetFrameworkVersion>
+    <TargetFrameworkProfile>Profile44</TargetFrameworkProfile>
+  </PropertyGroup>
+</Project>
\ No newline at end of file
diff --git a/src/libraries/pkg/test/packageSettings/System.Utf8String.Experimental/netcoreapp/DisableVerifyClosure.targets b/src/libraries/pkg/test/packageSettings/System.Utf8String.Experimental/netcoreapp/DisableVerifyClosure.targets
new file mode 100644
index 0000000..a5776c4
--- /dev/null
+++ b/src/libraries/pkg/test/packageSettings/System.Utf8String.Experimental/netcoreapp/DisableVerifyClosure.targets
@@ -0,0 +1,7 @@
+<Project>
+  <PropertyGroup>
+    <!-- Utf8String reference depends on System.Private.CoreLib on net5.0 so we can't run
+         Verify Closure on it. -->
+    <ShouldVerifyClosure>false</ShouldVerifyClosure>
+  </PropertyGroup>
+</Project>
\ No newline at end of file
diff --git a/src/libraries/pkg/test/packageTest.targets b/src/libraries/pkg/test/packageTest.targets
index 4aa0b3e..53f608f 100644
--- a/src/libraries/pkg/test/packageTest.targets
+++ b/src/libraries/pkg/test/packageTest.targets
@@ -3,6 +3,8 @@
   <PropertyGroup>
     <_targetFrameworkVersionIndex>$(TargetFramework.IndexOfAny(".-0123456789"))</_targetFrameworkVersionIndex>
     <_targetFrameworkIdentifier Condition="'$(_runtimeOSVersionIndex)' != '-1'">$(TargetFramework.SubString(0, $(_targetFrameworkVersionIndex)))</_targetFrameworkIdentifier>
+    <!-- For net5.0 and later use netcoreapp folder. -->
+    <_targetFrameworkIdentifier Condition="'$(_targetFrameworkIdentifier)' == 'net' and !$(TargetFramework.StartsWith('net4'))">netcoreapp</_targetFrameworkIdentifier>
     <ToolsDir>$(MSBuildThisFileDirectory)tools\</ToolsDir>
 
     <RestoreSources>
diff --git a/src/libraries/pkg/test/project.csproj.template b/src/libraries/pkg/test/project.csproj.template
index d78e153..dec755e 100644
--- a/src/libraries/pkg/test/project.csproj.template
+++ b/src/libraries/pkg/test/project.csproj.template
@@ -5,6 +5,8 @@
     <RuntimeIdentifiers>{RIDs}</RuntimeIdentifiers>
     <TestPackageId>{PackageId}</TestPackageId>
     <TestPackageVersion>{PackageVersion}</TestPackageVersion>
+    <!-- Turn off end of life target framework checks as we intentionally build older .NETCoreApp configurations. -->
+    <CheckEolTargetFramework>false</CheckEolTargetFramework>
 
     <SupportFilesDir Condition="'$(SupportFilesDir)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory), Directory.Build.props))\support</SupportFilesDir>
   </PropertyGroup>
diff --git a/src/libraries/pretest.proj b/src/libraries/pretest.proj
index 5cd55be..a2b807d 100644
--- a/src/libraries/pretest.proj
+++ b/src/libraries/pretest.proj
@@ -8,22 +8,22 @@
   </PropertyGroup>
 
   <!--
-    Explicitly build the runtime.depproj project first to create the PlatformManifest for
+    Explicitly build the externals.csproj project first to create the PlatformManifest for
     the targeting and runtimepack before the test runners which consume that asset are built.
   -->
   <ItemGroup>
-    <RuntimeProject Include="$(MSBuildThisFileDirectory)restore\runtime\runtime.depproj" />
-    <ProjectReference Include="@(RuntimeProject)" Condition="'$(MSBuildRestoreSessionId)' != ''" />
+    <ExternalsProject Include="externals.csproj" />
+    <ProjectReference Include="@(ExternalsProject)" Condition="'$(MSBuildRestoreSessionId)' != ''" />
 
     <ProjectReference Include="$(CommonTestPath)AppleTestRunner\AppleTestRunner.csproj" Condition="'$(TargetOS)' == 'iOS' or '$(TargetOS)' == 'tvOS'"/>
     <ProjectReference Include="$(CommonTestPath)AndroidTestRunner\AndroidTestRunner.csproj" Condition="'$(TargetOS)' == 'Android'" />
     <ProjectReference Include="$(CommonTestPath)WasmTestRunner\WasmTestRunner.csproj" Condition="'$(TargetOS)' == 'Browser'" />
   </ItemGroup>
   
-  <Target Name="RestoreRuntimeDepproj"
+  <Target Name="BuildExternalsProject"
           BeforeTargets="Build">
     <MSBuild Targets="Build"
-             Projects="@(RuntimeProject)"
+             Projects="@(ExternalsProject)"
              Properties="$(TraversalGlobalProperties)" />
   </Target>
 
@@ -48,7 +48,7 @@
   <UsingTask TaskName="GenerateFileVersionProps" AssemblyFile="$(InstallerTasksAssemblyPath)"/>
   <Target Name="GenerateFileVersionPropsRuntimePack"
           DependsOnTargets="GetSharedFrameworkRuntimeFiles"
-          AfterTargets="RestoreRuntimeDepproj"
+          AfterTargets="BuildExternalsProject"
           Inputs="@(SharedFrameworkRuntimeFile)"
           Outputs="$(MicrosoftNetCoreAppRuntimePackDir)data\PlatformManifest.txt"
           Condition="'$(BuildingNETCoreAppVertical)' == 'true'">
@@ -63,7 +63,7 @@
   <!-- Generate the ref pack's PlatformManifest -->
   <Target Name="GenerateFileVersionPropsRefPack"
           DependsOnTargets="GetSharedFrameworkRuntimeFiles"
-          AfterTargets="RestoreRuntimeDepproj"
+          AfterTargets="BuildExternalsProject"
           Inputs="@(SharedFrameworkRuntimeFile)"
           Outputs="$(MicrosoftNetCoreAppRefPackDataDir)PlatformManifest.txt"
           Condition="'$(BuildingNETCoreAppVertical)' == 'true'">
@@ -78,7 +78,7 @@
   <!-- Generate the shared framework's deps.json -->
   <UsingTask TaskName="GenerateTestSharedFrameworkDepsFile" AssemblyFile="$(InstallerTasksAssemblyPath)"/>
   <Target Name="GenerateTestSharedFrameworkAssets"
-          AfterTargets="RestoreRuntimeDepproj"
+          AfterTargets="BuildExternalsProject"
           Inputs="$(NETCoreAppTestSharedFrameworkPath)*.*"
           Outputs="$(NETCoreAppTestSharedFrameworkPath)$(SharedFrameworkName).deps.json"
           Condition="'$(BinPlaceTestSharedFramework)' == 'true'">
@@ -117,7 +117,7 @@
   <UsingTask TaskName="CreateFrameworkListFile" AssemblyFile="$(DotNetBuildTasksSharedFrameworkTaskFile)"/>
   <Target Name="GenerateRuntimeListFile"
           DependsOnTargets="GetRuntimePackFiles"
-          AfterTargets="RestoreRuntimeDepproj"
+          AfterTargets="BuildExternalsProject"
           Inputs="@(RuntimePackLibFile);@(RuntimePackNativeFile)"
           Outputs="$(MicrosoftNetCoreAppRuntimePackDir)data\RuntimeList.xml"
           Condition="'$(BuildingNETCoreAppVertical)' == 'true'">
diff --git a/src/libraries/restore/Directory.Build.props b/src/libraries/restore/Directory.Build.props
deleted file mode 100644
index 4cc2380..0000000
--- a/src/libraries/restore/Directory.Build.props
+++ /dev/null
@@ -1,23 +0,0 @@
-<Project>
-  <Import Project="..\Directory.Build.props" />
-
-  <PropertyGroup>
-    <!-- We need configuration-specific assets files which requires the IntermeidateOutputPath to be set. -->
-    <IntermediateOutputPath>$([MSBuild]::NormalizeDirectory('$(BaseIntermediateOutputPath)', '$(TargetFramework)-$(TargetFrameworkSuffix)-$(Configuration)'))</IntermediateOutputPath>
-    <IntermediateOutputPath Condition="'$(TargetFrameworkSuffix)' == ''">$([MSBuild]::NormalizeDirectory('$(BaseIntermediateOutputPath)', '$(TargetFramework)-$(Configuration)'))</IntermediateOutputPath>
-    <RestoreOutputPath>$(IntermediateOutputPath)</RestoreOutputPath>
-    <ProjectAssetsFile>$(RestoreOutputPath)/project.assets.json</ProjectAssetsFile>
-    <MSBuildProjectExtensionsPath>$(IntermediateOutputPath)</MSBuildProjectExtensionsPath>
-
-    <SkipDeriveTargetFrameworks>true</SkipDeriveTargetFrameworks>
-    <AppendRuntimeIdentifierToOutputPath>false</AppendRuntimeIdentifierToOutputPath>
-  </PropertyGroup>
-  
-  <!-- don't bring in props/targets from packages, we're not consuming them we're
-       deploying them -->
-  <ItemDefinitionGroup>
-    <PackageReference>
-      <ExcludeAssets>Build</ExcludeAssets>
-    </PackageReference>
-  </ItemDefinitionGroup>
-</Project>
diff --git a/src/libraries/restore/Directory.Build.targets b/src/libraries/restore/Directory.Build.targets
deleted file mode 100644
index 785efcc..0000000
--- a/src/libraries/restore/Directory.Build.targets
+++ /dev/null
@@ -1,7 +0,0 @@
-<Project>
-  <Import Project="..\Directory.Build.targets" />
-
-  <PropertyGroup>
-    <PrereleaseResolveNuGetPackages>true</PrereleaseResolveNuGetPackages>
-  </PropertyGroup>
-</Project>
diff --git a/src/libraries/restore/runtime/Directory.Build.props b/src/libraries/restore/runtime/Directory.Build.props
deleted file mode 100644
index dacf9d9..0000000
--- a/src/libraries/restore/runtime/Directory.Build.props
+++ /dev/null
@@ -1,7 +0,0 @@
-<Project>
-  <PropertyGroup>
-    <OutDirName>external.$(MSBuildProjectName)</OutDirName>
-  </PropertyGroup>
-
-  <Import Project="..\Directory.Build.props" />
-</Project>
\ No newline at end of file
diff --git a/src/libraries/restore/runtime/runtime.depproj b/src/libraries/restore/runtime/runtime.depproj
deleted file mode 100644
index 942e0fe..0000000
--- a/src/libraries/restore/runtime/runtime.depproj
+++ /dev/null
@@ -1,110 +0,0 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
-  <PropertyGroup>
-    <RuntimeIdentifier>$(PackageRID)</RuntimeIdentifier>
-    <NoWarn>$(NoWarn);NU1603;NU1605</NoWarn>
-    <SwapNativeForIL Condition="'$(SwapNativeForIL)' == '' and ('$(Configuration)' == 'Debug' or '$(Coverage)' == 'true') and '$(RuntimeFlavor)' != 'Mono'">true</SwapNativeForIL>
-    <BinPlaceForTargetVertical>false</BinPlaceForTargetVertical>
-    <BinPlaceNative>true</BinPlaceNative>
-    <BinPlaceRuntime>false</BinPlaceRuntime>
-    <TargetFrameworks>$(NetCoreAppCurrent)-Windows_NT;$(NetCoreAppCurrent)-Unix;$(NetCoreAppCurrent)-Browser</TargetFrameworks>
-  </PropertyGroup>
-
-  <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true'">
-    <PackageReference Include="Microsoft.DiaSymReader.Native" Version="1.7.0" />
-  </ItemGroup>
-
-  <ItemGroup Condition="'$(TargetsMobile)' != 'true'">
-    <PackageReference Include="Microsoft.NETCore.DotNetHost" Version="$(MicrosoftNETCoreDotNetHostVersion)" />
-    <PackageReference Include="Microsoft.NETCore.DotNetHostPolicy" Version="$(MicrosoftNETCoreDotNetHostPolicyVersion)" />
-    <!-- We do not need apphost.exe and the 3.0 SDK will actually remove it.
-         Exclude here so that when building with the 2.x SDK we don't place it in the test shared framework.
-         This can be removed once we have a new SDK -->
-    <FileToExclude Include="apphost" />
-    <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.0" PrivateAssets="All" />
-  </ItemGroup>
-
-  <!-- Setup the testing shared framework host -->
-  <Target Name="SetupTestingHost"
-          Condition="'$(BinPlaceTestSharedFramework)' == 'true'"
-          AfterTargets="AfterResolveReferences">
-    <PropertyGroup>
-      <HostFxrFileName Condition="'$(TargetsWindows)' == 'true'">hostfxr</HostFxrFileName>
-      <HostFxrFileName Condition="'$(TargetsWindows)' != 'true'">libhostfxr</HostFxrFileName>
-      <HostPolicyFileName Condition="'$(TargetsWindows)' == 'true'">hostpolicy</HostPolicyFileName>
-      <HostPolicyFileName Condition="'$(TargetsWindows)' != 'true'">libhostpolicy</HostPolicyFileName>
-
-      <UseHardlink>true</UseHardlink>
-      <!-- workaround core-setup problem for hardlinking dotnet executable to testhost: core-setup #4742 -->
-      <UseHardlink Condition="'$(_runtimeOSFamily)' == 'FreeBSD'">false</UseHardlink>
-    </PropertyGroup>
-
-    <ItemGroup>
-      <HostFxFile Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.Filename)' == '$(HostFxrFileName)'" />
-      <DotnetExe Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.Filename)' == 'dotnet'" />
-    </ItemGroup>
-
-    <Copy SourceFiles="@(HostFxFile)"
-          DestinationFolder="$(TestHostRootPath)host\fxr\$(ProductVersion)"
-          SkipUnchangedFiles="true"
-          UseHardlinksIfPossible="$(UseHardlink)" />
-
-    <Copy SourceFiles="@(DotnetExe)"
-          DestinationFolder="$(TestHostRootPath)"
-          SkipUnchangedFiles="true"
-          UseHardlinksIfPossible="$(UseHardlink)" />
-
-    <Exec Command="chmod +x $(TestHostRootPath)%(DotnetExe.Filename)%(DotnetExe.Extension) || true" Condition="'$(TargetOS)' != 'Windows_NT' and '$(OS)' != 'Windows_NT'"/>
-  </Target>
-
-  <Target Name="OverrideRuntimeCoreCLR"
-          DependsOnTargets="ResolveRuntimeFilesFromLocalBuild"
-          AfterTargets="AfterResolveReferences;FilterNugetPackages"
-          Condition="'$(RuntimeFlavor)' != 'Mono'">
-    <ItemGroup>
-      <!-- CoreRun is not used for testing anymore, but we still use it for benchmarking and profiling -->
-      <RuntimeFiles Include="$(CoreCLRArtifactsPath)/corerun*" />
-      <RuntimeFiles Include="$(CoreCLRArtifactsPath)/PDB/corerun*" />
-      <ReferenceCopyLocalPaths Include="@(RuntimeFiles)" />
-    </ItemGroup>
-  </Target>
-
-  <Target Name="OverrideRuntimeMono"
-          DependsOnTargets="ResolveRuntimeFilesFromLocalBuild"
-          AfterTargets="AfterResolveReferences;FilterNugetPackages"
-          Condition="'$(RuntimeFlavor)' == 'Mono'">
-    <ItemGroup>
-      <ReferenceCopyLocalPaths Include="@(RuntimeFiles)" />
-      <!-- Setup runtime pack native. -->
-      <ReferenceCopyLocalPaths Include="@(MonoCrossFiles)"
-                               DestinationSubDirectory="cross/" />
-      <ReferenceCopyLocalPaths Include="@(MonoIncludeFiles)"
-                               DestinationSubDirectory="include/%(RecursiveDir)" />
-    </ItemGroup>
-  </Target>
-
-  <Target Name="GetCoreCLRILFiles" DependsOnTargets="ResolveRuntimeFilesFromLocalBuild">
-    <ItemGroup>
-      <CoreCLRILFiles Include="$(CoreCLRArtifactsPath)/IL/*.*" />
-    </ItemGroup>
-    <Error Condition="'@(CoreCLRILFiles)' == ''" Text="Could not locate CoreCLR IL files." />
-  </Target>
-
-  <Target Name="SwapNativeForIL"
-          AfterTargets="AfterResolveReferences"
-          DependsOnTargets="GetCoreCLRILFiles;OverrideRuntimeCoreCLR"
-          Condition="'$(SwapNativeForIL)' == 'true'">
-      <ItemGroup>
-        <ReferenceCopyLocalPaths Remove="@(ReferenceCopyLocalPaths)" Condition="'@(CoreCLRILFiles->'%(FileName)%(Extension)')' == '%(FileName)%(Extension)'" />
-        <ReferenceCopyLocalPaths Remove="@(ReferenceCopyLocalPaths)" Condition="'@(CoreCLRILFiles->'%(FileName).ni%(Extension)')' == '%(FileName)%(Extension)'" />
-        <ReferenceCopyLocalPaths Include="@(CoreCLRILFiles)" />
-      </ItemGroup>
-  </Target>
-
-  <!-- Strip away placeholder tfms and TargetFrameworkSuffix. -->
-  <Target Name="StripTargetFrameworkSuffixFromTargetFrameworks"
-          BeforeTargets="_GetRestoreTargetFrameworksOutput;_GetRestoreTargetFrameworksAsItems">
-    <PropertyGroup>
-      <TargetFrameworks Condition="'$(TargetFrameworks)' != ''">$([System.Text.RegularExpressions.Regex]::Replace('$(TargetFrameworks)', '-[^;]+', ''))</TargetFrameworks>
-    </PropertyGroup>
-  </Target>
-</Project>
diff --git a/src/tests/Interop/UnmanagedCallersOnly/InvalidCSharp.ilproj b/src/tests/Interop/UnmanagedCallersOnly/InvalidCSharp.ilproj
new file mode 100644
index 0000000..b7b8b4d
--- /dev/null
+++ b/src/tests/Interop/UnmanagedCallersOnly/InvalidCSharp.ilproj
@@ -0,0 +1,8 @@
+<Project Sdk="Microsoft.NET.Sdk.IL">
+  <PropertyGroup>
+    <OutputType>library</OutputType>
+  </PropertyGroup>
+  <ItemGroup>
+    <Compile Include="InvalidCallbacks.il" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src/tests/Interop/UnmanagedCallersOnly/InvalidCallbacks.il b/src/tests/Interop/UnmanagedCallersOnly/InvalidCallbacks.il
new file mode 100644
index 0000000..bd39136
--- /dev/null
+++ b/src/tests/Interop/UnmanagedCallersOnly/InvalidCallbacks.il
@@ -0,0 +1,75 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+.assembly extern System.Runtime { }
+.assembly extern System.Runtime.InteropServices { }
+
+.assembly InvalidCSharp { }
+
+.class public auto ansi beforefieldinit InvalidCSharp.GenericClass`1<T>
+    extends System.Object
+{
+    .method public hidebysig static 
+        void CallbackMethod (
+            int32 n
+        ) cil managed preservesig 
+    {
+        .custom instance void [System.Runtime.InteropServices]System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute::.ctor() = (
+            01 00 00 00
+        )
+        .maxstack 8
+        IL_0000: ldstr "Functions with attribute UnmanagedCallersOnlyAttribute within a generic type are invalid"
+        IL_0005: newobj instance void [System.Runtime]System.Exception::.ctor(string)
+        IL_000a: throw
+    }
+
+    .method public hidebysig specialname rtspecialname 
+        instance void .ctor () cil managed 
+    {
+        .maxstack 8
+        IL_0000: ldarg.0
+        IL_0001: call instance void [System.Runtime]System.Object::.ctor()
+        IL_0006: ret
+    }
+}
+
+.class public auto ansi beforefieldinit InvalidCSharp.Callbacks
+    extends [System.Runtime]System.Object
+{
+    .method public hidebysig static 
+        int32 CallbackMethodGeneric<T> (
+            !!T arg
+        ) cil managed preservesig 
+    {
+        .custom instance void [System.Runtime.InteropServices]System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute::.ctor() = (
+            01 00 00 00
+        )
+        .maxstack 8
+        IL_0000: ldstr "Functions with attribute UnmanagedCallersOnlyAttribute cannot have generic arguments"
+        IL_0005: newobj instance void [System.Runtime]System.Exception::.ctor(string)
+        IL_000a: throw
+    }
+
+    .method public hidebysig 
+        instance int32 CallbackNonStatic (
+            int32 val
+        ) cil managed preservesig 
+    {
+        .custom instance void [System.Runtime.InteropServices]System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute::.ctor() = (
+            01 00 00 00
+        )
+        .maxstack 8
+        IL_0000: ldstr "Instance functions with attribute UnmanagedCallersOnlyAttribute are invalid"
+        IL_0005: newobj instance void [System.Runtime]System.Exception::.ctor(string)
+        IL_000a: throw
+    }
+
+    .method public hidebysig specialname rtspecialname 
+        instance void .ctor () cil managed 
+    {
+        .maxstack 8
+        IL_0000: ldarg.0
+        IL_0001: call instance void [System.Runtime]System.Object::.ctor()
+        IL_0006: ret
+    }
+}
diff --git a/src/tests/Interop/UnmanagedCallersOnly/UnmanagedCallersOnlyTest.cs b/src/tests/Interop/UnmanagedCallersOnly/UnmanagedCallersOnlyTest.cs
index 68d700c..0a2b530 100644
--- a/src/tests/Interop/UnmanagedCallersOnly/UnmanagedCallersOnlyTest.cs
+++ b/src/tests/Interop/UnmanagedCallersOnly/UnmanagedCallersOnlyTest.cs
@@ -3,9 +3,9 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Runtime.CompilerServices;
 using System.Reflection;
 using System.Reflection.Emit;
+using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 using System.Threading;
 using TestLibrary;
@@ -35,6 +35,20 @@ public static class UnmanagedCallersOnlyDll
         public static extern int PInvokeMarkedWithUnmanagedCallersOnly(int n);
     }
 
+    private const string InvalidCSharpAssemblyName = "InvalidCSharp";
+
+    public static Type GetCallbacksType()
+    {
+        var asm = Assembly.Load(InvalidCSharpAssemblyName);
+        return asm.GetType("InvalidCSharp.Callbacks");
+    }
+
+    public static Type GetGenericClassOfIntType()
+    {
+        var asm = Assembly.Load(InvalidCSharpAssemblyName);
+        return asm.GetType("InvalidCSharp.GenericClass`1").MakeGenericType(typeof(int));
+    }
+
     private delegate int IntNativeMethodInvoker();
     private delegate void NativeMethodInvoker();
 
@@ -338,12 +352,6 @@ void CallAsDelegate()
         }
     }
 
-    [UnmanagedCallersOnly]
-    public int CallbackNonStatic(int val)
-    {
-        Assert.Fail($"Instance functions with attribute {nameof(UnmanagedCallersOnlyAttribute)} are invalid");
-        return -1;
-    }
 
     public static void NegativeTest_NonStaticMethod()
     {
@@ -354,7 +362,7 @@ void TestUnmanagedCallersOnlyNonStatic()
            {
                 .locals init ([0] native int ptr)
                 nop
-                ldftn      int CallbackNonStatic(int)
+                ldftn      int GetCallbacksType().CallbackNonStatic(int)
                 stloc.0
 
                 ldloc.0
@@ -371,7 +379,7 @@ .locals init ([0] native int ptr)
         il.Emit(OpCodes.Nop);
 
         // Get native function pointer of the callback
-        il.Emit(OpCodes.Ldftn, typeof(Program).GetMethod(nameof(CallbackNonStatic)));
+        il.Emit(OpCodes.Ldftn, GetCallbacksType().GetMethod("CallbackNonStatic"));
         il.Emit(OpCodes.Stloc_0);
         il.Emit(OpCodes.Ldloc_0);
 
@@ -436,13 +444,6 @@ .locals init ([0] native int ptr)
         Assert.Throws<InvalidProgramException>(() => { testNativeMethod(); });
     }
 
-    [UnmanagedCallersOnly]
-    public static int CallbackMethodGeneric<T>(T arg)
-    {
-        Assert.Fail($"Functions with attribute {nameof(UnmanagedCallersOnlyAttribute)} cannot have generic arguments");
-        return -1;
-    }
-
     public static void NegativeTest_NonInstantiatedGenericArguments()
     {
         Console.WriteLine($"Running {nameof(NegativeTest_NonInstantiatedGenericArguments)}...");
@@ -452,7 +453,7 @@ void TestUnmanagedCallersOnlyNonInstGenericArguments()
            {
                 .locals init ([0] native int ptr)
                 IL_0000:  nop
-                IL_0001:  ldftn      void CallbackMethodGeneric(T)
+                IL_0001:  ldftn      void InvalidCSharp.Callbacks.CallbackMethodGeneric(T)
                 IL_0007:  stloc.0
                 IL_0008:  ret
              }
@@ -463,7 +464,7 @@ .locals init ([0] native int ptr)
         il.Emit(OpCodes.Nop);
 
         // Get native function pointer of the callback
-        il.Emit(OpCodes.Ldftn, typeof(Program).GetMethod(nameof(CallbackMethodGeneric)));
+        il.Emit(OpCodes.Ldftn, GetCallbacksType().GetMethod("CallbackMethodGeneric"));
         il.Emit(OpCodes.Stloc_0);
 
         il.Emit(OpCodes.Ret);
@@ -482,7 +483,7 @@ void TestUnmanagedCallersOnlyInstGenericArguments()
            {
                 .locals init ([0] native int ptr)
                 nop
-                ldftn      void CallbackMethodGeneric(int)
+                ldftn      void InvalidCSharp.Callbacks.CallbackMethodGeneric(int)
                 stloc.0
 
                 ldloc.0
@@ -499,7 +500,7 @@ .locals init ([0] native int ptr)
         il.Emit(OpCodes.Nop);
 
         // Get native function pointer of the instantiated generic callback
-        il.Emit(OpCodes.Ldftn, typeof(Program).GetMethod(nameof(CallbackMethodGeneric)).MakeGenericMethod(new [] { typeof(int) }));
+        il.Emit(OpCodes.Ldftn, GetCallbacksType().GetMethod("CallbackMethodGeneric").MakeGenericMethod(new [] { typeof(int) }));
         il.Emit(OpCodes.Stloc_0);
         il.Emit(OpCodes.Ldloc_0);
 
@@ -515,15 +516,6 @@ .locals init ([0] native int ptr)
         Assert.Throws<InvalidProgramException>(() => { testNativeMethod(); });
     }
 
-    public class GenericClass<T>
-    {
-        [UnmanagedCallersOnly]
-        public static void CallbackMethod(int n)
-        {
-            Assert.Fail($"Functions with attribute {nameof(UnmanagedCallersOnlyAttribute)} within a generic type are invalid");
-        }
-    }
-
     public static void NegativeTest_FromInstantiatedGenericClass()
     {
         Console.WriteLine($"Running {nameof(NegativeTest_FromInstantiatedGenericClass)}...");
@@ -533,7 +525,7 @@ void TestUnmanagedCallersOnlyInstGenericType()
            {
                 .locals init ([0] native int ptr)
                 nop
-                ldftn      int GenericClass<int>::CallbackMethod(int)
+                ldftn      int InvalidCSharp.GenericClass<int>::CallbackMethod(int)
                 stloc.0
 
                 ldloc.0
@@ -550,7 +542,7 @@ .locals init ([0] native int ptr)
         il.Emit(OpCodes.Nop);
 
         // Get native function pointer of the callback from the instantiated generic class.
-        il.Emit(OpCodes.Ldftn, typeof(GenericClass<int>).GetMethod(nameof(GenericClass<int>.CallbackMethod)));
+        il.Emit(OpCodes.Ldftn, GetGenericClassOfIntType().GetMethod("CallbackMethod"));
         il.Emit(OpCodes.Stloc_0);
         il.Emit(OpCodes.Ldloc_0);
 
diff --git a/src/tests/Interop/UnmanagedCallersOnly/UnmanagedCallersOnlyTest.csproj b/src/tests/Interop/UnmanagedCallersOnly/UnmanagedCallersOnlyTest.csproj
index a8c1862..170fac3 100644
--- a/src/tests/Interop/UnmanagedCallersOnly/UnmanagedCallersOnlyTest.csproj
+++ b/src/tests/Interop/UnmanagedCallersOnly/UnmanagedCallersOnlyTest.csproj
@@ -1,7 +1,6 @@
 <Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
     <OutputType>Exe</OutputType>
-    <CLRTestPriority>1</CLRTestPriority>
   </PropertyGroup>
   <ItemGroup>
     <Compile Include="UnmanagedCallersOnlyTest.cs" />
@@ -10,5 +9,6 @@
     <!-- This is needed to make sure native binary gets installed in the right location -->
     <ProjectReference Include="CMakeLists.txt" />
     <ProjectReference Include="$(TestSourceDir)Common/CoreCLRTestLibrary/CoreCLRTestLibrary.csproj" />
+    <ProjectReference Include="InvalidCSharp.ilproj" />
   </ItemGroup>
 </Project>
diff --git a/src/tests/JIT/Directed/tailcall/mutual_recursion.fsproj b/src/tests/JIT/Directed/tailcall/mutual_recursion.fsproj
index 0a9d97a..eb084ad 100644
--- a/src/tests/JIT/Directed/tailcall/mutual_recursion.fsproj
+++ b/src/tests/JIT/Directed/tailcall/mutual_recursion.fsproj
@@ -7,7 +7,7 @@
     <Noconfig>True</Noconfig>
     <Optimize>True</Optimize>
     <JitOptimizationSensitive>True</JitOptimizationSensitive>
-    <TargetFramework>netcoreapp3.1</TargetFramework>
+    <TargetFramework>$(NetCoreAppCurrent)</TargetFramework>
   </PropertyGroup>
   <ItemGroup>
     <Compile Include="mutual_recursion.fs" />
-- 
1.8.3.1

