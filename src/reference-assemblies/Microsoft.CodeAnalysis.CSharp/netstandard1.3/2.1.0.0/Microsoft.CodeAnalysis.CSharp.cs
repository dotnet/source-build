[assembly:System.Diagnostics.DebuggableAttribute((System.Diagnostics.DebuggableAttribute.DebuggingModes)(2))]
[assembly:System.Reflection.AssemblyCompanyAttribute("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyCopyrightAttribute("Â© Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyFileVersionAttribute("2.1.0.61520")]
[assembly:System.Reflection.AssemblyInformationalVersionAttribute("2.1.0-beta1-61520-04. Commit Hash: ba9c82a89ddd321419d1235a6ada590dcd0337de")]
[assembly:System.Reflection.AssemblyMetadataAttribute("Serviceable", "True")]
[assembly:System.Runtime.CompilerServices.CompilationRelaxationsAttribute(8)]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("csc, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("csi, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.CompilerServer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.CSharp.ExpressionEvaluator.ExpressionCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.CSharp.InteractiveEditorFeatures, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.CSharp.Scripting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.CSharp.Scripting.Desktop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.CSharp.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.Scripting.Destkop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.CommandLine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.Emit.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.EnC.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.Semantic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.Symbol.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.Syntax.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.Test.Utilities.Desktop, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.WinRT.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.ExpressionEvaluator.CSharp.ExpressionCompiler.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Services.Editor.CSharp.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Services.Editor2.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Test.Utilities.Desktop, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Test.Utilities.FX45, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("VBCSCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("VBCSCompilerPortable, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute(WrapNonExceptionThrows=true)]
[assembly:System.Runtime.Versioning.TargetFrameworkAttribute(".NETPortable,Version=v5.0", FrameworkDisplayName=".NET Portable Subset")]
namespace Microsoft.CodeAnalysis
{
    public static partial class CSharpExtensions
    {
        public static bool Any(this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool Any(this Microsoft.CodeAnalysis.SyntaxTriviaList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool Any<TNode>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static bool Any<TNode>(this Microsoft.CodeAnalysis.SyntaxList<TNode> list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static int IndexOf(this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static int IndexOf(this Microsoft.CodeAnalysis.SyntaxTriviaList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static int IndexOf<TNode>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static int IndexOf<TNode>(this Microsoft.CodeAnalysis.SyntaxList<TNode> list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static bool IsKind(this Microsoft.CodeAnalysis.SyntaxNode node, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsKind(this Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsKind(this Microsoft.CodeAnalysis.SyntaxToken token, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsKind(this Microsoft.CodeAnalysis.SyntaxTrivia trivia, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
    }
}
namespace Microsoft.CodeAnalysis.CSharp
{
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct AwaitExpressionInfo : System.IEquatable<Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo>
    {
        public Microsoft.CodeAnalysis.IMethodSymbol GetAwaiterMethod { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.IMethodSymbol GetResultMethod { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.IPropertySymbol IsCompletedProperty { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool IsDynamic { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Conversion : System.IEquatable<Microsoft.CodeAnalysis.CSharp.Conversion>
    {
        public bool Exists { get { throw null; } }
        public bool IsAnonymousFunction { get { throw null; } }
        public bool IsBoxing { get { throw null; } }
        public bool IsConstantExpression { get { throw null; } }
        public bool IsDynamic { get { throw null; } }
        public bool IsEnumeration { get { throw null; } }
        public bool IsExplicit { get { throw null; } }
        public bool IsIdentity { get { throw null; } }
        public bool IsImplicit { get { throw null; } }
        public bool IsInterpolatedString { get { throw null; } }
        public bool IsIntPtr { get { throw null; } }
        public bool IsMethodGroup { get { throw null; } }
        public bool IsNullable { get { throw null; } }
        public bool IsNullLiteral { get { throw null; } }
        public bool IsNumeric { get { throw null; } }
        public bool IsPointer { get { throw null; } }
        public bool IsReference { get { throw null; } }
        public bool IsThrow { get { throw null; } }
        public bool IsTupleConversion { get { throw null; } }
        public bool IsTupleLiteralConversion { get { throw null; } }
        public bool IsUnboxing { get { throw null; } }
        public bool IsUserDefined { get { throw null; } }
        public Microsoft.CodeAnalysis.IMethodSymbol MethodSymbol { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.CSharp.Conversion other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.CSharp.Conversion left, Microsoft.CodeAnalysis.CSharp.Conversion right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.CSharp.Conversion left, Microsoft.CodeAnalysis.CSharp.Conversion right) { throw null; }
        public override string ToString() { throw null; }
    }
    public sealed partial class CSharpCommandLineArguments : Microsoft.CodeAnalysis.CommandLineArguments
    {
        internal CSharpCommandLineArguments() { }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions CompilationOptions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        protected override Microsoft.CodeAnalysis.CompilationOptions CompilationOptionsCore { get { throw null; } }
        public new Microsoft.CodeAnalysis.CSharp.CSharpParseOptions ParseOptions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        protected override Microsoft.CodeAnalysis.ParseOptions ParseOptionsCore { get { throw null; } }
    }
    public partial class CSharpCommandLineParser : Microsoft.CodeAnalysis.CommandLineParser
    {
        internal CSharpCommandLineParser() { }
        public static Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParser Default { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        protected override string RegularFileExtension { get { throw null; } }
        protected override string ScriptFileExtension { get { throw null; } }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCommandLineArguments Parse(System.Collections.Generic.IEnumerable<string> args, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories=null) { throw null; }
        public static System.Collections.Generic.IEnumerable<string> ParseConditionalCompilationSymbols(string value, out System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> diagnostics) { diagnostics = default(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic>); throw null; }
    }
    public sealed partial class CSharpCompilation : Microsoft.CodeAnalysis.Compilation
    {
        internal CSharpCompilation() { }
        protected override Microsoft.CodeAnalysis.IAssemblySymbol CommonAssembly { get { throw null; } }
        protected override Microsoft.CodeAnalysis.ITypeSymbol CommonDynamicType { get { throw null; } }
        protected override Microsoft.CodeAnalysis.INamespaceSymbol CommonGlobalNamespace { get { throw null; } }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonObjectType { get { throw null; } }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonOptions { get { throw null; } }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonScriptClass { get { throw null; } }
        protected override Microsoft.CodeAnalysis.IModuleSymbol CommonSourceModule { get { throw null; } }
        protected override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> CommonSyntaxTrees { get { throw null; } }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.MetadataReference> DirectiveReferences { get { throw null; } }
        public override bool IsCaseSensitive { get { throw null; } }
        public override string Language { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.LanguageVersion LanguageVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions Options { get { throw null; } }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.AssemblyIdentity> ReferencedAssemblyNames { get { throw null; } }
        public new Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo ScriptCompilationInfo { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public new System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SyntaxTree> SyntaxTrees { get { throw null; } }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddReferences(params Microsoft.CodeAnalysis.MetadataReference[] references) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddReferences(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> references) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddSyntaxTrees(params Microsoft.CodeAnalysis.SyntaxTree[] trees) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddSyntaxTrees(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> trees) { throw null; }
        protected override void AppendDefaultVersionResource(System.IO.Stream resourceStream) { }
        public Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation Clone() { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonAddSyntaxTrees(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> trees) { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonClone() { throw null; }
        protected override bool CommonContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree syntaxTree) { throw null; }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateAnonymousTypeSymbol(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ITypeSymbol> memberTypes, System.Collections.Immutable.ImmutableArray<string> memberNames, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Location> memberLocations, System.Collections.Immutable.ImmutableArray<bool> memberIsReadOnly) { throw null; }
        protected override Microsoft.CodeAnalysis.IArrayTypeSymbol CommonCreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol elementType, int rank) { throw null; }
        protected override Microsoft.CodeAnalysis.INamespaceSymbol CommonCreateErrorNamespaceSymbol(Microsoft.CodeAnalysis.INamespaceSymbol container, string name) { throw null; }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateErrorTypeSymbol(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name, int arity) { throw null; }
        protected override Microsoft.CodeAnalysis.IPointerTypeSymbol CommonCreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol elementType) { throw null; }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateTupleTypeSymbol(Microsoft.CodeAnalysis.INamedTypeSymbol underlyingType, System.Collections.Immutable.ImmutableArray<string> elementNames, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Location> elementLocations) { throw null; }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateTupleTypeSymbol(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ITypeSymbol> elementTypes, System.Collections.Immutable.ImmutableArray<string> elementNames, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Location> elementLocations) { throw null; }
        protected override Microsoft.CodeAnalysis.ISymbol CommonGetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference reference) { throw null; }
        protected override Microsoft.CodeAnalysis.INamespaceSymbol CommonGetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol namespaceSymbol) { throw null; }
        protected override Microsoft.CodeAnalysis.IMethodSymbol CommonGetEntryPoint(System.Threading.CancellationToken cancellationToken) { throw null; }
        protected override Microsoft.CodeAnalysis.SemanticModel CommonGetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree syntaxTree, bool ignoreAccessibility) { throw null; }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonGetSpecialType(Microsoft.CodeAnalysis.SpecialType specialType) { throw null; }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonGetTypeByMetadataName(string metadataName) { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonRemoveAllSyntaxTrees() { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonRemoveSyntaxTrees(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> trees) { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree oldTree, Microsoft.CodeAnalysis.SyntaxTree newTree) { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonWithAssemblyName(string assemblyName) { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonWithOptions(Microsoft.CodeAnalysis.CompilationOptions options) { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonWithReferences(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> newReferences) { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonWithScriptCompilationInfo(Microsoft.CodeAnalysis.ScriptCompilationInfo info) { throw null; }
        public override bool ContainsSymbolsWithName(System.Func<string, bool> predicate, Microsoft.CodeAnalysis.SymbolFilter filter=(Microsoft.CodeAnalysis.SymbolFilter)(6), System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public new bool ContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree syntaxTree) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.CSharpCompilation Create(string assemblyName, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> syntaxTrees=null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> references=null, Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions options=null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.CSharpCompilation CreateScriptCompilation(string assemblyName, Microsoft.CodeAnalysis.SyntaxTree syntaxTree=null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> references=null, Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions options=null, Microsoft.CodeAnalysis.CSharp.CSharpCompilation previousScriptCompilation=null, System.Type returnType=null, System.Type globalsType=null) { throw null; }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetDeclarationDiagnostics(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public Microsoft.CodeAnalysis.MetadataReference GetDirectiveReference(Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax directive) { throw null; }
        public new Microsoft.CodeAnalysis.MetadataReference GetMetadataReference(Microsoft.CodeAnalysis.IAssemblySymbol assemblySymbol) { throw null; }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetMethodBodyDiagnostics(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetParseDiagnostics(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public new Microsoft.CodeAnalysis.SemanticModel GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree syntaxTree, bool ignoreAccessibility) { throw null; }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ISymbol> GetSymbolsWithName(System.Func<string, bool> predicate, Microsoft.CodeAnalysis.SymbolFilter filter=(Microsoft.CodeAnalysis.SymbolFilter)(6), System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveAllReferences() { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveAllSyntaxTrees() { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveReferences(params Microsoft.CodeAnalysis.MetadataReference[] references) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveReferences(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> references) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveSyntaxTrees(params Microsoft.CodeAnalysis.SyntaxTree[] trees) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveSyntaxTrees(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> trees) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation ReplaceReference(Microsoft.CodeAnalysis.MetadataReference oldReference, Microsoft.CodeAnalysis.MetadataReference newReference) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation ReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree oldTree, Microsoft.CodeAnalysis.SyntaxTree newTree) { throw null; }
        public override Microsoft.CodeAnalysis.CompilationReference ToMetadataReference(System.Collections.Immutable.ImmutableArray<string> aliases=default(System.Collections.Immutable.ImmutableArray<string>), bool embedInteropTypes=false) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithAssemblyName(string assemblyName) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithOptions(Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions options) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithReferences(params Microsoft.CodeAnalysis.MetadataReference[] references) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithReferences(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> references) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithScriptCompilationInfo(Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo info) { throw null; }
    }
    public sealed partial class CSharpCompilationOptions : Microsoft.CodeAnalysis.CompilationOptions, System.IEquatable<Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions>
    {
        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
        public CSharpCompilationOptions(Microsoft.CodeAnalysis.OutputKind outputKind, bool reportSuppressedDiagnostics, string moduleName, string mainTypeName, string scriptClassName, System.Collections.Generic.IEnumerable<string> usings, Microsoft.CodeAnalysis.OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey, System.Nullable<bool> delaySign, Microsoft.CodeAnalysis.Platform platform, Microsoft.CodeAnalysis.ReportDiagnostic generalDiagnosticOption, int warningLevel, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, Microsoft.CodeAnalysis.XmlReferenceResolver xmlReferenceResolver, Microsoft.CodeAnalysis.SourceReferenceResolver sourceReferenceResolver, Microsoft.CodeAnalysis.MetadataReferenceResolver metadataReferenceResolver, Microsoft.CodeAnalysis.AssemblyIdentityComparer assemblyIdentityComparer, Microsoft.CodeAnalysis.StrongNameProvider strongNameProvider) { }
        public CSharpCompilationOptions(Microsoft.CodeAnalysis.OutputKind outputKind, bool reportSuppressedDiagnostics=false, string moduleName=null, string mainTypeName=null, string scriptClassName=null, System.Collections.Generic.IEnumerable<string> usings=null, Microsoft.CodeAnalysis.OptimizationLevel optimizationLevel=(Microsoft.CodeAnalysis.OptimizationLevel)(0), bool checkOverflow=false, bool allowUnsafe=false, string cryptoKeyContainer=null, string cryptoKeyFile=null, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey=default(System.Collections.Immutable.ImmutableArray<byte>), System.Nullable<bool> delaySign=default(System.Nullable<bool>), Microsoft.CodeAnalysis.Platform platform=(Microsoft.CodeAnalysis.Platform)(0), Microsoft.CodeAnalysis.ReportDiagnostic generalDiagnosticOption=(Microsoft.CodeAnalysis.ReportDiagnostic)(0), int warningLevel=4, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>> specificDiagnosticOptions=null, bool concurrentBuild=true, bool deterministic=false, Microsoft.CodeAnalysis.XmlReferenceResolver xmlReferenceResolver=null, Microsoft.CodeAnalysis.SourceReferenceResolver sourceReferenceResolver=null, Microsoft.CodeAnalysis.MetadataReferenceResolver metadataReferenceResolver=null, Microsoft.CodeAnalysis.AssemblyIdentityComparer assemblyIdentityComparer=null, Microsoft.CodeAnalysis.StrongNameProvider strongNameProvider=null, bool publicSign=false) { }
        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
        public CSharpCompilationOptions(Microsoft.CodeAnalysis.OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, System.Collections.Generic.IEnumerable<string> usings, Microsoft.CodeAnalysis.OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey, System.Nullable<bool> delaySign, Microsoft.CodeAnalysis.Platform platform, Microsoft.CodeAnalysis.ReportDiagnostic generalDiagnosticOption, int warningLevel, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, Microsoft.CodeAnalysis.XmlReferenceResolver xmlReferenceResolver, Microsoft.CodeAnalysis.SourceReferenceResolver sourceReferenceResolver, Microsoft.CodeAnalysis.MetadataReferenceResolver metadataReferenceResolver, Microsoft.CodeAnalysis.AssemblyIdentityComparer assemblyIdentityComparer, Microsoft.CodeAnalysis.StrongNameProvider strongNameProvider) { }
        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
        public CSharpCompilationOptions(Microsoft.CodeAnalysis.OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, System.Collections.Generic.IEnumerable<string> usings, Microsoft.CodeAnalysis.OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey, System.Nullable<bool> delaySign, Microsoft.CodeAnalysis.Platform platform, Microsoft.CodeAnalysis.ReportDiagnostic generalDiagnosticOption, int warningLevel, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, Microsoft.CodeAnalysis.XmlReferenceResolver xmlReferenceResolver, Microsoft.CodeAnalysis.SourceReferenceResolver sourceReferenceResolver, Microsoft.CodeAnalysis.MetadataReferenceResolver metadataReferenceResolver, Microsoft.CodeAnalysis.AssemblyIdentityComparer assemblyIdentityComparer, Microsoft.CodeAnalysis.StrongNameProvider strongNameProvider) { }
        public bool AllowUnsafe { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public override string Language { get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<string> Usings { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithAssemblyIdentityComparer(Microsoft.CodeAnalysis.AssemblyIdentityComparer comparer) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithCheckOverflow(bool checkOverflow) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithConcurrentBuild(bool concurrent) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithCryptoKeyContainer(string cryptoKeyContainer) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithCryptoKeyFile(string cryptoKeyFile) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithCryptoPublicKey(System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithDelaySign(System.Nullable<bool> delaySign) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithDeterministic(bool deterministic) { throw null; }
        [System.ObsoleteAttribute]
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithFeatures(System.Collections.Immutable.ImmutableArray<string> features) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithGeneralDiagnosticOption(Microsoft.CodeAnalysis.ReportDiagnostic value) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithMainTypeName(string mainTypeName) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithMetadataReferenceResolver(Microsoft.CodeAnalysis.MetadataReferenceResolver resolver) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithModuleName(string moduleName) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithOptimizationLevel(Microsoft.CodeAnalysis.OptimizationLevel value) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithOutputKind(Microsoft.CodeAnalysis.OutputKind kind) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithPlatform(Microsoft.CodeAnalysis.Platform platform) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithPublicSign(bool publicSign) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithScriptClassName(string scriptClassName) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithSourceReferenceResolver(Microsoft.CodeAnalysis.SourceReferenceResolver resolver) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithSpecificDiagnosticOptions(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>> specificDiagnosticOptions) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithSpecificDiagnosticOptions(System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic> specificDiagnosticOptions) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithStrongNameProvider(Microsoft.CodeAnalysis.StrongNameProvider provider) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithXmlReferenceResolver(Microsoft.CodeAnalysis.XmlReferenceResolver resolver) { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithAllowUnsafe(bool enabled) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithAssemblyIdentityComparer(Microsoft.CodeAnalysis.AssemblyIdentityComparer comparer) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithConcurrentBuild(bool concurrentBuild) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithCryptoKeyContainer(string name) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithCryptoKeyFile(string path) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithCryptoPublicKey(System.Collections.Immutable.ImmutableArray<byte> value) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithDelaySign(System.Nullable<bool> value) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithDeterministic(bool deterministic) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithGeneralDiagnosticOption(Microsoft.CodeAnalysis.ReportDiagnostic value) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithMainTypeName(string name) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithMetadataReferenceResolver(Microsoft.CodeAnalysis.MetadataReferenceResolver resolver) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithModuleName(string moduleName) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithOptimizationLevel(Microsoft.CodeAnalysis.OptimizationLevel value) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithOutputKind(Microsoft.CodeAnalysis.OutputKind kind) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithOverflowChecks(bool enabled) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithPlatform(Microsoft.CodeAnalysis.Platform platform) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithPublicSign(bool publicSign) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithScriptClassName(string name) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithSourceReferenceResolver(Microsoft.CodeAnalysis.SourceReferenceResolver resolver) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithSpecificDiagnosticOptions(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>> values) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithSpecificDiagnosticOptions(System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic> values) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithStrongNameProvider(Microsoft.CodeAnalysis.StrongNameProvider provider) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithUsings(System.Collections.Generic.IEnumerable<string> usings) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithUsings(System.Collections.Immutable.ImmutableArray<string> usings) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithUsings(params string[] usings) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithWarningLevel(int warningLevel) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithXmlReferenceResolver(Microsoft.CodeAnalysis.XmlReferenceResolver resolver) { throw null; }
    }
    public partial class CSharpDiagnosticFormatter : Microsoft.CodeAnalysis.DiagnosticFormatter
    {
        internal CSharpDiagnosticFormatter() { }
        public static Microsoft.CodeAnalysis.CSharp.CSharpDiagnosticFormatter Instance { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
    }
    public static partial class CSharpExtensions
    {
        public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement) { throw null; }
        public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(this Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource=false) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource=false) { throw null; }
        public static Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo GetAwaitExpressionInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax awaitExpression) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetCollectionInitializerSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax GetCompilationUnitRoot(this Microsoft.CodeAnalysis.SyntaxTree tree, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.Optional<object> GetConstantValue(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Conversion GetConversion(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode expression, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IMethodSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax catchDeclaration, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IFieldSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IEventSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ILocalSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.INamespaceSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IParameterSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IPropertySymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax queryClause, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IRangeVariableSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax designationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ILabelSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.INamedTypeSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ITypeParameterSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax typeParameter, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IAliasSymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetFirstDirective(this Microsoft.CodeAnalysis.SyntaxNode node, System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool> predicate=null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEachStatement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IPropertySymbol> GetIndexerGroup(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetLastDirective(this Microsoft.CodeAnalysis.SyntaxNode node, System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool> predicate=null) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> GetMemberGroup(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> GetMemberGroup(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> GetMemberGroup(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.QueryClauseInfo GetQueryClauseInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax node, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Conversion GetSpeculativeConversion(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) { throw null; }
        public static Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTokenList Insert(this Microsoft.CodeAnalysis.SyntaxTokenList list, int index, params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public static bool IsContextualKeyword(this Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static bool IsKeyword(this Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static bool IsReservedKeyword(this Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static bool IsVerbatimIdentifier(this Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static bool IsVerbatimStringLiteral(this Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(this Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(this Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(this Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(this Microsoft.CodeAnalysis.SyntaxTrivia trivia) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(this Microsoft.CodeAnalysis.SyntaxToken token, Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, Microsoft.CodeAnalysis.SyntaxTrivia newTrivia) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(this Microsoft.CodeAnalysis.SyntaxToken token, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivia, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia> computeReplacementTrivia) { throw null; }
        public static bool TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, out Microsoft.CodeAnalysis.SemanticModel speculativeModel) { speculativeModel = default(Microsoft.CodeAnalysis.SemanticModel); throw null; }
        public static bool TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, out Microsoft.CodeAnalysis.SemanticModel speculativeModel) { speculativeModel = default(Microsoft.CodeAnalysis.SemanticModel); throw null; }
        public static bool TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, out Microsoft.CodeAnalysis.SemanticModel speculativeModel) { speculativeModel = default(Microsoft.CodeAnalysis.SemanticModel); throw null; }
        public static bool TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, out Microsoft.CodeAnalysis.SemanticModel speculativeModel) { speculativeModel = default(Microsoft.CodeAnalysis.SemanticModel); throw null; }
        public static bool TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer, out Microsoft.CodeAnalysis.SemanticModel speculativeModel) { speculativeModel = default(Microsoft.CodeAnalysis.SemanticModel); throw null; }
        public static bool TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, out Microsoft.CodeAnalysis.SemanticModel speculativeModel) { speculativeModel = default(Microsoft.CodeAnalysis.SemanticModel); throw null; }
        public static bool TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, out Microsoft.CodeAnalysis.SemanticModel speculativeModel, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption=(Microsoft.CodeAnalysis.SpeculativeBindingOption)(0)) { speculativeModel = default(Microsoft.CodeAnalysis.SemanticModel); throw null; }
        public static bool TryGetSpeculativeSemanticModelForMethodBody(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax accessor, out Microsoft.CodeAnalysis.SemanticModel speculativeModel) { speculativeModel = default(Microsoft.CodeAnalysis.SemanticModel); throw null; }
        public static bool TryGetSpeculativeSemanticModelForMethodBody(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax method, out Microsoft.CodeAnalysis.SemanticModel speculativeModel) { speculativeModel = default(Microsoft.CodeAnalysis.SemanticModel); throw null; }
        public static Microsoft.CodeAnalysis.VarianceKind VarianceKindFromToken(this Microsoft.CodeAnalysis.SyntaxToken node) { throw null; }
    }
    public static partial class CSharpFileSystemExtensions
    {
        public static Microsoft.CodeAnalysis.Emit.EmitResult Emit(this Microsoft.CodeAnalysis.CSharp.CSharpCompilation compilation, string outputPath, string pdbPath=null, string xmlDocumentationPath=null, string win32ResourcesPath=null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ResourceDescription> manifestResources=null, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
    }
    public sealed partial class CSharpParseOptions : Microsoft.CodeAnalysis.ParseOptions, System.IEquatable<Microsoft.CodeAnalysis.CSharp.CSharpParseOptions>
    {
        public CSharpParseOptions(Microsoft.CodeAnalysis.CSharp.LanguageVersion languageVersion=(Microsoft.CodeAnalysis.CSharp.LanguageVersion)(0), Microsoft.CodeAnalysis.DocumentationMode documentationMode=(Microsoft.CodeAnalysis.DocumentationMode)(1), Microsoft.CodeAnalysis.SourceCodeKind kind=(Microsoft.CodeAnalysis.SourceCodeKind)(0), System.Collections.Generic.IEnumerable<string> preprocessorSymbols=null) { }
        public static Microsoft.CodeAnalysis.CSharp.CSharpParseOptions Default { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public override System.Collections.Generic.IReadOnlyDictionary<string, string> Features { get { throw null; } }
        public override string Language { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.LanguageVersion LanguageVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public override System.Collections.Generic.IEnumerable<string> PreprocessorSymbolNames { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.LanguageVersion SpecifiedLanguageVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        protected override Microsoft.CodeAnalysis.ParseOptions CommonWithDocumentationMode(Microsoft.CodeAnalysis.DocumentationMode documentationMode) { throw null; }
        protected override Microsoft.CodeAnalysis.ParseOptions CommonWithFeatures(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> features) { throw null; }
        public override Microsoft.CodeAnalysis.ParseOptions CommonWithKind(Microsoft.CodeAnalysis.SourceCodeKind kind) { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.CSharp.CSharpParseOptions other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpParseOptions WithDocumentationMode(Microsoft.CodeAnalysis.DocumentationMode documentationMode) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpParseOptions WithFeatures(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> features) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpParseOptions WithKind(Microsoft.CodeAnalysis.SourceCodeKind kind) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpParseOptions WithLanguageVersion(Microsoft.CodeAnalysis.CSharp.LanguageVersion version) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpParseOptions WithPreprocessorSymbols(System.Collections.Generic.IEnumerable<string> preprocessorSymbols) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpParseOptions WithPreprocessorSymbols(System.Collections.Immutable.ImmutableArray<string> symbols) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpParseOptions WithPreprocessorSymbols(params string[] preprocessorSymbols) { throw null; }
    }
    public sealed partial class CSharpScriptCompilationInfo : Microsoft.CodeAnalysis.ScriptCompilationInfo
    {
        internal CSharpScriptCompilationInfo() { }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation PreviousScriptCompilation { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo WithPreviousScriptCompilation(Microsoft.CodeAnalysis.CSharp.CSharpCompilation compilation) { throw null; }
    }
    public abstract partial class CSharpSyntaxNode : Microsoft.CodeAnalysis.SyntaxNode
    {
        internal CSharpSyntaxNode() { }
        public override string Language { get { throw null; } }
        protected override Microsoft.CodeAnalysis.SyntaxTree SyntaxTreeCore { get { throw null; } }
        public abstract void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor);
        public abstract TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor);
        public static Microsoft.CodeAnalysis.SyntaxNode DeserializeFrom(System.IO.Stream stream, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        protected override bool EquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode other) { throw null; }
        public new Microsoft.CodeAnalysis.SyntaxToken FindToken(int position, bool findInsideTrivia=false) { throw null; }
        public new Microsoft.CodeAnalysis.SyntaxTrivia FindTrivia(int position, bool findInsideTrivia=false) { throw null; }
        public new Microsoft.CodeAnalysis.SyntaxTrivia FindTrivia(int position, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, bool> stepInto) { throw null; }
        public new System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics() { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetFirstDirective(System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool> predicate=null) { throw null; }
        public new Microsoft.CodeAnalysis.SyntaxToken GetFirstToken(bool includeZeroWidth=false, bool includeSkipped=false, bool includeDirectives=false, bool includeDocumentationComments=false) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetLastDirective(System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool> predicate=null) { throw null; }
        public new Microsoft.CodeAnalysis.SyntaxToken GetLastToken(bool includeZeroWidth=false, bool includeSkipped=false, bool includeDirectives=false, bool includeDocumentationComments=false) { throw null; }
        public new Microsoft.CodeAnalysis.SyntaxTriviaList GetLeadingTrivia() { throw null; }
        public new Microsoft.CodeAnalysis.Location GetLocation() { throw null; }
        public new Microsoft.CodeAnalysis.SyntaxTriviaList GetTrailingTrivia() { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode InsertNodesInListCore(Microsoft.CodeAnalysis.SyntaxNode nodeInList, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> nodesToInsert, bool insertBefore) { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode InsertTokensInListCore(Microsoft.CodeAnalysis.SyntaxToken originalToken, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> newTokens, bool insertBefore) { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode InsertTriviaInListCore(Microsoft.CodeAnalysis.SyntaxTrivia originalTrivia, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> newTrivia, bool insertBefore) { throw null; }
        protected override bool IsEquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode node, bool topLevel=false) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind() { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode NormalizeWhitespaceCore(string indentation, string eol, bool elasticTrivia) { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode RemoveNodesCore(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> nodes, Microsoft.CodeAnalysis.SyntaxRemoveOptions options) { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode ReplaceCore<TNode>(System.Collections.Generic.IEnumerable<TNode> nodes=null, System.Func<TNode, TNode, Microsoft.CodeAnalysis.SyntaxNode> computeReplacementNode=null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> tokens=null, System.Func<Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken> computeReplacementToken=null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivia=null, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia> computeReplacementTrivia=null) { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode ReplaceNodeInListCore(Microsoft.CodeAnalysis.SyntaxNode originalNode, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> replacementNodes) { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode ReplaceTokenInListCore(Microsoft.CodeAnalysis.SyntaxToken originalToken, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> newTokens) { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode ReplaceTriviaInListCore(Microsoft.CodeAnalysis.SyntaxTrivia originalTrivia, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> newTrivia) { throw null; }
    }
    public abstract partial class CSharpSyntaxRewriter : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<Microsoft.CodeAnalysis.SyntaxNode>
    {
        public CSharpSyntaxRewriter(bool visitIntoStructuredTrivia=false) { }
        public virtual bool VisitIntoStructuredTrivia { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxNode Visit(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitAccessorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitAliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitAnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitAnonymousObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitAnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitArrayRankSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitArrowExpressionClause(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitAssignmentExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitAttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitAttributeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitAttributeList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitAttributeTargetSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitAwaitExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitBadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitBaseExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitBinaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitBracketedArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitBreakStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitCasePatternSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitCaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitCastExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitCatchClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitCatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitCatchFilterClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitCheckedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitCheckedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitClassDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitCompilationUnit(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitConstantPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitConstructorConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitConstructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitContinueStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitConversionOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitConversionOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitCrefBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitCrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitCrefParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitDeclarationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitDeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitDefaultExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitDefaultSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitDefineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitDelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitDestructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitDiscardDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitDocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitDoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitElementBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitElifDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitElseClause(Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitElseDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitEmptyStatement(Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitEndIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitEndRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitEnumDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitEnumMemberDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitEqualsValueClause(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitErrorDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitEventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitEventFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitExternAliasDirective(Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitFinallyClause(Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitFixedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitForEachVariableStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitFromClause(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitGenericName(Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitGlobalStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitGotoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitGroupClause(Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitIdentifierName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitIfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitImplicitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitImplicitElementAccess(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitIncompleteMember(Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitIndexerDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitIndexerMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitInitializerExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitInterfaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitInterpolatedStringExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitInterpolatedStringText(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitInterpolation(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitInterpolationAlignmentClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitInterpolationFormatClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitIsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitJoinClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitJoinIntoClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitLabeledStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitLetClause(Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitLineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax node) { throw null; }
        public virtual Microsoft.CodeAnalysis.SyntaxTokenList VisitList(Microsoft.CodeAnalysis.SyntaxTokenList list) { throw null; }
        public virtual Microsoft.CodeAnalysis.SyntaxTriviaList VisitList(Microsoft.CodeAnalysis.SyntaxTriviaList list) { throw null; }
        public virtual Microsoft.CodeAnalysis.SyntaxTrivia VisitListElement(Microsoft.CodeAnalysis.SyntaxTrivia element) { throw null; }
        public virtual TNode VisitListElement<TNode>(TNode node) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public virtual Microsoft.CodeAnalysis.SyntaxToken VisitListSeparator(Microsoft.CodeAnalysis.SyntaxToken separator) { throw null; }
        public virtual Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> VisitList<TNode>(Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> list) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public virtual Microsoft.CodeAnalysis.SyntaxList<TNode> VisitList<TNode>(Microsoft.CodeAnalysis.SyntaxList<TNode> list) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitLiteralExpression(Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitLoadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitLocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitLockStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitMakeRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitMemberAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitMemberBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitMethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitNameColon(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitNameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitNameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitNullableType(Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitOmittedArraySizeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitOmittedTypeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitOrderByClause(Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitOrdering(Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitParameter(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitParenthesizedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitParenthesizedVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitPostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitPragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitPragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitPredefinedType(Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitPrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitQualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitQueryBody(Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitQueryContinuation(Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitQueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitReferenceDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitRefType(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitRefTypeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitRefValueExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitReturnStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitSelectClause(Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitShebangDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitSimpleBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitSimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitSingleVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitSizeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitSkippedTokensTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitStructDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitSwitchSection(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitSwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitThisExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitThrowExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitThrowStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax node) { throw null; }
        public virtual Microsoft.CodeAnalysis.SyntaxToken VisitToken(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public virtual Microsoft.CodeAnalysis.SyntaxTrivia VisitTrivia(Microsoft.CodeAnalysis.SyntaxTrivia trivia) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitTryStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitTupleElement(Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitTupleExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitTupleType(Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitTypeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitTypeConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitTypeCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitTypeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitTypeParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitTypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitUndefDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitUnsafeStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitUsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitVariableDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitWhenClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitWhereClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitWhileStatement(Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitXmlCDataSection(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitXmlComment(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitXmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitXmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitXmlElementEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitXmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitXmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitXmlName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitXmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitXmlPrefix(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitXmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitXmlText(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitXmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode VisitYieldStatement(Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax node) { throw null; }
    }
    public abstract partial class CSharpSyntaxTree : Microsoft.CodeAnalysis.SyntaxTree
    {
        protected CSharpSyntaxTree() { }
        public abstract new Microsoft.CodeAnalysis.CSharp.CSharpParseOptions Options { get; }
        protected override Microsoft.CodeAnalysis.ParseOptions OptionsCore { get { throw null; } }
        protected T CloneNodeAsRoot<T>(T node) where T : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTree Create(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode root, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions options=null, string path="", System.Text.Encoding encoding=null) { throw null; }
        public override System.Collections.Generic.IList<Microsoft.CodeAnalysis.Text.TextSpan> GetChangedSpans(Microsoft.CodeAnalysis.SyntaxTree oldTree) { throw null; }
        public override System.Collections.Generic.IList<Microsoft.CodeAnalysis.Text.TextChange> GetChanges(Microsoft.CodeAnalysis.SyntaxTree oldTree) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax GetCompilationUnitRoot(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) { throw null; }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(Microsoft.CodeAnalysis.SyntaxTrivia trivia) { throw null; }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public override Microsoft.CodeAnalysis.FileLinePositionSpan GetLineSpan(Microsoft.CodeAnalysis.Text.TextSpan span, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public override Microsoft.CodeAnalysis.LineVisibility GetLineVisibility(int position, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public override Microsoft.CodeAnalysis.Location GetLocation(Microsoft.CodeAnalysis.Text.TextSpan span) { throw null; }
        public override Microsoft.CodeAnalysis.FileLinePositionSpan GetMappedLineSpan(Microsoft.CodeAnalysis.Text.TextSpan span, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public abstract new Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode GetRoot(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public virtual new System.Threading.Tasks.Task<Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode> GetRootAsync(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        protected override System.Threading.Tasks.Task<Microsoft.CodeAnalysis.SyntaxNode> GetRootAsyncCore(System.Threading.CancellationToken cancellationToken) { throw null; }
        protected override Microsoft.CodeAnalysis.SyntaxNode GetRootCore(System.Threading.CancellationToken cancellationToken) { throw null; }
        public override bool HasHiddenRegions() { throw null; }
        public override bool IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTree tree, bool topLevel=false) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTree ParseText(Microsoft.CodeAnalysis.Text.SourceText text, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions options=null, string path="", System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTree ParseText(string text, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions options=null, string path="", System.Text.Encoding encoding=null, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public abstract bool TryGetRoot(out Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode root);
        protected override bool TryGetRootCore(out Microsoft.CodeAnalysis.SyntaxNode root) { root = default(Microsoft.CodeAnalysis.SyntaxNode); throw null; }
        public override Microsoft.CodeAnalysis.SyntaxTree WithChangedText(Microsoft.CodeAnalysis.Text.SourceText newText) { throw null; }
    }
    public abstract partial class CSharpSyntaxVisitor
    {
        protected CSharpSyntaxVisitor() { }
        public virtual void DefaultVisit(Microsoft.CodeAnalysis.SyntaxNode node) { }
        public virtual void Visit(Microsoft.CodeAnalysis.SyntaxNode node) { }
        public virtual void VisitAccessorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax node) { }
        public virtual void VisitAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax node) { }
        public virtual void VisitAliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax node) { }
        public virtual void VisitAnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax node) { }
        public virtual void VisitAnonymousObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax node) { }
        public virtual void VisitAnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax node) { }
        public virtual void VisitArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax node) { }
        public virtual void VisitArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax node) { }
        public virtual void VisitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax node) { }
        public virtual void VisitArrayRankSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax node) { }
        public virtual void VisitArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax node) { }
        public virtual void VisitArrowExpressionClause(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax node) { }
        public virtual void VisitAssignmentExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax node) { }
        public virtual void VisitAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax node) { }
        public virtual void VisitAttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax node) { }
        public virtual void VisitAttributeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax node) { }
        public virtual void VisitAttributeList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax node) { }
        public virtual void VisitAttributeTargetSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax node) { }
        public virtual void VisitAwaitExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax node) { }
        public virtual void VisitBadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax node) { }
        public virtual void VisitBaseExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax node) { }
        public virtual void VisitBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax node) { }
        public virtual void VisitBinaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax node) { }
        public virtual void VisitBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax node) { }
        public virtual void VisitBracketedArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax node) { }
        public virtual void VisitBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax node) { }
        public virtual void VisitBreakStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax node) { }
        public virtual void VisitCasePatternSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax node) { }
        public virtual void VisitCaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax node) { }
        public virtual void VisitCastExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax node) { }
        public virtual void VisitCatchClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax node) { }
        public virtual void VisitCatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax node) { }
        public virtual void VisitCatchFilterClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax node) { }
        public virtual void VisitCheckedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax node) { }
        public virtual void VisitCheckedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax node) { }
        public virtual void VisitClassDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax node) { }
        public virtual void VisitClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax node) { }
        public virtual void VisitCompilationUnit(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax node) { }
        public virtual void VisitConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax node) { }
        public virtual void VisitConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax node) { }
        public virtual void VisitConstantPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax node) { }
        public virtual void VisitConstructorConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax node) { }
        public virtual void VisitConstructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax node) { }
        public virtual void VisitConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax node) { }
        public virtual void VisitContinueStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax node) { }
        public virtual void VisitConversionOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax node) { }
        public virtual void VisitConversionOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax node) { }
        public virtual void VisitCrefBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax node) { }
        public virtual void VisitCrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax node) { }
        public virtual void VisitCrefParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax node) { }
        public virtual void VisitDeclarationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax node) { }
        public virtual void VisitDeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax node) { }
        public virtual void VisitDefaultExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax node) { }
        public virtual void VisitDefaultSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax node) { }
        public virtual void VisitDefineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax node) { }
        public virtual void VisitDelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax node) { }
        public virtual void VisitDestructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax node) { }
        public virtual void VisitDiscardDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax node) { }
        public virtual void VisitDocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax node) { }
        public virtual void VisitDoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax node) { }
        public virtual void VisitElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax node) { }
        public virtual void VisitElementBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax node) { }
        public virtual void VisitElifDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax node) { }
        public virtual void VisitElseClause(Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax node) { }
        public virtual void VisitElseDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax node) { }
        public virtual void VisitEmptyStatement(Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax node) { }
        public virtual void VisitEndIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax node) { }
        public virtual void VisitEndRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax node) { }
        public virtual void VisitEnumDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax node) { }
        public virtual void VisitEnumMemberDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax node) { }
        public virtual void VisitEqualsValueClause(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax node) { }
        public virtual void VisitErrorDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax node) { }
        public virtual void VisitEventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax node) { }
        public virtual void VisitEventFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax node) { }
        public virtual void VisitExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax node) { }
        public virtual void VisitExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax node) { }
        public virtual void VisitExternAliasDirective(Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax node) { }
        public virtual void VisitFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax node) { }
        public virtual void VisitFinallyClause(Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax node) { }
        public virtual void VisitFixedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax node) { }
        public virtual void VisitForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax node) { }
        public virtual void VisitForEachVariableStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax node) { }
        public virtual void VisitForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax node) { }
        public virtual void VisitFromClause(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax node) { }
        public virtual void VisitGenericName(Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax node) { }
        public virtual void VisitGlobalStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax node) { }
        public virtual void VisitGotoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax node) { }
        public virtual void VisitGroupClause(Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax node) { }
        public virtual void VisitIdentifierName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax node) { }
        public virtual void VisitIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax node) { }
        public virtual void VisitIfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax node) { }
        public virtual void VisitImplicitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax node) { }
        public virtual void VisitImplicitElementAccess(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax node) { }
        public virtual void VisitIncompleteMember(Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax node) { }
        public virtual void VisitIndexerDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax node) { }
        public virtual void VisitIndexerMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax node) { }
        public virtual void VisitInitializerExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax node) { }
        public virtual void VisitInterfaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax node) { }
        public virtual void VisitInterpolatedStringExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax node) { }
        public virtual void VisitInterpolatedStringText(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax node) { }
        public virtual void VisitInterpolation(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax node) { }
        public virtual void VisitInterpolationAlignmentClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax node) { }
        public virtual void VisitInterpolationFormatClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax node) { }
        public virtual void VisitInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax node) { }
        public virtual void VisitIsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax node) { }
        public virtual void VisitJoinClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax node) { }
        public virtual void VisitJoinIntoClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node) { }
        public virtual void VisitLabeledStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax node) { }
        public virtual void VisitLetClause(Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax node) { }
        public virtual void VisitLineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax node) { }
        public virtual void VisitLiteralExpression(Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax node) { }
        public virtual void VisitLoadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax node) { }
        public virtual void VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax node) { }
        public virtual void VisitLocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax node) { }
        public virtual void VisitLockStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax node) { }
        public virtual void VisitMakeRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax node) { }
        public virtual void VisitMemberAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax node) { }
        public virtual void VisitMemberBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax node) { }
        public virtual void VisitMethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax node) { }
        public virtual void VisitNameColon(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax node) { }
        public virtual void VisitNameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax node) { }
        public virtual void VisitNameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax node) { }
        public virtual void VisitNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax node) { }
        public virtual void VisitNullableType(Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax node) { }
        public virtual void VisitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax node) { }
        public virtual void VisitOmittedArraySizeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax node) { }
        public virtual void VisitOmittedTypeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax node) { }
        public virtual void VisitOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax node) { }
        public virtual void VisitOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax node) { }
        public virtual void VisitOrderByClause(Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax node) { }
        public virtual void VisitOrdering(Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node) { }
        public virtual void VisitParameter(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax node) { }
        public virtual void VisitParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax node) { }
        public virtual void VisitParenthesizedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax node) { }
        public virtual void VisitParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax node) { }
        public virtual void VisitParenthesizedVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax node) { }
        public virtual void VisitPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax node) { }
        public virtual void VisitPostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax node) { }
        public virtual void VisitPragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax node) { }
        public virtual void VisitPragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax node) { }
        public virtual void VisitPredefinedType(Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax node) { }
        public virtual void VisitPrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax node) { }
        public virtual void VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax node) { }
        public virtual void VisitQualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax node) { }
        public virtual void VisitQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax node) { }
        public virtual void VisitQueryBody(Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax node) { }
        public virtual void VisitQueryContinuation(Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node) { }
        public virtual void VisitQueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax node) { }
        public virtual void VisitReferenceDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax node) { }
        public virtual void VisitRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax node) { }
        public virtual void VisitRefType(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax node) { }
        public virtual void VisitRefTypeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax node) { }
        public virtual void VisitRefValueExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax node) { }
        public virtual void VisitRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax node) { }
        public virtual void VisitReturnStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax node) { }
        public virtual void VisitSelectClause(Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax node) { }
        public virtual void VisitShebangDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax node) { }
        public virtual void VisitSimpleBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax node) { }
        public virtual void VisitSimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax node) { }
        public virtual void VisitSingleVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax node) { }
        public virtual void VisitSizeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax node) { }
        public virtual void VisitSkippedTokensTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax node) { }
        public virtual void VisitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax node) { }
        public virtual void VisitStructDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax node) { }
        public virtual void VisitSwitchSection(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax node) { }
        public virtual void VisitSwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax node) { }
        public virtual void VisitThisExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax node) { }
        public virtual void VisitThrowExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax node) { }
        public virtual void VisitThrowStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax node) { }
        public virtual void VisitTryStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax node) { }
        public virtual void VisitTupleElement(Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax node) { }
        public virtual void VisitTupleExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax node) { }
        public virtual void VisitTupleType(Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax node) { }
        public virtual void VisitTypeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax node) { }
        public virtual void VisitTypeConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax node) { }
        public virtual void VisitTypeCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax node) { }
        public virtual void VisitTypeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax node) { }
        public virtual void VisitTypeParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax node) { }
        public virtual void VisitTypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax node) { }
        public virtual void VisitTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax node) { }
        public virtual void VisitUndefDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax node) { }
        public virtual void VisitUnsafeStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax node) { }
        public virtual void VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax node) { }
        public virtual void VisitUsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax node) { }
        public virtual void VisitVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax node) { }
        public virtual void VisitVariableDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax node) { }
        public virtual void VisitWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax node) { }
        public virtual void VisitWhenClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax node) { }
        public virtual void VisitWhereClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax node) { }
        public virtual void VisitWhileStatement(Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax node) { }
        public virtual void VisitXmlCDataSection(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax node) { }
        public virtual void VisitXmlComment(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax node) { }
        public virtual void VisitXmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax node) { }
        public virtual void VisitXmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax node) { }
        public virtual void VisitXmlElementEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax node) { }
        public virtual void VisitXmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax node) { }
        public virtual void VisitXmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax node) { }
        public virtual void VisitXmlName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax node) { }
        public virtual void VisitXmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax node) { }
        public virtual void VisitXmlPrefix(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax node) { }
        public virtual void VisitXmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax node) { }
        public virtual void VisitXmlText(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax node) { }
        public virtual void VisitXmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax node) { }
        public virtual void VisitYieldStatement(Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax node) { }
    }
    public abstract partial class CSharpSyntaxVisitor<TResult>
    {
        protected CSharpSyntaxVisitor() { }
        public virtual TResult DefaultVisit(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public virtual TResult Visit(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public virtual TResult VisitAccessorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax node) { throw null; }
        public virtual TResult VisitAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax node) { throw null; }
        public virtual TResult VisitAliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax node) { throw null; }
        public virtual TResult VisitAnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax node) { throw null; }
        public virtual TResult VisitAnonymousObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax node) { throw null; }
        public virtual TResult VisitAnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax node) { throw null; }
        public virtual TResult VisitArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax node) { throw null; }
        public virtual TResult VisitArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax node) { throw null; }
        public virtual TResult VisitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax node) { throw null; }
        public virtual TResult VisitArrayRankSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax node) { throw null; }
        public virtual TResult VisitArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax node) { throw null; }
        public virtual TResult VisitArrowExpressionClause(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax node) { throw null; }
        public virtual TResult VisitAssignmentExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax node) { throw null; }
        public virtual TResult VisitAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax node) { throw null; }
        public virtual TResult VisitAttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax node) { throw null; }
        public virtual TResult VisitAttributeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax node) { throw null; }
        public virtual TResult VisitAttributeList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax node) { throw null; }
        public virtual TResult VisitAttributeTargetSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax node) { throw null; }
        public virtual TResult VisitAwaitExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax node) { throw null; }
        public virtual TResult VisitBadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitBaseExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax node) { throw null; }
        public virtual TResult VisitBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax node) { throw null; }
        public virtual TResult VisitBinaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax node) { throw null; }
        public virtual TResult VisitBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax node) { throw null; }
        public virtual TResult VisitBracketedArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax node) { throw null; }
        public virtual TResult VisitBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax node) { throw null; }
        public virtual TResult VisitBreakStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax node) { throw null; }
        public virtual TResult VisitCasePatternSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax node) { throw null; }
        public virtual TResult VisitCaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax node) { throw null; }
        public virtual TResult VisitCastExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax node) { throw null; }
        public virtual TResult VisitCatchClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax node) { throw null; }
        public virtual TResult VisitCatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax node) { throw null; }
        public virtual TResult VisitCatchFilterClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax node) { throw null; }
        public virtual TResult VisitCheckedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax node) { throw null; }
        public virtual TResult VisitCheckedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax node) { throw null; }
        public virtual TResult VisitClassDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax node) { throw null; }
        public virtual TResult VisitClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax node) { throw null; }
        public virtual TResult VisitCompilationUnit(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax node) { throw null; }
        public virtual TResult VisitConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax node) { throw null; }
        public virtual TResult VisitConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax node) { throw null; }
        public virtual TResult VisitConstantPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax node) { throw null; }
        public virtual TResult VisitConstructorConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax node) { throw null; }
        public virtual TResult VisitConstructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax node) { throw null; }
        public virtual TResult VisitConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax node) { throw null; }
        public virtual TResult VisitContinueStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax node) { throw null; }
        public virtual TResult VisitConversionOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax node) { throw null; }
        public virtual TResult VisitConversionOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax node) { throw null; }
        public virtual TResult VisitCrefBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax node) { throw null; }
        public virtual TResult VisitCrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax node) { throw null; }
        public virtual TResult VisitCrefParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax node) { throw null; }
        public virtual TResult VisitDeclarationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax node) { throw null; }
        public virtual TResult VisitDeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax node) { throw null; }
        public virtual TResult VisitDefaultExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax node) { throw null; }
        public virtual TResult VisitDefaultSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax node) { throw null; }
        public virtual TResult VisitDefineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitDelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax node) { throw null; }
        public virtual TResult VisitDestructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax node) { throw null; }
        public virtual TResult VisitDiscardDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax node) { throw null; }
        public virtual TResult VisitDocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax node) { throw null; }
        public virtual TResult VisitDoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax node) { throw null; }
        public virtual TResult VisitElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax node) { throw null; }
        public virtual TResult VisitElementBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax node) { throw null; }
        public virtual TResult VisitElifDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitElseClause(Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax node) { throw null; }
        public virtual TResult VisitElseDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitEmptyStatement(Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax node) { throw null; }
        public virtual TResult VisitEndIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitEndRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitEnumDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax node) { throw null; }
        public virtual TResult VisitEnumMemberDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax node) { throw null; }
        public virtual TResult VisitEqualsValueClause(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax node) { throw null; }
        public virtual TResult VisitErrorDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitEventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax node) { throw null; }
        public virtual TResult VisitEventFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax node) { throw null; }
        public virtual TResult VisitExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax node) { throw null; }
        public virtual TResult VisitExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax node) { throw null; }
        public virtual TResult VisitExternAliasDirective(Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax node) { throw null; }
        public virtual TResult VisitFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax node) { throw null; }
        public virtual TResult VisitFinallyClause(Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax node) { throw null; }
        public virtual TResult VisitFixedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax node) { throw null; }
        public virtual TResult VisitForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax node) { throw null; }
        public virtual TResult VisitForEachVariableStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax node) { throw null; }
        public virtual TResult VisitForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax node) { throw null; }
        public virtual TResult VisitFromClause(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax node) { throw null; }
        public virtual TResult VisitGenericName(Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax node) { throw null; }
        public virtual TResult VisitGlobalStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax node) { throw null; }
        public virtual TResult VisitGotoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax node) { throw null; }
        public virtual TResult VisitGroupClause(Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax node) { throw null; }
        public virtual TResult VisitIdentifierName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax node) { throw null; }
        public virtual TResult VisitIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitIfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax node) { throw null; }
        public virtual TResult VisitImplicitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax node) { throw null; }
        public virtual TResult VisitImplicitElementAccess(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax node) { throw null; }
        public virtual TResult VisitIncompleteMember(Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax node) { throw null; }
        public virtual TResult VisitIndexerDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax node) { throw null; }
        public virtual TResult VisitIndexerMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax node) { throw null; }
        public virtual TResult VisitInitializerExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax node) { throw null; }
        public virtual TResult VisitInterfaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax node) { throw null; }
        public virtual TResult VisitInterpolatedStringExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax node) { throw null; }
        public virtual TResult VisitInterpolatedStringText(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax node) { throw null; }
        public virtual TResult VisitInterpolation(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax node) { throw null; }
        public virtual TResult VisitInterpolationAlignmentClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax node) { throw null; }
        public virtual TResult VisitInterpolationFormatClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax node) { throw null; }
        public virtual TResult VisitInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax node) { throw null; }
        public virtual TResult VisitIsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax node) { throw null; }
        public virtual TResult VisitJoinClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax node) { throw null; }
        public virtual TResult VisitJoinIntoClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node) { throw null; }
        public virtual TResult VisitLabeledStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax node) { throw null; }
        public virtual TResult VisitLetClause(Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax node) { throw null; }
        public virtual TResult VisitLineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitLiteralExpression(Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax node) { throw null; }
        public virtual TResult VisitLoadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax node) { throw null; }
        public virtual TResult VisitLocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax node) { throw null; }
        public virtual TResult VisitLockStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax node) { throw null; }
        public virtual TResult VisitMakeRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax node) { throw null; }
        public virtual TResult VisitMemberAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax node) { throw null; }
        public virtual TResult VisitMemberBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax node) { throw null; }
        public virtual TResult VisitMethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax node) { throw null; }
        public virtual TResult VisitNameColon(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax node) { throw null; }
        public virtual TResult VisitNameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax node) { throw null; }
        public virtual TResult VisitNameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax node) { throw null; }
        public virtual TResult VisitNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax node) { throw null; }
        public virtual TResult VisitNullableType(Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax node) { throw null; }
        public virtual TResult VisitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax node) { throw null; }
        public virtual TResult VisitOmittedArraySizeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax node) { throw null; }
        public virtual TResult VisitOmittedTypeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax node) { throw null; }
        public virtual TResult VisitOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax node) { throw null; }
        public virtual TResult VisitOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax node) { throw null; }
        public virtual TResult VisitOrderByClause(Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax node) { throw null; }
        public virtual TResult VisitOrdering(Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node) { throw null; }
        public virtual TResult VisitParameter(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax node) { throw null; }
        public virtual TResult VisitParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax node) { throw null; }
        public virtual TResult VisitParenthesizedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax node) { throw null; }
        public virtual TResult VisitParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax node) { throw null; }
        public virtual TResult VisitParenthesizedVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax node) { throw null; }
        public virtual TResult VisitPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax node) { throw null; }
        public virtual TResult VisitPostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax node) { throw null; }
        public virtual TResult VisitPragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitPragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitPredefinedType(Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax node) { throw null; }
        public virtual TResult VisitPrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax node) { throw null; }
        public virtual TResult VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax node) { throw null; }
        public virtual TResult VisitQualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax node) { throw null; }
        public virtual TResult VisitQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax node) { throw null; }
        public virtual TResult VisitQueryBody(Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax node) { throw null; }
        public virtual TResult VisitQueryContinuation(Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node) { throw null; }
        public virtual TResult VisitQueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax node) { throw null; }
        public virtual TResult VisitReferenceDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax node) { throw null; }
        public virtual TResult VisitRefType(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax node) { throw null; }
        public virtual TResult VisitRefTypeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax node) { throw null; }
        public virtual TResult VisitRefValueExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax node) { throw null; }
        public virtual TResult VisitRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitReturnStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax node) { throw null; }
        public virtual TResult VisitSelectClause(Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax node) { throw null; }
        public virtual TResult VisitShebangDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitSimpleBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax node) { throw null; }
        public virtual TResult VisitSimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax node) { throw null; }
        public virtual TResult VisitSingleVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax node) { throw null; }
        public virtual TResult VisitSizeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax node) { throw null; }
        public virtual TResult VisitSkippedTokensTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax node) { throw null; }
        public virtual TResult VisitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax node) { throw null; }
        public virtual TResult VisitStructDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax node) { throw null; }
        public virtual TResult VisitSwitchSection(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax node) { throw null; }
        public virtual TResult VisitSwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax node) { throw null; }
        public virtual TResult VisitThisExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax node) { throw null; }
        public virtual TResult VisitThrowExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax node) { throw null; }
        public virtual TResult VisitThrowStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax node) { throw null; }
        public virtual TResult VisitTryStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax node) { throw null; }
        public virtual TResult VisitTupleElement(Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax node) { throw null; }
        public virtual TResult VisitTupleExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax node) { throw null; }
        public virtual TResult VisitTupleType(Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax node) { throw null; }
        public virtual TResult VisitTypeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax node) { throw null; }
        public virtual TResult VisitTypeConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax node) { throw null; }
        public virtual TResult VisitTypeCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax node) { throw null; }
        public virtual TResult VisitTypeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax node) { throw null; }
        public virtual TResult VisitTypeParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax node) { throw null; }
        public virtual TResult VisitTypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax node) { throw null; }
        public virtual TResult VisitTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax node) { throw null; }
        public virtual TResult VisitUndefDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitUnsafeStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax node) { throw null; }
        public virtual TResult VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax node) { throw null; }
        public virtual TResult VisitUsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax node) { throw null; }
        public virtual TResult VisitVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax node) { throw null; }
        public virtual TResult VisitVariableDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax node) { throw null; }
        public virtual TResult VisitWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult VisitWhenClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax node) { throw null; }
        public virtual TResult VisitWhereClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax node) { throw null; }
        public virtual TResult VisitWhileStatement(Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax node) { throw null; }
        public virtual TResult VisitXmlCDataSection(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax node) { throw null; }
        public virtual TResult VisitXmlComment(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax node) { throw null; }
        public virtual TResult VisitXmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax node) { throw null; }
        public virtual TResult VisitXmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax node) { throw null; }
        public virtual TResult VisitXmlElementEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax node) { throw null; }
        public virtual TResult VisitXmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax node) { throw null; }
        public virtual TResult VisitXmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax node) { throw null; }
        public virtual TResult VisitXmlName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax node) { throw null; }
        public virtual TResult VisitXmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax node) { throw null; }
        public virtual TResult VisitXmlPrefix(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax node) { throw null; }
        public virtual TResult VisitXmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax node) { throw null; }
        public virtual TResult VisitXmlText(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax node) { throw null; }
        public virtual TResult VisitXmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax node) { throw null; }
        public virtual TResult VisitYieldStatement(Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax node) { throw null; }
    }
    public abstract partial class CSharpSyntaxWalker : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor
    {
        protected CSharpSyntaxWalker(Microsoft.CodeAnalysis.SyntaxWalkerDepth depth=(Microsoft.CodeAnalysis.SyntaxWalkerDepth)(0)) { }
        protected Microsoft.CodeAnalysis.SyntaxWalkerDepth Depth { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public override void DefaultVisit(Microsoft.CodeAnalysis.SyntaxNode node) { }
        public override void Visit(Microsoft.CodeAnalysis.SyntaxNode node) { }
        public virtual void VisitLeadingTrivia(Microsoft.CodeAnalysis.SyntaxToken token) { }
        public virtual void VisitToken(Microsoft.CodeAnalysis.SyntaxToken token) { }
        public virtual void VisitTrailingTrivia(Microsoft.CodeAnalysis.SyntaxToken token) { }
        public virtual void VisitTrivia(Microsoft.CodeAnalysis.SyntaxTrivia trivia) { }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct ForEachStatementInfo : System.IEquatable<Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo>
    {
        public Microsoft.CodeAnalysis.CSharp.Conversion CurrentConversion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.IPropertySymbol CurrentProperty { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.IMethodSymbol DisposeMethod { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Conversion ElementConversion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.ITypeSymbol ElementType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.IMethodSymbol GetEnumeratorMethod { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.IMethodSymbol MoveNextMethod { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    public enum LanguageVersion
    {
        CSharp1 = 1,
        CSharp2 = 2,
        CSharp3 = 3,
        CSharp4 = 4,
        CSharp5 = 5,
        CSharp6 = 6,
        CSharp7 = 7,
        Default = 0,
        Latest = 2147483647,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct QueryClauseInfo : System.IEquatable<Microsoft.CodeAnalysis.CSharp.QueryClauseInfo>
    {
        public Microsoft.CodeAnalysis.SymbolInfo CastInfo { get { throw null; } }
        public Microsoft.CodeAnalysis.SymbolInfo OperationInfo { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.CSharp.QueryClauseInfo other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    public static partial class SymbolDisplay
    {
        public static string FormatLiteral(char c, bool quote) { throw null; }
        public static string FormatLiteral(string value, bool quote) { throw null; }
        public static string FormatPrimitive(object obj, bool quoteStrings, bool useHexadecimalNumbers) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SymbolDisplayPart> ToDisplayParts(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SymbolDisplayFormat format=null) { throw null; }
        public static string ToDisplayString(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SymbolDisplayFormat format=null) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SymbolDisplayPart> ToMinimalDisplayParts(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SymbolDisplayFormat format=null) { throw null; }
        public static string ToMinimalDisplayString(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SymbolDisplayFormat format=null) { throw null; }
    }
    public static partial class SyntaxExtensions
    {
        public static Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace(this Microsoft.CodeAnalysis.SyntaxToken token, string indentation, bool elasticTrivia) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace(this Microsoft.CodeAnalysis.SyntaxToken token, string indentation="    ", string eol="\r\n", bool elasticTrivia=false) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace(this Microsoft.CodeAnalysis.SyntaxTriviaList list, string indentation, bool elasticTrivia) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace(this Microsoft.CodeAnalysis.SyntaxTriviaList list, string indentation="    ", string eol="\r\n", bool elasticTrivia=false) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList ToSyntaxTriviaList(this System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> sequence) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax Update(this Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax syntax, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken thisKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax Update(this Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax syntax, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax Update(this Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax syntax, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax WithIdentifier(this Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax simpleName, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
    }
    public static partial class SyntaxFactory
    {
        public static Microsoft.CodeAnalysis.SyntaxTrivia CarriageReturn { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia CarriageReturnLineFeed { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticCarriageReturn { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticCarriageReturnLineFeed { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticLineFeed { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticMarker { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticSpace { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticTab { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia LineFeed { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia Space { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia Tab { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax AccessorList(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax> accessors=default(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax AccessorList(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax> accessors, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax AliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax alias, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax AliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax alias, Microsoft.CodeAnalysis.SyntaxToken colonColonToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax AliasQualifiedName(string alias, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.SyntaxToken delegateKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax> initializers=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax> initializers, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax nameEquals, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static bool AreEquivalent(Microsoft.CodeAnalysis.SyntaxNode oldNode, Microsoft.CodeAnalysis.SyntaxNode newNode, bool topLevel) { throw null; }
        public static bool AreEquivalent(Microsoft.CodeAnalysis.SyntaxNode oldNode, Microsoft.CodeAnalysis.SyntaxNode newNode, System.Func<Microsoft.CodeAnalysis.CSharp.SyntaxKind, bool> ignoreChildNode=null) { throw null; }
        public static bool AreEquivalent(Microsoft.CodeAnalysis.SyntaxToken oldToken, Microsoft.CodeAnalysis.SyntaxToken newToken) { throw null; }
        public static bool AreEquivalent(Microsoft.CodeAnalysis.SyntaxTokenList oldList, Microsoft.CodeAnalysis.SyntaxTokenList newList) { throw null; }
        public static bool AreEquivalent(Microsoft.CodeAnalysis.SyntaxTree oldTree, Microsoft.CodeAnalysis.SyntaxTree newTree, bool topLevel) { throw null; }
        public static bool AreEquivalent<TNode>(Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> oldList, Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> newList, bool topLevel) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static bool AreEquivalent<TNode>(Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> oldList, Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> newList, System.Func<Microsoft.CodeAnalysis.CSharp.SyntaxKind, bool> ignoreChildNode=null) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static bool AreEquivalent<TNode>(Microsoft.CodeAnalysis.SyntaxList<TNode> oldList, Microsoft.CodeAnalysis.SyntaxList<TNode> newList, bool topLevel) where TNode : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode { throw null; }
        public static bool AreEquivalent<TNode>(Microsoft.CodeAnalysis.SyntaxList<TNode> oldList, Microsoft.CodeAnalysis.SyntaxList<TNode> newList, System.Func<Microsoft.CodeAnalysis.CSharp.SyntaxKind, bool> ignoreChildNode=null) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax Argument(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax Argument(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax nameColon, Microsoft.CodeAnalysis.SyntaxToken refOrOutKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax ArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax ArgumentList(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax ArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax ArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax ArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax ArrayRankSpecifier(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> sizes=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax ArrayRankSpecifier(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> sizes, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax ArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax ArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax> rankSpecifiers) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax ArrowExpressionClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax ArrowExpressionClause(Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax AssignmentExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax AssignmentExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax Attribute(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax Attribute(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax argumentList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax AttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax AttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax nameEquals, Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax nameColon, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax AttributeArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax> arguments=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax AttributeArgumentList(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax AttributeList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax target, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax> attributes) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax AttributeList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax> attributes=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax AttributeList(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax target, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax> attributes, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax AttributeTargetSpecifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax AttributeTargetSpecifier(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax AwaitExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax AwaitExpression(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax BadDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax BadDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken identifier, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken BadToken(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax BaseExpression() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax BaseExpression(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax BaseList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax> types=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax BaseList(Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax> types) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax BinaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax BinaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] statements) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements=default(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax BracketedArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax BracketedArgumentList(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax BracketedParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax BracketedParameterList(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax BreakStatement() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax BreakStatement(Microsoft.CodeAnalysis.SyntaxToken breakKeyword, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax CasePatternSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern, Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax whenClause, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax CasePatternSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax CasePatternSwitchLabel(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern, Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax whenClause, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax CaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax CaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax CaseSwitchLabel(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax CastExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax CastExpression(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax CatchClause() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax CatchClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax declaration, Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax filter, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax CatchClause(Microsoft.CodeAnalysis.SyntaxToken catchKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax declaration, Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax filter, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax CatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax CatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax CatchDeclaration(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax CatchFilterClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax filterExpression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax CatchFilterClause(Microsoft.CodeAnalysis.SyntaxToken whenKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax filterExpression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax CheckedExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax CheckedExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax CheckedStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block=null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax CheckedStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax ClassDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax ClassDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax ClassDeclaration(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax ClassDeclaration(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax ClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax ClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken classOrStructKeyword) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia Comment(string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax CompilationUnit() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax CompilationUnit(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax CompilationUnit(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken endOfFileToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax ConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenNotNull) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax ConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenNotNull) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax ConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenTrue, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenFalse) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax ConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken questionToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenTrue, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenFalse) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax ConstantPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax ConstructorConstraint() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax ConstructorConstraint(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax ConstructorInitializer(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList=null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax ConstructorInitializer(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SyntaxToken thisOrBaseKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax ContinueStatement() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax ContinueStatement(Microsoft.CodeAnalysis.SyntaxToken continueKeyword, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax parameters) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax parameters) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax CrefBracketedParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax CrefBracketedParameterList(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax CrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax CrefParameter(Microsoft.CodeAnalysis.SyntaxToken refOrOutKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax CrefParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax CrefParameterList(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax DeclarationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax DeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax DefaultExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax DefaultExpression(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax DefaultSwitchLabel() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax DefaultSwitchLabel(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax DefaultSwitchLabel(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax DefineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken defineKeyword, Microsoft.CodeAnalysis.SyntaxToken name, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax DefineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken name, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax DefineDirectiveTrivia(string name, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax DelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax DelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax DelegateDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax DelegateDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken delegateKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken tildeToken, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken tildeToken, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken tildeToken, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia DisabledText(string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax DiscardDesignation() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax DiscardDesignation(Microsoft.CodeAnalysis.SyntaxToken underscoreToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax DocumentationComment(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia DocumentationCommentExterior(string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax DocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content=default(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax DocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content, Microsoft.CodeAnalysis.SyntaxToken endOfComment) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax DoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax DoStatement(Microsoft.CodeAnalysis.SyntaxToken doKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.SyntaxToken whileKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticEndOfLine(string text) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticWhitespace(string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax ElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax ElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax ElementBindingExpression() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax ElementBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax ElifDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax ElifDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken elifKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax ElseClause(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax ElseClause(Microsoft.CodeAnalysis.SyntaxToken elseKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax ElseDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken elseKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax ElseDirectiveTrivia(bool isActive, bool branchTaken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax EmptyStatement() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax EmptyStatement(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken endIfKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia EndOfLine(string text) { throw null; }
        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
        [System.ObsoleteAttribute("Use SyntaxFactory.EndOfLine or SyntaxFactory.ElasticEndOfLine")]
        public static Microsoft.CodeAnalysis.SyntaxTrivia EndOfLine(string text, bool elastic) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken endRegionKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax EnumDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax EnumDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken enumKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax EnumDeclaration(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax EnumDeclaration(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax EnumMemberDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax equalsValue) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax EnumMemberDeclaration(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax EnumMemberDeclaration(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax EqualsValueClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax EqualsValueClause(Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken errorKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken eventKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax EventFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax EventFieldDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax EventFieldDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken eventKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken dotToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax ExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax ExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax ExternAliasDirective(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax ExternAliasDirective(Microsoft.CodeAnalysis.SyntaxToken externKeyword, Microsoft.CodeAnalysis.SyntaxToken aliasKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax ExternAliasDirective(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax FieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax FieldDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax FieldDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax FinallyClause(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block=null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax FinallyClause(Microsoft.CodeAnalysis.SyntaxToken finallyKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax FixedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax FixedStatement(Microsoft.CodeAnalysis.SyntaxToken fixedKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax ForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax ForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, string identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax ForEachStatement(Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax ForEachVariableStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax variable, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax ForEachVariableStatement(Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax variable, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax ForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax ForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> initializers, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> incrementors, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax ForStatement(Microsoft.CodeAnalysis.SyntaxToken forKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> initializers, Microsoft.CodeAnalysis.SyntaxToken firstSemicolonToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> incrementors, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax FromClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax FromClause(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax FromClause(Microsoft.CodeAnalysis.SyntaxToken fromKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax FromClause(string identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax GenericName(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax GenericName(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax typeArgumentList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax GenericName(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax GetNonGenericExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax GetStandaloneExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax GlobalStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax GotoStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression=null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax GotoStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken caseOrDefaultKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax GotoStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken gotoKeyword, Microsoft.CodeAnalysis.SyntaxToken caseOrDefaultKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax GroupClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax groupExpression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax byExpression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax GroupClause(Microsoft.CodeAnalysis.SyntaxToken groupKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax groupExpression, Microsoft.CodeAnalysis.SyntaxToken byKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax byExpression) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Identifier(Microsoft.CodeAnalysis.SyntaxTriviaList leading, Microsoft.CodeAnalysis.CSharp.SyntaxKind contextualKind, string text, string valueText, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Identifier(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Identifier(string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax IdentifierName(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax IdentifierName(string name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax IfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax IfDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken ifKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax IfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax IfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax @else) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax IfStatement(Microsoft.CodeAnalysis.SyntaxToken ifKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax @else) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SyntaxTokenList commas, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxTokenList commas, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax ImplicitElementAccess() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax ImplicitElementAccess(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax IncompleteMember(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type=null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax IncompleteMember(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax IndexerDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax IndexerDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax IndexerDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax IndexerDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken thisKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax IndexerMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax parameters=null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax IndexerMemberCref(Microsoft.CodeAnalysis.SyntaxToken thisKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax parameters) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax InitializerExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> expressions=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax InitializerExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> expressions, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax InterfaceDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax InterfaceDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax InterfaceDeclaration(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax InterfaceDeclaration(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax InterpolatedStringExpression(Microsoft.CodeAnalysis.SyntaxToken stringStartToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax InterpolatedStringExpression(Microsoft.CodeAnalysis.SyntaxToken stringStartToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax> contents) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax InterpolatedStringExpression(Microsoft.CodeAnalysis.SyntaxToken stringStartToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax> contents, Microsoft.CodeAnalysis.SyntaxToken stringEndToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax InterpolatedStringText() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax InterpolatedStringText(Microsoft.CodeAnalysis.SyntaxToken textToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax Interpolation(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax Interpolation(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax alignmentClause, Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax formatClause) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax Interpolation(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax alignmentClause, Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax formatClause, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(Microsoft.CodeAnalysis.SyntaxToken commaToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax InterpolationFormatClause(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax InterpolationFormatClause(Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SyntaxToken formatStringToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax InvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax InvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public static bool IsCompleteSubmission(Microsoft.CodeAnalysis.SyntaxTree tree) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax IsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax IsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken isKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax JoinClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax inExpression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax leftExpression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax rightExpression, Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax into) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax JoinClause(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax inExpression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax leftExpression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax rightExpression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax JoinClause(Microsoft.CodeAnalysis.SyntaxToken joinKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax inExpression, Microsoft.CodeAnalysis.SyntaxToken onKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax leftExpression, Microsoft.CodeAnalysis.SyntaxToken equalsKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax rightExpression, Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax into) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax JoinClause(string identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax inExpression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax leftExpression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax rightExpression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax JoinIntoClause(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax JoinIntoClause(Microsoft.CodeAnalysis.SyntaxToken intoKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax JoinIntoClause(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax LabeledStatement(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax LabeledStatement(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax LabeledStatement(string identifier, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax LetClause(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax LetClause(Microsoft.CodeAnalysis.SyntaxToken letKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax LetClause(string identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax LineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken lineKeyword, Microsoft.CodeAnalysis.SyntaxToken line, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax LineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken line, Microsoft.CodeAnalysis.SyntaxToken file, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax LineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken line, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxList<TNode> List<TNode>() where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxList<TNode> List<TNode>(System.Collections.Generic.IEnumerable<TNode> nodes) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, char value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, decimal value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, double value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, int value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, long value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, float value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, string value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, uint value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, ulong value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(char value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(decimal value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(double value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(int value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(long value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(float value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, char value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, decimal value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, double value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, int value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, long value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, float value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, string value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, uint value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, ulong value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(uint value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(ulong value) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax LiteralExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax LiteralExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax LoadDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken loadKeyword, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax LoadDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken file, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax LockStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax LockStatement(Microsoft.CodeAnalysis.SyntaxToken lockKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax MakeRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax MakeRefExpression(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax MemberAccessExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax MemberAccessExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax MemberBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax MemberBindingExpression(Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken MissingToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken MissingToken(Microsoft.CodeAnalysis.SyntaxTriviaList leading, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax NameColon(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax NameColon(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax NameColon(string name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax NameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax NameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax NameEquals(string name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax NameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax NameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax name, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax parameters) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax NamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax NamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax NamespaceDeclaration(Microsoft.CodeAnalysis.SyntaxToken namespaceKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxNodeOrTokenList NodeOrTokenList() { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxNodeOrTokenList NodeOrTokenList(params Microsoft.CodeAnalysis.SyntaxNodeOrToken[] nodesAndTokens) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxNodeOrTokenList NodeOrTokenList(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken> nodesAndTokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax NullableType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax NullableType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType, Microsoft.CodeAnalysis.SyntaxToken questionToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax ObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax ObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax ObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax OmittedArraySizeExpression() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(Microsoft.CodeAnalysis.SyntaxToken omittedArraySizeExpressionToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax OmittedTypeArgument() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax OmittedTypeArgument(Microsoft.CodeAnalysis.SyntaxToken omittedTypeArgumentToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax OperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax OperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax parameters) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax OperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax parameters) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax OrderByClause(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax> orderings=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax OrderByClause(Microsoft.CodeAnalysis.SyntaxToken orderByKeyword, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax> orderings) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax Ordering(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax Ordering(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken ascendingOrDescendingKeyword) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax Parameter(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax @default) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax Parameter(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax ParenthesizedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax ParenthesizedExpression(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax> variables=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax> variables, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax ParseArgumentList(string text, int offset=0, Microsoft.CodeAnalysis.ParseOptions options=null, bool consumeFullText=true) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax ParseAttributeArgumentList(string text, int offset=0, Microsoft.CodeAnalysis.ParseOptions options=null, bool consumeFullText=true) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax ParseBracketedArgumentList(string text, int offset=0, Microsoft.CodeAnalysis.ParseOptions options=null, bool consumeFullText=true) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax ParseBracketedParameterList(string text, int offset=0, Microsoft.CodeAnalysis.ParseOptions options=null, bool consumeFullText=true) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax ParseCompilationUnit(string text, int offset=0, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions options=null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax ParseExpression(string text, int offset=0, Microsoft.CodeAnalysis.ParseOptions options=null, bool consumeFullText=true) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList ParseLeadingTrivia(string text, int offset=0) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax ParseName(string text, int offset=0, bool consumeFullText=true) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParseParameterList(string text, int offset=0, Microsoft.CodeAnalysis.ParseOptions options=null, bool consumeFullText=true) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax ParseStatement(string text, int offset=0, Microsoft.CodeAnalysis.ParseOptions options=null, bool consumeFullText=true) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTree ParseSyntaxTree(Microsoft.CodeAnalysis.Text.SourceText text, Microsoft.CodeAnalysis.ParseOptions options=null, string path="", System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTree ParseSyntaxTree(string text, Microsoft.CodeAnalysis.ParseOptions options=null, string path="", System.Text.Encoding encoding=null, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken ParseToken(string text, int offset=0) { throw null; }
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> ParseTokens(string text, int offset=0, int initialTokenPosition=0, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions options=null) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList ParseTrailingTrivia(string text, int offset=0) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ParseTypeName(string text, int offset=0, bool consumeFullText=true) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax PointerType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax PointerType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType, Microsoft.CodeAnalysis.SyntaxToken asteriskToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax PostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax PostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand, Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken pragmaKeyword, Microsoft.CodeAnalysis.SyntaxToken checksumKeyword, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken guid, Microsoft.CodeAnalysis.SyntaxToken bytes, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken guid, Microsoft.CodeAnalysis.SyntaxToken bytes, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken disableOrRestoreKeyword, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> errorCodes, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken pragmaKeyword, Microsoft.CodeAnalysis.SyntaxToken warningKeyword, Microsoft.CodeAnalysis.SyntaxToken disableOrRestoreKeyword, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> errorCodes, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken disableOrRestoreKeyword, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax PredefinedType(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax PrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax PrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia PreprocessingMessage(string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax QualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax container, Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax member) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax QualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax container, Microsoft.CodeAnalysis.SyntaxToken dotToken, Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax member) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax QualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax left, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax right) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax QualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax left, Microsoft.CodeAnalysis.SyntaxToken dotToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax right) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax QueryBody(Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax selectOrGroup) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax QueryBody(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax> clauses, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax selectOrGroup, Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax continuation) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax QueryContinuation(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax QueryContinuation(Microsoft.CodeAnalysis.SyntaxToken intoKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax QueryContinuation(string identifier, Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax QueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax fromClause, Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken referenceKeyword, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken file, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax RefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax RefExpression(Microsoft.CodeAnalysis.SyntaxToken refKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax RefType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax RefType(Microsoft.CodeAnalysis.SyntaxToken refKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax RefTypeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax RefTypeExpression(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax RefValueExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax RefValueExpression(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken comma, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax RegionDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken regionKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax RegionDirectiveTrivia(bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax ReturnStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression=null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax ReturnStatement(Microsoft.CodeAnalysis.SyntaxToken returnKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax SelectClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax SelectClause(Microsoft.CodeAnalysis.SyntaxToken selectKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> SeparatedList<TNode>() where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> SeparatedList<TNode>(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList nodesAndTokens) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> SeparatedList<TNode>(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken> nodesAndTokens) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> SeparatedList<TNode>(System.Collections.Generic.IEnumerable<TNode> nodes) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> SeparatedList<TNode>(System.Collections.Generic.IEnumerable<TNode> nodes, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> separators) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken exclamationToken, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax SimpleBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxList<TNode> SingletonList<TNode>(TNode node) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> SingletonSeparatedList<TNode>(TNode node) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax SingleVariableDesignation(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax SizeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax SizeOfExpression(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax SkippedTokensTrivia() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.SyntaxTokenList tokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken stackAllocKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax StructDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax StructDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax StructDeclaration(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax StructDeclaration(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax SwitchSection() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax SwitchSection(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax> labels, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax SwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax SwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax> sections) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax SwitchStatement(Microsoft.CodeAnalysis.SyntaxToken switchKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax> sections, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTree SyntaxTree(Microsoft.CodeAnalysis.SyntaxNode root, Microsoft.CodeAnalysis.ParseOptions options=null, string path="", System.Text.Encoding encoding=null) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia SyntaxTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax ThisExpression() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax ThisExpression(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax ThrowExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax ThrowExpression(Microsoft.CodeAnalysis.SyntaxToken throwKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax ThrowStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression=null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax ThrowStatement(Microsoft.CodeAnalysis.SyntaxToken throwKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Token(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Token(Microsoft.CodeAnalysis.SyntaxTriviaList leading, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Token(Microsoft.CodeAnalysis.SyntaxTriviaList leading, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, string text, string valueText, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTokenList TokenList() { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTokenList TokenList(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTokenList TokenList(params Microsoft.CodeAnalysis.SyntaxToken[] tokens) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTokenList TokenList(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> tokens) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia Trivia(Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax node) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList TriviaList() { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList TriviaList(Microsoft.CodeAnalysis.SyntaxTrivia trivia) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList TriviaList(params Microsoft.CodeAnalysis.SyntaxTrivia[] trivias) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList TriviaList(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivias) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax TryStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax> catches, Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax @finally) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax TryStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax> catches=default(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax TryStatement(Microsoft.CodeAnalysis.SyntaxToken tryKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax> catches, Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax @finally) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax TupleElement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax TupleElement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax TupleExpression(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax TupleExpression(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax TupleType(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax> elements=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax TupleType(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax> elements, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax TypeArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax> arguments=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax TypeArgumentList(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax TypeConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax TypeCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax TypeDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributes, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax TypeDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax TypeDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax TypeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax TypeOfExpression(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax TypeParameter(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken varianceKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax TypeParameter(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax TypeParameter(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax> constraints) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(Microsoft.CodeAnalysis.SyntaxToken whereKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax> constraints) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax TypeParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax> parameters=default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax TypeParameterList(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax UndefDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken undefKeyword, Microsoft.CodeAnalysis.SyntaxToken name, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax UndefDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken name, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax UndefDirectiveTrivia(string name, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax UnsafeStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block=null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax UnsafeStatement(Microsoft.CodeAnalysis.SyntaxToken unsafeKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax UsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax alias, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax UsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax UsingDirective(Microsoft.CodeAnalysis.SyntaxToken staticKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax alias, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax UsingDirective(Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxToken staticKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax alias, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax UsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax UsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax UsingStatement(Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax VariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax VariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax> variables) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax VariableDeclarator(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax VariableDeclarator(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax VariableDeclarator(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken VerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, string valueText, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax WarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken warningKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax WarningDirectiveTrivia(bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax WhenClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax WhenClause(Microsoft.CodeAnalysis.SyntaxToken whenKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax WhereClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax WhereClause(Microsoft.CodeAnalysis.SyntaxToken whereKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WhileStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WhileStatement(Microsoft.CodeAnalysis.SyntaxToken whileKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia Whitespace(string text) { throw null; }
        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
        [System.ObsoleteAttribute("Use SyntaxFactory.Whitespace or SyntaxFactory.ElasticWhitespace")]
        public static Microsoft.CodeAnalysis.SyntaxTrivia Whitespace(string text, bool elastic) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax XmlCDataSection(Microsoft.CodeAnalysis.SyntaxToken startCDataToken, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken endCDataToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax XmlCDataSection(Microsoft.CodeAnalysis.SyntaxTokenList textTokens=default(Microsoft.CodeAnalysis.SyntaxTokenList)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax XmlComment(Microsoft.CodeAnalysis.SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken minusMinusGreaterThanToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax XmlComment(Microsoft.CodeAnalysis.SyntaxTokenList textTokens=default(Microsoft.CodeAnalysis.SyntaxTokenList)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, Microsoft.CodeAnalysis.CSharp.SyntaxKind quoteKind) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax endTag) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content, Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax endTag) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlElement(string localName, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax XmlElementEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax XmlElementEndTag(Microsoft.CodeAnalysis.SyntaxToken lessThanSlashToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax XmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax XmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax XmlElementStartTag(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlEmptyElement(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes, Microsoft.CodeAnalysis.SyntaxToken slashGreaterThanToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlEmptyElement(string localName) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken XmlEntity(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, string value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlExampleElement(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlExampleElement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlExceptionElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlExceptionElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlMultiLineElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlMultiLineElement(string localName, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax XmlName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax prefix, Microsoft.CodeAnalysis.SyntaxToken localName) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax XmlName(Microsoft.CodeAnalysis.SyntaxToken localName) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax XmlName(string localName) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax XmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax identifier, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax XmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax identifier, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax XmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, string identifier, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax XmlNameAttribute(string parameterName) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax XmlNewLine(string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlNullKeywordElement() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlParaElement(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlParaElement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlParamElement(string parameterName, params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlParamElement(string parameterName, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlParamRefElement(string parameterName) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlPermissionElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlPermissionElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlPlaceholderElement(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlPlaceholderElement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax XmlPrefix(Microsoft.CodeAnalysis.SyntaxToken prefix) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax XmlPrefix(Microsoft.CodeAnalysis.SyntaxToken prefix, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax XmlPrefix(string prefix) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlPreliminaryElement() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax XmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax XmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax XmlProcessingInstruction(Microsoft.CodeAnalysis.SyntaxToken startProcessingInstructionToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken endProcessingInstructionToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlRemarksElement(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlRemarksElement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlReturnsElement(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlReturnsElement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlSeeAlsoElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlSeeAlsoElement(System.Uri linkAddress, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> linkText) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlSeeElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlSummaryElement(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlSummaryElement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax XmlText() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax XmlText(Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax XmlText(params Microsoft.CodeAnalysis.SyntaxToken[] textTokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax XmlText(string value) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax XmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.CSharp.SyntaxKind quoteKind, Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax XmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax XmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax XmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax XmlTextAttribute(string name, Microsoft.CodeAnalysis.CSharp.SyntaxKind quoteKind, Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax XmlTextAttribute(string name, params Microsoft.CodeAnalysis.SyntaxToken[] textTokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax XmlTextAttribute(string name, string value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken XmlTextLiteral(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, string value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken XmlTextLiteral(string value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken XmlTextLiteral(string text, string value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken XmlTextNewLine(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, string value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken XmlTextNewLine(string text) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken XmlTextNewLine(string text, bool continueXmlDocumentationComment) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlThreadSafetyElement() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlThreadSafetyElement(bool isStatic, bool isInstance) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlValueElement(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlValueElement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax YieldStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression=null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax YieldStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken yieldKeyword, Microsoft.CodeAnalysis.SyntaxToken returnOrBreakKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public static partial class SyntaxFacts
    {
        public static System.Collections.Generic.IEqualityComparer<Microsoft.CodeAnalysis.CSharp.SyntaxKind> EqualityComparer { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetAccessorDeclarationKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind keyword) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetAssignmentExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetBaseTypeDeclarationKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetBinaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetCheckStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind keyword) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetContextualKeywordKind(string text) { throw null; }
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.SyntaxKind> GetContextualKeywordKinds() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetInstanceExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetKeywordKind(string text) { throw null; }
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.SyntaxKind> GetKeywordKinds() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetLiteralExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetOperatorKind(string operatorMetadataName) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetPostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetPrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetPreprocessorKeywordKind(string text) { throw null; }
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.SyntaxKind> GetPreprocessorKeywordKinds() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetPrimaryFunction(Microsoft.CodeAnalysis.CSharp.SyntaxKind keyword) { throw null; }
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.SyntaxKind> GetPunctuationKinds() { throw null; }
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.SyntaxKind> GetReservedKeywordKinds() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetSwitchLabelKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind keyword) { throw null; }
        public static string GetText(Microsoft.CodeAnalysis.Accessibility accessibility) { throw null; }
        public static string GetText(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetTypeDeclarationKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsAccessibilityModifier(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsAccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsAccessorDeclarationKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind keyword) { throw null; }
        public static bool IsAliasQualifier(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public static bool IsAnyOverloadableOperator(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsAnyToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsAnyUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsAssignmentExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsAssignmentExpressionOperatorToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsAttributeName(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public static bool IsAttributeTargetSpecifier(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsBinaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsBinaryExpressionOperatorToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsContextualKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsDocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsFixedStatementExpression(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public static bool IsGlobalMemberDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsIdentifierPartCharacter(char ch) { throw null; }
        public static bool IsIdentifierStartCharacter(char ch) { throw null; }
        public static bool IsIndexed(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node) { throw null; }
        public static bool IsInNamespaceOrTypeContext(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node) { throw null; }
        public static bool IsInstanceExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsInTypeOnlyContext(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node) { throw null; }
        public static bool IsInvoked(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node) { throw null; }
        public static bool IsKeywordKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        [System.ObsoleteAttribute("IsLambdaBody API is obsolete", true)]
        public static bool IsLambdaBody(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public static bool IsLanguagePunctuation(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsLiteralExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsName(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsNamedArgumentName(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public static bool IsNamespaceAliasQualifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node) { throw null; }
        public static bool IsNamespaceMemberDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsNewLine(char ch) { throw null; }
        public static bool IsOverloadableBinaryOperator(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsOverloadableUnaryOperator(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsPostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsPostfixUnaryExpressionToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsPredefinedType(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsPrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsPrefixUnaryExpressionOperatorToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsPreprocessorDirective(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsPreprocessorKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsPreprocessorPunctuation(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsPrimaryFunction(Microsoft.CodeAnalysis.CSharp.SyntaxKind keyword) { throw null; }
        public static bool IsPunctuation(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsPunctuationOrKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsQueryContextualKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsReservedKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsTypeDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsTypeParameterVarianceKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsTypeSyntax(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsUnaryOperatorDeclarationToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsValidIdentifier(string name) { throw null; }
        public static bool IsWhitespace(char ch) { throw null; }
    }
    public enum SyntaxKind : ushort
    {
        AbstractKeyword = (ushort)8356,
        AccessorList = (ushort)8895,
        AddAccessorDeclaration = (ushort)8898,
        AddAssignmentExpression = (ushort)8715,
        AddExpression = (ushort)8668,
        AddKeyword = (ushort)8419,
        AddressOfExpression = (ushort)8737,
        AliasKeyword = (ushort)8407,
        AliasQualifiedName = (ushort)8620,
        AmpersandAmpersandToken = (ushort)8261,
        AmpersandEqualsToken = (ushort)8279,
        AmpersandToken = (ushort)8198,
        AndAssignmentExpression = (ushort)8720,
        AnonymousMethodExpression = (ushort)8641,
        AnonymousObjectCreationExpression = (ushort)8650,
        AnonymousObjectMemberDeclarator = (ushort)8647,
        ArgListExpression = (ushort)8748,
        ArgListKeyword = (ushort)8366,
        Argument = (ushort)8638,
        ArgumentList = (ushort)8636,
        ArrayCreationExpression = (ushort)8651,
        ArrayInitializerExpression = (ushort)8646,
        ArrayRankSpecifier = (ushort)8623,
        ArrayType = (ushort)8622,
        ArrowExpressionClause = (ushort)8917,
        AscendingKeyword = (ushort)8432,
        AscendingOrdering = (ushort)8782,
        AsExpression = (ushort)8687,
        AsKeyword = (ushort)8364,
        AssemblyKeyword = (ushort)8409,
        AsteriskEqualsToken = (ushort)8277,
        AsteriskToken = (ushort)8199,
        AsyncKeyword = (ushort)8435,
        Attribute = (ushort)8849,
        AttributeArgument = (ushort)8851,
        AttributeArgumentList = (ushort)8850,
        AttributeList = (ushort)8847,
        AttributeTargetSpecifier = (ushort)8848,
        AwaitExpression = (ushort)8740,
        AwaitKeyword = (ushort)8436,
        BackslashToken = (ushort)8210,
        BadDirectiveTrivia = (ushort)8562,
        BadToken = (ushort)8507,
        BarBarToken = (ushort)8260,
        BarEqualsToken = (ushort)8278,
        BarToken = (ushort)8209,
        BaseConstructorInitializer = (ushort)8889,
        BaseExpression = (ushort)8747,
        BaseKeyword = (ushort)8371,
        BaseList = (ushort)8864,
        BitwiseAndExpression = (ushort)8678,
        BitwiseNotExpression = (ushort)8732,
        BitwiseOrExpression = (ushort)8677,
        Block = (ushort)8792,
        BoolKeyword = (ushort)8304,
        BracketedArgumentList = (ushort)8637,
        BracketedParameterList = (ushort)8907,
        BreakKeyword = (ushort)8339,
        BreakStatement = (ushort)8803,
        ByKeyword = (ushort)8427,
        ByteKeyword = (ushort)8305,
        CaretEqualsToken = (ushort)8282,
        CaretToken = (ushort)8197,
        CaseKeyword = (ushort)8332,
        CasePatternSwitchLabel = (ushort)9009,
        CaseSwitchLabel = (ushort)8823,
        CastExpression = (ushort)8640,
        CatchClause = (ushort)8826,
        CatchDeclaration = (ushort)8827,
        CatchFilterClause = (ushort)8828,
        CatchKeyword = (ushort)8335,
        CharacterLiteralExpression = (ushort)8751,
        CharacterLiteralToken = (ushort)8510,
        CharKeyword = (ushort)8317,
        CheckedExpression = (ushort)8762,
        CheckedKeyword = (ushort)8379,
        CheckedStatement = (ushort)8815,
        ChecksumKeyword = (ushort)8478,
        ClassConstraint = (ushort)8868,
        ClassDeclaration = (ushort)8855,
        ClassKeyword = (ushort)8374,
        CloseBraceToken = (ushort)8206,
        CloseBracketToken = (ushort)8208,
        CloseParenToken = (ushort)8201,
        CoalesceExpression = (ushort)8688,
        CollectionInitializerExpression = (ushort)8645,
        ColonColonToken = (ushort)8264,
        ColonToken = (ushort)8211,
        CommaToken = (ushort)8216,
        CompilationUnit = (ushort)8840,
        ComplexElementInitializerExpression = (ushort)8648,
        ConditionalAccessExpression = (ushort)8691,
        ConditionalExpression = (ushort)8633,
        ConstantPattern = (ushort)9002,
        ConstKeyword = (ushort)8350,
        ConstructorConstraint = (ushort)8867,
        ConstructorDeclaration = (ushort)8878,
        ContinueKeyword = (ushort)8340,
        ContinueStatement = (ushort)8804,
        ConversionOperatorDeclaration = (ushort)8877,
        ConversionOperatorMemberCref = (ushort)8602,
        CrefBracketedParameterList = (ushort)8604,
        CrefParameter = (ushort)8605,
        CrefParameterList = (ushort)8603,
        DecimalKeyword = (ushort)8315,
        DeclarationExpression = (ushort)9040,
        DeclarationPattern = (ushort)9000,
        DefaultExpression = (ushort)8764,
        DefaultKeyword = (ushort)8333,
        DefaultSwitchLabel = (ushort)8824,
        DefineDirectiveTrivia = (ushort)8554,
        DefineKeyword = (ushort)8471,
        DelegateDeclaration = (ushort)8859,
        DelegateKeyword = (ushort)8378,
        DescendingKeyword = (ushort)8433,
        DescendingOrdering = (ushort)8783,
        DestructorDeclaration = (ushort)8891,
        DisabledTextTrivia = (ushort)8546,
        DisableKeyword = (ushort)8479,
        DiscardDesignation = (ushort)9014,
        DivideAssignmentExpression = (ushort)8718,
        DivideExpression = (ushort)8671,
        DocumentationCommentExteriorTrivia = (ushort)8543,
        DoKeyword = (ushort)8330,
        DollarToken = (ushort)8195,
        DoStatement = (ushort)8810,
        DotToken = (ushort)8218,
        DoubleKeyword = (ushort)8313,
        DoubleQuoteToken = (ushort)8213,
        ElementAccessExpression = (ushort)8635,
        ElementBindingExpression = (ushort)8708,
        ElifDirectiveTrivia = (ushort)8549,
        ElifKeyword = (ushort)8467,
        ElseClause = (ushort)8820,
        ElseDirectiveTrivia = (ushort)8550,
        ElseKeyword = (ushort)8326,
        EmptyStatement = (ushort)8798,
        EndIfDirectiveTrivia = (ushort)8551,
        EndIfKeyword = (ushort)8468,
        EndOfDirectiveToken = (ushort)8494,
        EndOfDocumentationCommentToken = (ushort)8495,
        EndOfFileToken = (ushort)8496,
        EndOfLineTrivia = (ushort)8539,
        EndRegionDirectiveTrivia = (ushort)8553,
        EndRegionKeyword = (ushort)8470,
        EnumDeclaration = (ushort)8858,
        EnumKeyword = (ushort)8377,
        EnumMemberDeclaration = (ushort)8872,
        EqualsEqualsToken = (ushort)8268,
        EqualsExpression = (ushort)8680,
        EqualsGreaterThanToken = (ushort)8269,
        EqualsKeyword = (ushort)8431,
        EqualsToken = (ushort)8204,
        EqualsValueClause = (ushort)8796,
        ErrorDirectiveTrivia = (ushort)8556,
        ErrorKeyword = (ushort)8474,
        EventDeclaration = (ushort)8893,
        EventFieldDeclaration = (ushort)8874,
        EventKeyword = (ushort)8358,
        ExclamationEqualsToken = (ushort)8267,
        ExclamationToken = (ushort)8194,
        ExclusiveOrAssignmentExpression = (ushort)8721,
        ExclusiveOrExpression = (ushort)8679,
        ExplicitInterfaceSpecifier = (ushort)8871,
        ExplicitKeyword = (ushort)8383,
        ExpressionStatement = (ushort)8797,
        ExternAliasDirective = (ushort)8844,
        ExternKeyword = (ushort)8359,
        FalseKeyword = (ushort)8324,
        FalseLiteralExpression = (ushort)8753,
        FieldDeclaration = (ushort)8873,
        FieldKeyword = (ushort)8412,
        FinallyClause = (ushort)8829,
        FinallyKeyword = (ushort)8336,
        FixedKeyword = (ushort)8351,
        FixedStatement = (ushort)8814,
        FloatKeyword = (ushort)8314,
        ForEachKeyword = (ushort)8329,
        ForEachStatement = (ushort)8812,
        ForEachVariableStatement = (ushort)8929,
        ForKeyword = (ushort)8328,
        ForStatement = (ushort)8811,
        FromClause = (ushort)8776,
        FromKeyword = (ushort)8422,
        GenericName = (ushort)8618,
        GetAccessorDeclaration = (ushort)8896,
        GetKeyword = (ushort)8417,
        GlobalKeyword = (ushort)8408,
        GlobalStatement = (ushort)8841,
        GotoCaseStatement = (ushort)8801,
        GotoDefaultStatement = (ushort)8802,
        GotoKeyword = (ushort)8338,
        GotoStatement = (ushort)8800,
        GreaterThanEqualsToken = (ushort)8273,
        GreaterThanExpression = (ushort)8684,
        GreaterThanGreaterThanEqualsToken = (ushort)8275,
        GreaterThanGreaterThanToken = (ushort)8274,
        GreaterThanOrEqualExpression = (ushort)8685,
        GreaterThanToken = (ushort)8217,
        GroupClause = (ushort)8785,
        GroupKeyword = (ushort)8423,
        HashToken = (ushort)8220,
        HiddenKeyword = (ushort)8477,
        IdentifierName = (ushort)8616,
        IdentifierToken = (ushort)8508,
        IfDirectiveTrivia = (ushort)8548,
        IfKeyword = (ushort)8325,
        IfStatement = (ushort)8819,
        ImplicitArrayCreationExpression = (ushort)8652,
        ImplicitElementAccess = (ushort)8656,
        ImplicitKeyword = (ushort)8384,
        IncompleteMember = (ushort)8916,
        IndexerDeclaration = (ushort)8894,
        IndexerMemberCref = (ushort)8600,
        InKeyword = (ushort)8362,
        InterfaceDeclaration = (ushort)8857,
        InterfaceKeyword = (ushort)8376,
        InternalKeyword = (ushort)8345,
        InterpolatedStringEndToken = (ushort)8483,
        InterpolatedStringExpression = (ushort)8655,
        InterpolatedStringStartToken = (ushort)8482,
        InterpolatedStringText = (ushort)8919,
        InterpolatedStringTextToken = (ushort)8517,
        InterpolatedStringToken = (ushort)8515,
        InterpolatedVerbatimStringStartToken = (ushort)8484,
        Interpolation = (ushort)8918,
        InterpolationAlignmentClause = (ushort)8920,
        InterpolationFormatClause = (ushort)8921,
        IntKeyword = (ushort)8309,
        IntoKeyword = (ushort)8425,
        InvocationExpression = (ushort)8634,
        IsExpression = (ushort)8686,
        IsKeyword = (ushort)8363,
        IsPatternExpression = (ushort)8657,
        JoinClause = (ushort)8778,
        JoinIntoClause = (ushort)8779,
        JoinKeyword = (ushort)8424,
        LabeledStatement = (ushort)8799,
        LeftShiftAssignmentExpression = (ushort)8723,
        LeftShiftExpression = (ushort)8673,
        LessThanEqualsToken = (ushort)8270,
        LessThanExpression = (ushort)8682,
        LessThanLessThanEqualsToken = (ushort)8272,
        LessThanLessThanToken = (ushort)8271,
        LessThanOrEqualExpression = (ushort)8683,
        LessThanSlashToken = (ushort)8233,
        LessThanToken = (ushort)8215,
        LetClause = (ushort)8777,
        LetKeyword = (ushort)8426,
        LineDirectiveTrivia = (ushort)8558,
        LineKeyword = (ushort)8475,
        List = (ushort)1,
        LoadDirectiveTrivia = (ushort)8923,
        LoadKeyword = (ushort)8485,
        LocalDeclarationStatement = (ushort)8793,
        LocalFunctionStatement = (ushort)8830,
        LockKeyword = (ushort)8337,
        LockStatement = (ushort)8818,
        LogicalAndExpression = (ushort)8676,
        LogicalNotExpression = (ushort)8733,
        LogicalOrExpression = (ushort)8675,
        LongKeyword = (ushort)8311,
        MakeRefExpression = (ushort)8765,
        MakeRefKeyword = (ushort)8367,
        MemberBindingExpression = (ushort)8707,
        MethodDeclaration = (ushort)8875,
        MethodKeyword = (ushort)8413,
        MinusEqualsToken = (ushort)8281,
        MinusGreaterThanToken = (ushort)8266,
        MinusMinusToken = (ushort)8262,
        MinusToken = (ushort)8202,
        ModuleKeyword = (ushort)8410,
        ModuloAssignmentExpression = (ushort)8719,
        ModuloExpression = (ushort)8672,
        MultiLineCommentTrivia = (ushort)8542,
        MultiLineDocumentationCommentTrivia = (ushort)8545,
        MultiplyAssignmentExpression = (ushort)8717,
        MultiplyExpression = (ushort)8670,
        NameColon = (ushort)8639,
        NameEquals = (ushort)8852,
        NameMemberCref = (ushort)8599,
        NameOfKeyword = (ushort)8434,
        NamespaceDeclaration = (ushort)8842,
        NamespaceKeyword = (ushort)8372,
        NewKeyword = (ushort)8354,
        None = (ushort)0,
        NotEqualsExpression = (ushort)8681,
        NullableType = (ushort)8625,
        NullKeyword = (ushort)8322,
        NullLiteralExpression = (ushort)8754,
        NumericLiteralExpression = (ushort)8749,
        NumericLiteralToken = (ushort)8509,
        ObjectCreationExpression = (ushort)8649,
        ObjectInitializerExpression = (ushort)8644,
        ObjectKeyword = (ushort)8319,
        OmittedArraySizeExpression = (ushort)8654,
        OmittedArraySizeExpressionToken = (ushort)8493,
        OmittedTypeArgument = (ushort)8626,
        OmittedTypeArgumentToken = (ushort)8492,
        OnKeyword = (ushort)8430,
        OpenBraceToken = (ushort)8205,
        OpenBracketToken = (ushort)8207,
        OpenParenToken = (ushort)8200,
        OperatorDeclaration = (ushort)8876,
        OperatorKeyword = (ushort)8382,
        OperatorMemberCref = (ushort)8601,
        OrAssignmentExpression = (ushort)8722,
        OrderByClause = (ushort)8781,
        OrderByKeyword = (ushort)8429,
        OutKeyword = (ushort)8361,
        OverrideKeyword = (ushort)8355,
        Parameter = (ushort)8908,
        ParameterList = (ushort)8906,
        ParamKeyword = (ushort)8414,
        ParamsKeyword = (ushort)8365,
        ParenthesizedExpression = (ushort)8632,
        ParenthesizedLambdaExpression = (ushort)8643,
        ParenthesizedVariableDesignation = (ushort)8928,
        PartialKeyword = (ushort)8406,
        PercentEqualsToken = (ushort)8283,
        PercentToken = (ushort)8196,
        PlusEqualsToken = (ushort)8280,
        PlusPlusToken = (ushort)8263,
        PlusToken = (ushort)8203,
        PointerIndirectionExpression = (ushort)8736,
        PointerMemberAccessExpression = (ushort)8690,
        PointerType = (ushort)8624,
        PostDecrementExpression = (ushort)8739,
        PostIncrementExpression = (ushort)8738,
        PragmaChecksumDirectiveTrivia = (ushort)8560,
        PragmaKeyword = (ushort)8476,
        PragmaWarningDirectiveTrivia = (ushort)8559,
        PreDecrementExpression = (ushort)8735,
        PredefinedType = (ushort)8621,
        PreIncrementExpression = (ushort)8734,
        PreprocessingMessageTrivia = (ushort)8547,
        PrivateKeyword = (ushort)8344,
        PropertyDeclaration = (ushort)8892,
        PropertyKeyword = (ushort)8415,
        ProtectedKeyword = (ushort)8346,
        PublicKeyword = (ushort)8343,
        QualifiedCref = (ushort)8598,
        QualifiedName = (ushort)8617,
        QueryBody = (ushort)8775,
        QueryContinuation = (ushort)8786,
        QueryExpression = (ushort)8774,
        QuestionQuestionToken = (ushort)8265,
        QuestionToken = (ushort)8219,
        ReadOnlyKeyword = (ushort)8348,
        ReferenceDirectiveTrivia = (ushort)8561,
        ReferenceKeyword = (ushort)8481,
        RefExpression = (ushort)9050,
        RefKeyword = (ushort)8360,
        RefType = (ushort)9051,
        RefTypeExpression = (ushort)8767,
        RefTypeKeyword = (ushort)8368,
        RefValueExpression = (ushort)8766,
        RefValueKeyword = (ushort)8369,
        RegionDirectiveTrivia = (ushort)8552,
        RegionKeyword = (ushort)8469,
        RemoveAccessorDeclaration = (ushort)8899,
        RemoveKeyword = (ushort)8420,
        RestoreKeyword = (ushort)8480,
        ReturnKeyword = (ushort)8341,
        ReturnStatement = (ushort)8805,
        RightShiftAssignmentExpression = (ushort)8724,
        RightShiftExpression = (ushort)8674,
        SByteKeyword = (ushort)8306,
        SealedKeyword = (ushort)8349,
        SelectClause = (ushort)8784,
        SelectKeyword = (ushort)8428,
        SemicolonToken = (ushort)8212,
        SetAccessorDeclaration = (ushort)8897,
        SetKeyword = (ushort)8418,
        ShebangDirectiveTrivia = (ushort)8922,
        ShortKeyword = (ushort)8307,
        SimpleAssignmentExpression = (ushort)8714,
        SimpleBaseType = (ushort)8865,
        SimpleLambdaExpression = (ushort)8642,
        SimpleMemberAccessExpression = (ushort)8689,
        SingleLineCommentTrivia = (ushort)8541,
        SingleLineDocumentationCommentTrivia = (ushort)8544,
        SingleQuoteToken = (ushort)8214,
        SingleVariableDesignation = (ushort)8927,
        SizeOfExpression = (ushort)8761,
        SizeOfKeyword = (ushort)8321,
        SkippedTokensTrivia = (ushort)8563,
        SlashEqualsToken = (ushort)8276,
        SlashGreaterThanToken = (ushort)8232,
        SlashToken = (ushort)8221,
        StackAllocArrayCreationExpression = (ushort)8653,
        StackAllocKeyword = (ushort)8352,
        StaticKeyword = (ushort)8347,
        StringKeyword = (ushort)8316,
        StringLiteralExpression = (ushort)8750,
        StringLiteralToken = (ushort)8511,
        StructConstraint = (ushort)8869,
        StructDeclaration = (ushort)8856,
        StructKeyword = (ushort)8375,
        SubtractAssignmentExpression = (ushort)8716,
        SubtractExpression = (ushort)8669,
        SwitchKeyword = (ushort)8331,
        SwitchSection = (ushort)8822,
        SwitchStatement = (ushort)8821,
        ThisConstructorInitializer = (ushort)8890,
        ThisExpression = (ushort)8746,
        ThisKeyword = (ushort)8370,
        ThrowExpression = (ushort)9052,
        ThrowKeyword = (ushort)8342,
        ThrowStatement = (ushort)8808,
        TildeToken = (ushort)8193,
        TrueKeyword = (ushort)8323,
        TrueLiteralExpression = (ushort)8752,
        TryKeyword = (ushort)8334,
        TryStatement = (ushort)8825,
        TupleElement = (ushort)8925,
        TupleExpression = (ushort)8926,
        TupleType = (ushort)8924,
        TypeArgumentList = (ushort)8619,
        TypeConstraint = (ushort)8870,
        TypeCref = (ushort)8597,
        TypeKeyword = (ushort)8411,
        TypeOfExpression = (ushort)8760,
        TypeOfKeyword = (ushort)8320,
        TypeParameter = (ushort)8910,
        TypeParameterConstraintClause = (ushort)8866,
        TypeParameterList = (ushort)8909,
        TypeVarKeyword = (ushort)8416,
        UIntKeyword = (ushort)8310,
        ULongKeyword = (ushort)8312,
        UnaryMinusExpression = (ushort)8731,
        UnaryPlusExpression = (ushort)8730,
        UncheckedExpression = (ushort)8763,
        UncheckedKeyword = (ushort)8380,
        UncheckedStatement = (ushort)8816,
        UndefDirectiveTrivia = (ushort)8555,
        UndefKeyword = (ushort)8472,
        UnderscoreToken = (ushort)8491,
        UnknownAccessorDeclaration = (ushort)8900,
        UnsafeKeyword = (ushort)8381,
        UnsafeStatement = (ushort)8817,
        UShortKeyword = (ushort)8308,
        UsingDirective = (ushort)8843,
        UsingKeyword = (ushort)8373,
        UsingStatement = (ushort)8813,
        VariableDeclaration = (ushort)8794,
        VariableDeclarator = (ushort)8795,
        VirtualKeyword = (ushort)8357,
        VoidKeyword = (ushort)8318,
        VolatileKeyword = (ushort)8353,
        WarningDirectiveTrivia = (ushort)8557,
        WarningKeyword = (ushort)8473,
        WhenClause = (ushort)9013,
        WhenKeyword = (ushort)8437,
        WhereClause = (ushort)8780,
        WhereKeyword = (ushort)8421,
        WhileKeyword = (ushort)8327,
        WhileStatement = (ushort)8809,
        WhitespaceTrivia = (ushort)8540,
        XmlCDataEndToken = (ushort)8237,
        XmlCDataSection = (ushort)8584,
        XmlCDataStartToken = (ushort)8236,
        XmlComment = (ushort)8585,
        XmlCommentEndToken = (ushort)8235,
        XmlCommentStartToken = (ushort)8234,
        XmlCrefAttribute = (ushort)8579,
        XmlElement = (ushort)8574,
        XmlElementEndTag = (ushort)8576,
        XmlElementStartTag = (ushort)8575,
        XmlEmptyElement = (ushort)8577,
        XmlEntityLiteralToken = (ushort)8512,
        XmlName = (ushort)8581,
        XmlNameAttribute = (ushort)8580,
        XmlPrefix = (ushort)8582,
        XmlProcessingInstruction = (ushort)8586,
        XmlProcessingInstructionEndToken = (ushort)8239,
        XmlProcessingInstructionStartToken = (ushort)8238,
        XmlText = (ushort)8583,
        XmlTextAttribute = (ushort)8578,
        XmlTextLiteralNewLineToken = (ushort)8514,
        XmlTextLiteralToken = (ushort)8513,
        YieldBreakStatement = (ushort)8807,
        YieldKeyword = (ushort)8405,
        YieldReturnStatement = (ushort)8806,
    }
    public static partial class TypedConstantExtensions
    {
        public static string ToCSharpString(this Microsoft.CodeAnalysis.TypedConstant constant) { throw null; }
    }
}
namespace Microsoft.CodeAnalysis.CSharp.Syntax
{
    public sealed partial class AccessorDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AccessorDeclarationSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Body { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax ExpressionBody { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AddBodyStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class AccessorListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AccessorListSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax> Accessors { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax AddAccessors(params Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax> accessors, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax WithAccessors(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax> accessors) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
    }
    public sealed partial class AliasQualifiedNameSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax
    {
        internal AliasQualifiedNameSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax Alias { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ColonColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax alias, Microsoft.CodeAnalysis.SyntaxToken colonColonToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax WithAlias(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax alias) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax WithColonColonToken(Microsoft.CodeAnalysis.SyntaxToken colonColonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
    }
    public abstract partial class AnonymousFunctionExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal AnonymousFunctionExpressionSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxToken AsyncKeyword { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode Body { get; }
    }
    public sealed partial class AnonymousMethodExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax
    {
        internal AnonymousMethodExpressionSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken AsyncKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode Body { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken DelegateKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.SyntaxToken delegateKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax WithAsyncKeyword(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax WithBody(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax WithDelegateKeyword(Microsoft.CodeAnalysis.SyntaxToken delegateKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
    }
    public sealed partial class AnonymousObjectCreationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal AnonymousObjectCreationExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax> Initializers { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken NewKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax AddInitializers(params Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax> initializers, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax WithInitializers(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax> initializers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken newKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
    }
    public sealed partial class AnonymousObjectMemberDeclaratorSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AnonymousObjectMemberDeclaratorSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax NameEquals { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax nameEquals, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax WithNameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax nameEquals) { throw null; }
    }
    public sealed partial class ArgumentListSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax
    {
        internal ArgumentListSyntax() { }
        public override Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> Arguments { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax AddArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax WithArguments(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class ArgumentSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ArgumentSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax NameColon { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken RefOrOutKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax nameColon, Microsoft.CodeAnalysis.SyntaxToken refOrOutKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax WithNameColon(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax nameColon) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax WithRefOrOutKeyword(Microsoft.CodeAnalysis.SyntaxToken refOrOutKeyword) { throw null; }
    }
    public sealed partial class ArrayCreationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ArrayCreationExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax Initializer { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken NewKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax AddTypeRankSpecifiers(params Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken newKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax type) { throw null; }
    }
    public sealed partial class ArrayRankSpecifierSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ArrayRankSpecifierSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken { get { throw null; } }
        public int Rank { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> Sizes { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax AddSizes(params Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> sizes, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax WithCloseBracketToken(Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax WithOpenBracketToken(Microsoft.CodeAnalysis.SyntaxToken openBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax WithSizes(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> sizes) { throw null; }
    }
    public sealed partial class ArrayTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal ArrayTypeSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ElementType { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax> RankSpecifiers { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax AddRankSpecifiers(params Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax> rankSpecifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax WithElementType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax WithRankSpecifiers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax> rankSpecifiers) { throw null; }
    }
    public sealed partial class ArrowExpressionClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ArrowExpressionClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ArrowToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax WithArrowToken(Microsoft.CodeAnalysis.SyntaxToken arrowToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
    }
    public sealed partial class AssignmentExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal AssignmentExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Left { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Right { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax WithLeft(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax WithRight(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
    }
    public sealed partial class AttributeArgumentListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AttributeArgumentListSyntax() { }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax> Arguments { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax AddArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax WithArguments(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax> arguments) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class AttributeArgumentSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AttributeArgumentSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax NameColon { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax NameEquals { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax nameEquals, Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax nameColon, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax WithNameColon(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax nameColon) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax WithNameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax nameEquals) { throw null; }
    }
    public sealed partial class AttributeListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AttributeListSyntax() { }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax> Attributes { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax Target { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax AddAttributes(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax target, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax> attributes, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax WithAttributes(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax> attributes) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax WithCloseBracketToken(Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax WithOpenBracketToken(Microsoft.CodeAnalysis.SyntaxToken openBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax WithTarget(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax target) { throw null; }
    }
    public sealed partial class AttributeSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AttributeSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax ArgumentList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
    }
    public sealed partial class AttributeTargetSpecifierSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AttributeTargetSpecifierSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax Update(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
    }
    public sealed partial class AwaitExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal AwaitExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken AwaitKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax WithAwaitKeyword(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
    }
    public sealed partial class BadDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal BadDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public abstract partial class BaseArgumentListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal BaseArgumentListSyntax() { }
        public abstract Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> Arguments { get; }
    }
    public abstract partial class BaseCrefParameterListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal BaseCrefParameterListSyntax() { }
        public abstract Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> Parameters { get; }
    }
    public sealed partial class BaseExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.InstanceExpressionSyntax
    {
        internal BaseExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Token { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax WithToken(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
    }
    public abstract partial class BaseFieldDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal BaseFieldDeclarationSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax Declaration { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get; }
    }
    public sealed partial class BaseListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal BaseListSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax> Types { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax AddTypes(params Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax> types) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax WithTypes(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax> types) { throw null; }
    }
    public abstract partial class BaseMethodDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal BaseMethodDeclarationSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Body { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax ExpressionBody { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get; }
    }
    public abstract partial class BaseParameterListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal BaseParameterListSyntax() { }
        public abstract Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> Parameters { get; }
    }
    public abstract partial class BasePropertyDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal BasePropertyDeclarationSyntax() { }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax AccessorList { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get; }
    }
    public abstract partial class BaseTypeDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal BaseTypeDeclarationSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax BaseList { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken Identifier { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get; }
    }
    public abstract partial class BaseTypeSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal BaseTypeSyntax() { }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get; }
    }
    public sealed partial class BinaryExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal BinaryExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Left { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Right { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax WithLeft(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax WithRight(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
    }
    public sealed partial class BlockSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal BlockSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> Statements { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax AddStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax WithStatements(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements) { throw null; }
    }
    public sealed partial class BracketedArgumentListSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax
    {
        internal BracketedArgumentListSyntax() { }
        public override Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> Arguments { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax AddArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax WithArguments(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax WithCloseBracketToken(Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax WithOpenBracketToken(Microsoft.CodeAnalysis.SyntaxToken openBracketToken) { throw null; }
    }
    public sealed partial class BracketedParameterListSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax
    {
        internal BracketedParameterListSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> Parameters { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax AddParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax WithCloseBracketToken(Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax WithOpenBracketToken(Microsoft.CodeAnalysis.SyntaxToken openBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax WithParameters(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters) { throw null; }
    }
    public abstract partial class BranchingDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal BranchingDirectiveTriviaSyntax() { }
        public abstract bool BranchTaken { get; }
    }
    public sealed partial class BreakStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal BreakStatementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken BreakKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken breakKeyword, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax WithBreakKeyword(Microsoft.CodeAnalysis.SyntaxToken breakKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class CasePatternSwitchLabelSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax
    {
        internal CasePatternSwitchLabelSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax Pattern { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax WhenClause { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern, Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax whenClause, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax WithPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax WithWhenClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax whenClause) { throw null; }
    }
    public sealed partial class CaseSwitchLabelSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax
    {
        internal CaseSwitchLabelSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Value { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax WithValue(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
    }
    public sealed partial class CastExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal CastExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class CatchClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal CatchClauseSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CatchKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax Declaration { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax Filter { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken catchKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax declaration, Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax filter, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax WithCatchKeyword(Microsoft.CodeAnalysis.SyntaxToken catchKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax WithDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax declaration) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax WithFilter(Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax filter) { throw null; }
    }
    public sealed partial class CatchDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal CatchDeclarationSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class CatchFilterClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal CatchFilterClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax FilterExpression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WhenKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken whenKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax filterExpression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax WithFilterExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax filterExpression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax WithWhenKeyword(Microsoft.CodeAnalysis.SyntaxToken whenKeyword) { throw null; }
    }
    public sealed partial class CheckedExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal CheckedExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class CheckedStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal CheckedStatementSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
    }
    public sealed partial class ClassDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax
    {
        internal ClassDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax BaseList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> Members { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax TypeParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax AddBaseListTypes(params Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax AddConstraintClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax AddTypeParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithConstraintClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithMembers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList) { throw null; }
    }
    public sealed partial class ClassOrStructConstraintSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax
    {
        internal ClassOrStructConstraintSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ClassOrStructKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax Update(Microsoft.CodeAnalysis.SyntaxToken classOrStructKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax WithClassOrStructKeyword(Microsoft.CodeAnalysis.SyntaxToken classOrStructKeyword) { throw null; }
    }
    public abstract partial class CommonForEachStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal CommonForEachStatementSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken ForEachKeyword { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken InKeyword { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get; }
    }
    public sealed partial class CompilationUnitSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.ICompilationUnitSyntax
    {
        internal CompilationUnitSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken EndOfFileToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> Externs { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> Members { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> Usings { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax AddExterns(params Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax AddUsings(params Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax[] items) { throw null; }
        public System.Collections.Generic.IList<Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax> GetLoadDirectives() { throw null; }
        public System.Collections.Generic.IList<Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax> GetReferenceDirectives() { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken endOfFileToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax WithEndOfFileToken(Microsoft.CodeAnalysis.SyntaxToken endOfFileToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax WithExterns(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax WithMembers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax WithUsings(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings) { throw null; }
    }
    public sealed partial class ConditionalAccessExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ConditionalAccessExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax WhenNotNull { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenNotNull) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax WithWhenNotNull(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenNotNull) { throw null; }
    }
    public abstract partial class ConditionalDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BranchingDirectiveTriviaSyntax
    {
        internal ConditionalDirectiveTriviaSyntax() { }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get; }
        public abstract bool ConditionValue { get; }
    }
    public sealed partial class ConditionalExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ConditionalExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken QuestionToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax WhenFalse { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax WhenTrue { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken questionToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenTrue, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenFalse) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax WithQuestionToken(Microsoft.CodeAnalysis.SyntaxToken questionToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax WithWhenFalse(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenFalse) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax WithWhenTrue(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenTrue) { throw null; }
    }
    public sealed partial class ConstantPatternSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax
    {
        internal ConstantPatternSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
    }
    public sealed partial class ConstructorConstraintSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax
    {
        internal ConstructorConstraintSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken NewKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax Update(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken newKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class ConstructorDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax
    {
        internal ConstructorDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Body { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax ExpressionBody { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax Initializer { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax AddBodyStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class ConstructorInitializerSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ConstructorInitializerSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax ArgumentList { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ThisOrBaseKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax Update(Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SyntaxToken thisOrBaseKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax WithThisOrBaseKeyword(Microsoft.CodeAnalysis.SyntaxToken thisOrBaseKeyword) { throw null; }
    }
    public sealed partial class ContinueStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal ContinueStatementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ContinueKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken continueKeyword, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax WithContinueKeyword(Microsoft.CodeAnalysis.SyntaxToken continueKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class ConversionOperatorDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax
    {
        internal ConversionOperatorDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Body { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax ExpressionBody { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ImplicitOrExplicitKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax AddBodyStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithImplicitOrExplicitKeyword(Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithOperatorKeyword(Microsoft.CodeAnalysis.SyntaxToken operatorKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class ConversionOperatorMemberCrefSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax
    {
        internal ConversionOperatorMemberCrefSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ImplicitOrExplicitKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax Parameters { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax AddParametersParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax Update(Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax parameters) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax WithImplicitOrExplicitKeyword(Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax WithOperatorKeyword(Microsoft.CodeAnalysis.SyntaxToken operatorKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax WithParameters(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax parameters) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class CrefBracketedParameterListSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax
    {
        internal CrefBracketedParameterListSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> Parameters { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax AddParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax WithCloseBracketToken(Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax WithOpenBracketToken(Microsoft.CodeAnalysis.SyntaxToken openBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax WithParameters(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters) { throw null; }
    }
    public sealed partial class CrefParameterListSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax
    {
        internal CrefParameterListSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> Parameters { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax AddParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax WithParameters(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters) { throw null; }
    }
    public sealed partial class CrefParameterSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal CrefParameterSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken RefOrOutKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax Update(Microsoft.CodeAnalysis.SyntaxToken refOrOutKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax WithRefOrOutKeyword(Microsoft.CodeAnalysis.SyntaxToken refOrOutKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public abstract partial class CrefSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal CrefSyntax() { }
    }
    public sealed partial class DeclarationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal DeclarationExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax Designation { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax WithDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class DeclarationPatternSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax
    {
        internal DeclarationPatternSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax Designation { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax WithDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class DefaultExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal DefaultExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class DefaultSwitchLabelSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax
    {
        internal DefaultSwitchLabelSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
    }
    public sealed partial class DefineDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal DefineDirectiveTriviaSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken DefineKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken defineKeyword, Microsoft.CodeAnalysis.SyntaxToken name, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax WithDefineKeyword(Microsoft.CodeAnalysis.SyntaxToken defineKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax WithName(Microsoft.CodeAnalysis.SyntaxToken name) { throw null; }
    }
    public sealed partial class DelegateDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal DelegateDeclarationSyntax() { }
        public int Arity { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken DelegateKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ReturnType { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax TypeParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax AddConstraintClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax AddTypeParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken delegateKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithConstraintClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithDelegateKeyword(Microsoft.CodeAnalysis.SyntaxToken delegateKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithReturnType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList) { throw null; }
    }
    public sealed partial class DestructorDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax
    {
        internal DestructorDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Body { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax ExpressionBody { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken TildeToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax AddBodyStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken tildeToken, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken tildeToken, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithTildeToken(Microsoft.CodeAnalysis.SyntaxToken tildeToken) { throw null; }
    }
    public abstract partial class DirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax
    {
        internal DirectiveTriviaSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken DirectiveNameToken { get { throw null; } }
        public abstract Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken HashToken { get; }
        public abstract bool IsActive { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetNextDirective(System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool> predicate=null) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax GetPreviousDirective(System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool> predicate=null) { throw null; }
        public System.Collections.Generic.List<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax> GetRelatedDirectives() { throw null; }
    }
    public sealed partial class DiscardDesignationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax
    {
        internal DiscardDesignationSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken UnderscoreToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax Update(Microsoft.CodeAnalysis.SyntaxToken underscoreToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax WithUnderscoreToken(Microsoft.CodeAnalysis.SyntaxToken underscoreToken) { throw null; }
    }
    public sealed partial class DocumentationCommentTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax
    {
        internal DocumentationCommentTriviaSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> Content { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken EndOfComment { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax AddContent(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content, Microsoft.CodeAnalysis.SyntaxToken endOfComment) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax WithContent(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax WithEndOfComment(Microsoft.CodeAnalysis.SyntaxToken endOfComment) { throw null; }
    }
    public sealed partial class DoStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal DoStatementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken DoKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WhileKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken doKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.SyntaxToken whileKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax WithDoKeyword(Microsoft.CodeAnalysis.SyntaxToken doKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax WithWhileKeyword(Microsoft.CodeAnalysis.SyntaxToken whileKeyword) { throw null; }
    }
    public sealed partial class ElementAccessExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ElementAccessExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax ArgumentList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
    }
    public sealed partial class ElementBindingExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ElementBindingExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax ArgumentList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
    }
    public sealed partial class ElifDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalDirectiveTriviaSyntax
    {
        internal ElifDirectiveTriviaSyntax() { }
        public override bool BranchTaken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public override bool ConditionValue { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ElifKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken elifKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax WithBranchTaken(bool branchTaken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax WithConditionValue(bool conditionValue) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax WithElifKeyword(Microsoft.CodeAnalysis.SyntaxToken elifKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public sealed partial class ElseClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ElseClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ElseKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken elseKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax WithElseKeyword(Microsoft.CodeAnalysis.SyntaxToken elseKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
    }
    public sealed partial class ElseDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BranchingDirectiveTriviaSyntax
    {
        internal ElseDirectiveTriviaSyntax() { }
        public override bool BranchTaken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ElseKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken elseKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax WithBranchTaken(bool branchTaken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax WithElseKeyword(Microsoft.CodeAnalysis.SyntaxToken elseKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public sealed partial class EmptyStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal EmptyStatementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class EndIfDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal EndIfDirectiveTriviaSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken EndIfKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken endIfKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax WithEndIfKeyword(Microsoft.CodeAnalysis.SyntaxToken endIfKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public sealed partial class EndRegionDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal EndRegionDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken EndRegionKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken endRegionKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax WithEndRegionKeyword(Microsoft.CodeAnalysis.SyntaxToken endRegionKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public sealed partial class EnumDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax
    {
        internal EnumDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax BaseList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken EnumKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax> Members { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax AddBaseListTypes(params Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken enumKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithEnumKeyword(Microsoft.CodeAnalysis.SyntaxToken enumKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithMembers(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax> members) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class EnumMemberDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal EnumMemberDeclarationSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax EqualsValue { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax equalsValue) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax WithEqualsValue(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax equalsValue) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
    }
    public sealed partial class EqualsValueClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal EqualsValueClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken EqualsToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Value { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax WithValue(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
    }
    public sealed partial class ErrorDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal ErrorDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ErrorKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken errorKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax WithErrorKeyword(Microsoft.CodeAnalysis.SyntaxToken errorKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public sealed partial class EventDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax
    {
        internal EventDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax AccessorList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken EventKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax AddAccessorListAccessors(params Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken eventKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax WithAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax WithEventKeyword(Microsoft.CodeAnalysis.SyntaxToken eventKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax WithExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class EventFieldDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax
    {
        internal EventFieldDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax Declaration { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken EventKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax AddDeclarationVariables(params Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken eventKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax WithDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax WithEventKeyword(Microsoft.CodeAnalysis.SyntaxToken eventKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class ExplicitInterfaceSpecifierSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ExplicitInterfaceSpecifierSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken DotToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken dotToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax WithDotToken(Microsoft.CodeAnalysis.SyntaxToken dotToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
    }
    public sealed partial class ExpressionStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal ExpressionStatementSyntax() { }
        public bool AllowsAnyExpression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public abstract partial class ExpressionSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ExpressionSyntax() { }
    }
    public sealed partial class ExternAliasDirectiveSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ExternAliasDirectiveSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken AliasKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ExternKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax Update(Microsoft.CodeAnalysis.SyntaxToken externKeyword, Microsoft.CodeAnalysis.SyntaxToken aliasKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax WithAliasKeyword(Microsoft.CodeAnalysis.SyntaxToken aliasKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax WithExternKeyword(Microsoft.CodeAnalysis.SyntaxToken externKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class FieldDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax
    {
        internal FieldDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax Declaration { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax AddDeclarationVariables(params Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax WithDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class FinallyClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal FinallyClauseSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken FinallyKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken finallyKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax WithFinallyKeyword(Microsoft.CodeAnalysis.SyntaxToken finallyKeyword) { throw null; }
    }
    public sealed partial class FixedStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal FixedStatementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax Declaration { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken FixedKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax AddDeclarationVariables(params Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken fixedKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax WithDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax WithFixedKeyword(Microsoft.CodeAnalysis.SyntaxToken fixedKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
    }
    public sealed partial class ForEachStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax
    {
        internal ForEachStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken ForEachKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken InKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithForEachKeyword(Microsoft.CodeAnalysis.SyntaxToken forEachKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithInKeyword(Microsoft.CodeAnalysis.SyntaxToken inKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class ForEachVariableStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax
    {
        internal ForEachVariableStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken ForEachKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken InKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Variable { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax variable, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithForEachKeyword(Microsoft.CodeAnalysis.SyntaxToken forEachKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithInKeyword(Microsoft.CodeAnalysis.SyntaxToken inKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithVariable(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax variable) { throw null; }
    }
    public sealed partial class ForStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal ForStatementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax Declaration { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken FirstSemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ForKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> Incrementors { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> Initializers { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SecondSemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax AddIncrementors(params Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax AddInitializers(params Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken forKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> initializers, Microsoft.CodeAnalysis.SyntaxToken firstSemicolonToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> incrementors, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithFirstSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken firstSemicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithForKeyword(Microsoft.CodeAnalysis.SyntaxToken forKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithIncrementors(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> incrementors) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithInitializers(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> initializers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithSecondSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken secondSemicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
    }
    public sealed partial class FromClauseSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax
    {
        internal FromClauseSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken FromKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken InKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken fromKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax WithFromKeyword(Microsoft.CodeAnalysis.SyntaxToken fromKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax WithInKeyword(Microsoft.CodeAnalysis.SyntaxToken inKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class GenericNameSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax
    {
        internal GenericNameSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public bool IsUnboundGenericName { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax TypeArgumentList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax AddTypeArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax Update(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax typeArgumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax WithTypeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax typeArgumentList) { throw null; }
    }
    public sealed partial class GlobalStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal GlobalStatementSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
    }
    public sealed partial class GotoStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal GotoStatementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CaseOrDefaultKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken GotoKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken gotoKeyword, Microsoft.CodeAnalysis.SyntaxToken caseOrDefaultKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax WithCaseOrDefaultKeyword(Microsoft.CodeAnalysis.SyntaxToken caseOrDefaultKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax WithGotoKeyword(Microsoft.CodeAnalysis.SyntaxToken gotoKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class GroupClauseSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax
    {
        internal GroupClauseSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax ByExpression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ByKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax GroupExpression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken GroupKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken groupKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax groupExpression, Microsoft.CodeAnalysis.SyntaxToken byKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax byExpression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax WithByExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax byExpression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax WithByKeyword(Microsoft.CodeAnalysis.SyntaxToken byKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax WithGroupExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax groupExpression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax WithGroupKeyword(Microsoft.CodeAnalysis.SyntaxToken groupKeyword) { throw null; }
    }
    public sealed partial class IdentifierNameSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax
    {
        internal IdentifierNameSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax Update(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
    }
    public sealed partial class IfDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalDirectiveTriviaSyntax
    {
        internal IfDirectiveTriviaSyntax() { }
        public override bool BranchTaken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public override bool ConditionValue { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken IfKeyword { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken ifKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax WithBranchTaken(bool branchTaken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax WithConditionValue(bool conditionValue) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax WithIfKeyword(Microsoft.CodeAnalysis.SyntaxToken ifKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public sealed partial class IfStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal IfStatementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax Else { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken IfKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken ifKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax @else) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax WithElse(Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax @else) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax WithIfKeyword(Microsoft.CodeAnalysis.SyntaxToken ifKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
    }
    public sealed partial class ImplicitArrayCreationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ImplicitArrayCreationExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList Commas { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax Initializer { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken NewKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax AddCommas(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax AddInitializerExpressions(params Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SyntaxTokenList commas, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax WithCloseBracketToken(Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax WithCommas(Microsoft.CodeAnalysis.SyntaxTokenList commas) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken newKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax WithOpenBracketToken(Microsoft.CodeAnalysis.SyntaxToken openBracketToken) { throw null; }
    }
    public sealed partial class ImplicitElementAccessSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ImplicitElementAccessSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax ArgumentList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
    }
    public sealed partial class IncompleteMemberSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal IncompleteMemberSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class IndexerDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax
    {
        internal IndexerDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax AccessorList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax ExpressionBody { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax ParameterList { get { throw null; } }
        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
        [System.ObsoleteAttribute("This member is obsolete.", true)]
        public Microsoft.CodeAnalysis.SyntaxToken Semicolon { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ThisKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax AddAccessorListAccessors(params Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken thisKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList) { throw null; }
        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
        [System.ObsoleteAttribute("This member is obsolete.", true)]
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithSemicolon(Microsoft.CodeAnalysis.SyntaxToken semicolon) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithThisKeyword(Microsoft.CodeAnalysis.SyntaxToken thisKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class IndexerMemberCrefSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax
    {
        internal IndexerMemberCrefSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax Parameters { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ThisKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax AddParametersParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax Update(Microsoft.CodeAnalysis.SyntaxToken thisKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax parameters) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax WithParameters(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax parameters) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax WithThisKeyword(Microsoft.CodeAnalysis.SyntaxToken thisKeyword) { throw null; }
    }
    public sealed partial class InitializerExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal InitializerExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> Expressions { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax AddExpressions(params Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> expressions, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax WithExpressions(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> expressions) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
    }
    public abstract partial class InstanceExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal InstanceExpressionSyntax() { }
    }
    public sealed partial class InterfaceDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax
    {
        internal InterfaceDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax BaseList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> Members { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax TypeParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax AddBaseListTypes(params Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax AddConstraintClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax AddTypeParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithConstraintClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithMembers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList) { throw null; }
    }
    public abstract partial class InterpolatedStringContentSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal InterpolatedStringContentSyntax() { }
    }
    public sealed partial class InterpolatedStringExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal InterpolatedStringExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax> Contents { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken StringEndToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken StringStartToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax AddContents(params Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken stringStartToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax> contents, Microsoft.CodeAnalysis.SyntaxToken stringEndToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax WithContents(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax> contents) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax WithStringEndToken(Microsoft.CodeAnalysis.SyntaxToken stringEndToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax WithStringStartToken(Microsoft.CodeAnalysis.SyntaxToken stringStartToken) { throw null; }
    }
    public sealed partial class InterpolatedStringTextSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax
    {
        internal InterpolatedStringTextSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken TextToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax Update(Microsoft.CodeAnalysis.SyntaxToken textToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax WithTextToken(Microsoft.CodeAnalysis.SyntaxToken textToken) { throw null; }
    }
    public sealed partial class InterpolationAlignmentClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal InterpolationAlignmentClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CommaToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Value { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken commaToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax WithCommaToken(Microsoft.CodeAnalysis.SyntaxToken commaToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax WithValue(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
    }
    public sealed partial class InterpolationFormatClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal InterpolationFormatClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken FormatStringToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SyntaxToken formatStringToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax WithFormatStringToken(Microsoft.CodeAnalysis.SyntaxToken formatStringToken) { throw null; }
    }
    public sealed partial class InterpolationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax
    {
        internal InterpolationSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax AlignmentClause { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax FormatClause { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax alignmentClause, Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax formatClause, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax WithAlignmentClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax alignmentClause) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax WithFormatClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax formatClause) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
    }
    public sealed partial class InvocationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal InvocationExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax ArgumentList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
    }
    public sealed partial class IsPatternExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal IsPatternExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken IsKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax Pattern { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken isKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax WithIsKeyword(Microsoft.CodeAnalysis.SyntaxToken isKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax WithPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
    }
    public sealed partial class JoinClauseSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax
    {
        internal JoinClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken EqualsKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax InExpression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken InKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax Into { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken JoinKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax LeftExpression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OnKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax RightExpression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken joinKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax inExpression, Microsoft.CodeAnalysis.SyntaxToken onKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax leftExpression, Microsoft.CodeAnalysis.SyntaxToken equalsKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax rightExpression, Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax into) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithEqualsKeyword(Microsoft.CodeAnalysis.SyntaxToken equalsKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithInExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax inExpression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithInKeyword(Microsoft.CodeAnalysis.SyntaxToken inKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithInto(Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax into) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithJoinKeyword(Microsoft.CodeAnalysis.SyntaxToken joinKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithLeftExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax leftExpression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithOnKeyword(Microsoft.CodeAnalysis.SyntaxToken onKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithRightExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax rightExpression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class JoinIntoClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal JoinIntoClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken IntoKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken intoKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax WithIntoKeyword(Microsoft.CodeAnalysis.SyntaxToken intoKeyword) { throw null; }
    }
    public sealed partial class LabeledStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal LabeledStatementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
    }
    public abstract partial class LambdaExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax
    {
        internal LambdaExpressionSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxToken ArrowToken { get; }
    }
    public sealed partial class LetClauseSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax
    {
        internal LetClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken EqualsToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LetKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken letKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax WithLetKeyword(Microsoft.CodeAnalysis.SyntaxToken letKeyword) { throw null; }
    }
    public sealed partial class LineDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal LineDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken File { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Line { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LineKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken lineKeyword, Microsoft.CodeAnalysis.SyntaxToken line, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax WithFile(Microsoft.CodeAnalysis.SyntaxToken file) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax WithLine(Microsoft.CodeAnalysis.SyntaxToken line) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax WithLineKeyword(Microsoft.CodeAnalysis.SyntaxToken lineKeyword) { throw null; }
    }
    public sealed partial class LiteralExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal LiteralExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Token { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax WithToken(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
    }
    public sealed partial class LoadDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal LoadDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken File { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LoadKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken loadKeyword, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax WithFile(Microsoft.CodeAnalysis.SyntaxToken file) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax WithLoadKeyword(Microsoft.CodeAnalysis.SyntaxToken loadKeyword) { throw null; }
    }
    public sealed partial class LocalDeclarationStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal LocalDeclarationStatementSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax Declaration { get { throw null; } }
        public bool IsConst { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax AddDeclarationVariables(params Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax WithDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class LocalFunctionStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal LocalFunctionStatementSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Body { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax ExpressionBody { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ReturnType { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax TypeParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax AddBodyStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax AddConstraintClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax AddTypeParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithConstraintClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithReturnType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList) { throw null; }
    }
    public sealed partial class LockStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal LockStatementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LockKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken lockKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax WithLockKeyword(Microsoft.CodeAnalysis.SyntaxToken lockKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
    }
    public sealed partial class MakeRefExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal MakeRefExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class MemberAccessExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal MemberAccessExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax Name { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
    }
    public sealed partial class MemberBindingExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal MemberBindingExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax Name { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
    }
    public abstract partial class MemberCrefSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax
    {
        internal MemberCrefSyntax() { }
    }
    public abstract partial class MemberDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal MemberDeclarationSyntax() { }
    }
    public sealed partial class MethodDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax
    {
        internal MethodDeclarationSyntax() { }
        public int Arity { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Body { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax ExpressionBody { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ReturnType { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax TypeParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax AddBodyStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax AddConstraintClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax AddTypeParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithConstraintClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithReturnType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList) { throw null; }
    }
    public sealed partial class NameColonSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal NameColonSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name) { throw null; }
    }
    public sealed partial class NameEqualsSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal NameEqualsSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken EqualsToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name) { throw null; }
    }
    public sealed partial class NameMemberCrefSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax
    {
        internal NameMemberCrefSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Name { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax Parameters { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax AddParametersParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax name, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax parameters) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax WithParameters(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax parameters) { throw null; }
    }
    public sealed partial class NamespaceDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal NamespaceDeclarationSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> Externs { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> Members { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax Name { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken NamespaceKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> Usings { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax AddExterns(params Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax AddUsings(params Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxToken namespaceKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithExterns(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithMembers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithNamespaceKeyword(Microsoft.CodeAnalysis.SyntaxToken namespaceKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithUsings(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings) { throw null; }
    }
    public abstract partial class NameSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal NameSyntax() { }
        public int Arity { get { throw null; } }
    }
    public sealed partial class NullableTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal NullableTypeSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ElementType { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken QuestionToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType, Microsoft.CodeAnalysis.SyntaxToken questionToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax WithElementType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax WithQuestionToken(Microsoft.CodeAnalysis.SyntaxToken questionToken) { throw null; }
    }
    public sealed partial class ObjectCreationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ObjectCreationExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax ArgumentList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax Initializer { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken NewKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken newKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class OmittedArraySizeExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal OmittedArraySizeExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken OmittedArraySizeExpressionToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken omittedArraySizeExpressionToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax WithOmittedArraySizeExpressionToken(Microsoft.CodeAnalysis.SyntaxToken omittedArraySizeExpressionToken) { throw null; }
    }
    public sealed partial class OmittedTypeArgumentSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal OmittedTypeArgumentSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken OmittedTypeArgumentToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax Update(Microsoft.CodeAnalysis.SyntaxToken omittedTypeArgumentToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax WithOmittedTypeArgumentToken(Microsoft.CodeAnalysis.SyntaxToken omittedTypeArgumentToken) { throw null; }
    }
    public sealed partial class OperatorDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax
    {
        internal OperatorDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Body { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax ExpressionBody { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ReturnType { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax AddBodyStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithOperatorKeyword(Microsoft.CodeAnalysis.SyntaxToken operatorKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithReturnType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class OperatorMemberCrefSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax
    {
        internal OperatorMemberCrefSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax Parameters { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax AddParametersParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax Update(Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax parameters) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax WithOperatorKeyword(Microsoft.CodeAnalysis.SyntaxToken operatorKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax WithParameters(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax parameters) { throw null; }
    }
    public sealed partial class OrderByClauseSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax
    {
        internal OrderByClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken OrderByKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax> Orderings { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax AddOrderings(params Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken orderByKeyword, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax> orderings) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax WithOrderByKeyword(Microsoft.CodeAnalysis.SyntaxToken orderByKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax WithOrderings(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax> orderings) { throw null; }
    }
    public sealed partial class OrderingSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal OrderingSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken AscendingOrDescendingKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken ascendingOrDescendingKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax WithAscendingOrDescendingKeyword(Microsoft.CodeAnalysis.SyntaxToken ascendingOrDescendingKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
    }
    public sealed partial class ParameterListSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax
    {
        internal ParameterListSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> Parameters { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax AddParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax WithParameters(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters) { throw null; }
    }
    public sealed partial class ParameterSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ParameterSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax Default { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax @default) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax WithDefault(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax @default) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class ParenthesizedExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ParenthesizedExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class ParenthesizedLambdaExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax
    {
        internal ParenthesizedLambdaExpressionSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken ArrowToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken AsyncKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode Body { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax WithArrowToken(Microsoft.CodeAnalysis.SyntaxToken arrowToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax WithAsyncKeyword(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax WithBody(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
    }
    public sealed partial class ParenthesizedVariableDesignationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax
    {
        internal ParenthesizedVariableDesignationSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax> Variables { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax AddVariables(params Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax> variables, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax WithVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax> variables) { throw null; }
    }
    public abstract partial class PatternSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal PatternSyntax() { }
    }
    public sealed partial class PointerTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal PointerTypeSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken AsteriskToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ElementType { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType, Microsoft.CodeAnalysis.SyntaxToken asteriskToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax WithAsteriskToken(Microsoft.CodeAnalysis.SyntaxToken asteriskToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax WithElementType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType) { throw null; }
    }
    public sealed partial class PostfixUnaryExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal PostfixUnaryExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Operand { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand, Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax WithOperand(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
    }
    public sealed partial class PragmaChecksumDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal PragmaChecksumDirectiveTriviaSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Bytes { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ChecksumKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken File { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Guid { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken PragmaKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken pragmaKeyword, Microsoft.CodeAnalysis.SyntaxToken checksumKeyword, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken guid, Microsoft.CodeAnalysis.SyntaxToken bytes, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithBytes(Microsoft.CodeAnalysis.SyntaxToken bytes) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithChecksumKeyword(Microsoft.CodeAnalysis.SyntaxToken checksumKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithFile(Microsoft.CodeAnalysis.SyntaxToken file) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithGuid(Microsoft.CodeAnalysis.SyntaxToken guid) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithPragmaKeyword(Microsoft.CodeAnalysis.SyntaxToken pragmaKeyword) { throw null; }
    }
    public sealed partial class PragmaWarningDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal PragmaWarningDirectiveTriviaSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken DisableOrRestoreKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> ErrorCodes { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken PragmaKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WarningKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax AddErrorCodes(params Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken pragmaKeyword, Microsoft.CodeAnalysis.SyntaxToken warningKeyword, Microsoft.CodeAnalysis.SyntaxToken disableOrRestoreKeyword, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> errorCodes, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax WithDisableOrRestoreKeyword(Microsoft.CodeAnalysis.SyntaxToken disableOrRestoreKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax WithErrorCodes(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> errorCodes) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax WithPragmaKeyword(Microsoft.CodeAnalysis.SyntaxToken pragmaKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax WithWarningKeyword(Microsoft.CodeAnalysis.SyntaxToken warningKeyword) { throw null; }
    }
    public sealed partial class PredefinedTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal PredefinedTypeSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
    }
    public sealed partial class PrefixUnaryExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal PrefixUnaryExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Operand { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax WithOperand(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
    }
    public sealed partial class PropertyDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax
    {
        internal PropertyDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax AccessorList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax ExpressionBody { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax Initializer { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
        [System.ObsoleteAttribute("This member is obsolete.", true)]
        public Microsoft.CodeAnalysis.SyntaxToken Semicolon { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax AddAccessorListAccessors(params Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
        [System.ObsoleteAttribute("This member is obsolete.", true)]
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithSemicolon(Microsoft.CodeAnalysis.SyntaxToken semicolon) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class QualifiedCrefSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax
    {
        internal QualifiedCrefSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Container { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken DotToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax Member { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax container, Microsoft.CodeAnalysis.SyntaxToken dotToken, Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax member) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax WithContainer(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax container) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax WithDotToken(Microsoft.CodeAnalysis.SyntaxToken dotToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax WithMember(Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax member) { throw null; }
    }
    public sealed partial class QualifiedNameSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax
    {
        internal QualifiedNameSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken DotToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax Left { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax Right { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax left, Microsoft.CodeAnalysis.SyntaxToken dotToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax right) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax WithDotToken(Microsoft.CodeAnalysis.SyntaxToken dotToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax WithLeft(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax left) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax WithRight(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax right) { throw null; }
    }
    public sealed partial class QueryBodySyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal QueryBodySyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax> Clauses { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax Continuation { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax SelectOrGroup { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax AddClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax> clauses, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax selectOrGroup, Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax continuation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax WithClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax> clauses) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax WithContinuation(Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax continuation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax WithSelectOrGroup(Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax selectOrGroup) { throw null; }
    }
    public abstract partial class QueryClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal QueryClauseSyntax() { }
    }
    public sealed partial class QueryContinuationSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal QueryContinuationSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax Body { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken IntoKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax AddBodyClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax Update(Microsoft.CodeAnalysis.SyntaxToken intoKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax WithIntoKeyword(Microsoft.CodeAnalysis.SyntaxToken intoKeyword) { throw null; }
    }
    public sealed partial class QueryExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal QueryExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax Body { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax FromClause { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax AddBodyClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax fromClause, Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax WithFromClause(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax fromClause) { throw null; }
    }
    public sealed partial class ReferenceDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal ReferenceDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken File { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ReferenceKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken referenceKeyword, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax WithFile(Microsoft.CodeAnalysis.SyntaxToken file) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax WithReferenceKeyword(Microsoft.CodeAnalysis.SyntaxToken referenceKeyword) { throw null; }
    }
    public sealed partial class RefExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal RefExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken RefKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken refKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax WithRefKeyword(Microsoft.CodeAnalysis.SyntaxToken refKeyword) { throw null; }
    }
    public sealed partial class RefTypeExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal RefTypeExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class RefTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal RefTypeSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken RefKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax Update(Microsoft.CodeAnalysis.SyntaxToken refKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax WithRefKeyword(Microsoft.CodeAnalysis.SyntaxToken refKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class RefValueExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal RefValueExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Comma { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken comma, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax WithComma(Microsoft.CodeAnalysis.SyntaxToken comma) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class RegionDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal RegionDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken RegionKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken regionKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax WithRegionKeyword(Microsoft.CodeAnalysis.SyntaxToken regionKeyword) { throw null; }
    }
    public sealed partial class ReturnStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal ReturnStatementSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ReturnKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken returnKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax WithReturnKeyword(Microsoft.CodeAnalysis.SyntaxToken returnKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class SelectClauseSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax
    {
        internal SelectClauseSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SelectKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken selectKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax WithSelectKeyword(Microsoft.CodeAnalysis.SyntaxToken selectKeyword) { throw null; }
    }
    public abstract partial class SelectOrGroupClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal SelectOrGroupClauseSyntax() { }
    }
    public sealed partial class ShebangDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal ShebangDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ExclamationToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken exclamationToken, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax WithExclamationToken(Microsoft.CodeAnalysis.SyntaxToken exclamationToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public sealed partial class SimpleBaseTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax
    {
        internal SimpleBaseTypeSyntax() { }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class SimpleLambdaExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax
    {
        internal SimpleLambdaExpressionSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken ArrowToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken AsyncKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode Body { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax Parameter { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax AddParameterAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax AddParameterModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax WithArrowToken(Microsoft.CodeAnalysis.SyntaxToken arrowToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax WithAsyncKeyword(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax WithBody(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax WithParameter(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter) { throw null; }
    }
    public abstract partial class SimpleNameSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax
    {
        internal SimpleNameSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxToken Identifier { get; }
    }
    public sealed partial class SingleVariableDesignationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax
    {
        internal SingleVariableDesignationSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax Update(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
    }
    public sealed partial class SizeOfExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal SizeOfExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class SkippedTokensTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax, Microsoft.CodeAnalysis.ISkippedTokensTriviaSyntax
    {
        internal SkippedTokensTriviaSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxTokenList Tokens { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax AddTokens(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxTokenList tokens) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax WithTokens(Microsoft.CodeAnalysis.SyntaxTokenList tokens) { throw null; }
    }
    public sealed partial class StackAllocArrayCreationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal StackAllocArrayCreationExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken StackAllocKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken stackAllocKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax WithStackAllocKeyword(Microsoft.CodeAnalysis.SyntaxToken stackAllocKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public abstract partial class StatementSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal StatementSyntax() { }
    }
    public sealed partial class StructDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax
    {
        internal StructDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax BaseList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> Members { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax TypeParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax AddBaseListTypes(params Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax AddConstraintClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax AddTypeParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithConstraintClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithMembers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList) { throw null; }
    }
    public abstract partial class StructuredTriviaSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.IStructuredTriviaSyntax
    {
        internal StructuredTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxTrivia ParentTrivia { get { throw null; } }
    }
    public abstract partial class SwitchLabelSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal SwitchLabelSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxToken ColonToken { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken Keyword { get; }
    }
    public sealed partial class SwitchSectionSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal SwitchSectionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax> Labels { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> Statements { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax AddLabels(params Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax AddStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax> labels, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax WithLabels(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax> labels) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax WithStatements(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements) { throw null; }
    }
    public sealed partial class SwitchStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal SwitchStatementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax> Sections { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SwitchKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax AddSections(params Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken switchKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax> sections, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax WithSections(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax> sections) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax WithSwitchKeyword(Microsoft.CodeAnalysis.SyntaxToken switchKeyword) { throw null; }
    }
    public sealed partial class ThisExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.InstanceExpressionSyntax
    {
        internal ThisExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Token { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax WithToken(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
    }
    public sealed partial class ThrowExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ThrowExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ThrowKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken throwKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax WithThrowKeyword(Microsoft.CodeAnalysis.SyntaxToken throwKeyword) { throw null; }
    }
    public sealed partial class ThrowStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal ThrowStatementSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ThrowKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken throwKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax WithThrowKeyword(Microsoft.CodeAnalysis.SyntaxToken throwKeyword) { throw null; }
    }
    public sealed partial class TryStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal TryStatementSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax> Catches { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax Finally { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken TryKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax AddCatches(params Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken tryKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax> catches, Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax @finally) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax WithCatches(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax> catches) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax WithFinally(Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax @finally) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax WithTryKeyword(Microsoft.CodeAnalysis.SyntaxToken tryKeyword) { throw null; }
    }
    public sealed partial class TupleElementSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal TupleElementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class TupleExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal TupleExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> Arguments { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax AddArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax WithArguments(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class TupleTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal TupleTypeSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax> Elements { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax AddElements(params Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax> elements, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax WithElements(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax> elements) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class TypeArgumentListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal TypeArgumentListSyntax() { }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax> Arguments { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken GreaterThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LessThanToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax AddArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax WithArguments(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax> arguments) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax WithGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax WithLessThanToken(Microsoft.CodeAnalysis.SyntaxToken lessThanToken) { throw null; }
    }
    public sealed partial class TypeConstraintSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax
    {
        internal TypeConstraintSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class TypeCrefSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax
    {
        internal TypeCrefSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public abstract partial class TypeDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax
    {
        internal TypeDeclarationSyntax() { }
        public int Arity { get { throw null; } }
        public abstract Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken Keyword { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> Members { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax TypeParameterList { get; }
    }
    public sealed partial class TypeOfExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal TypeOfExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class TypeParameterConstraintClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal TypeParameterConstraintClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax> Constraints { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax Name { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WhereKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax AddConstraints(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken whereKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax> constraints) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax WithConstraints(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax> constraints) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax WithWhereKeyword(Microsoft.CodeAnalysis.SyntaxToken whereKeyword) { throw null; }
    }
    public abstract partial class TypeParameterConstraintSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal TypeParameterConstraintSyntax() { }
    }
    public sealed partial class TypeParameterListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal TypeParameterListSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken GreaterThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LessThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax> Parameters { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax AddParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax WithGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax WithLessThanToken(Microsoft.CodeAnalysis.SyntaxToken lessThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax WithParameters(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax> parameters) { throw null; }
    }
    public sealed partial class TypeParameterSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal TypeParameterSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken VarianceKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken varianceKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax WithVarianceKeyword(Microsoft.CodeAnalysis.SyntaxToken varianceKeyword) { throw null; }
    }
    public abstract partial class TypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal TypeSyntax() { }
        public bool IsVar { get { throw null; } }
    }
    public sealed partial class UndefDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal UndefDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Name { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken UndefKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken undefKeyword, Microsoft.CodeAnalysis.SyntaxToken name, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax WithName(Microsoft.CodeAnalysis.SyntaxToken name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax WithUndefKeyword(Microsoft.CodeAnalysis.SyntaxToken undefKeyword) { throw null; }
    }
    public sealed partial class UnsafeStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal UnsafeStatementSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken UnsafeKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken unsafeKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax WithUnsafeKeyword(Microsoft.CodeAnalysis.SyntaxToken unsafeKeyword) { throw null; }
    }
    public sealed partial class UsingDirectiveSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal UsingDirectiveSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax Alias { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax Name { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken StaticKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken UsingKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax Update(Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxToken staticKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax alias, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax WithAlias(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax alias) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax WithStaticKeyword(Microsoft.CodeAnalysis.SyntaxToken staticKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax WithUsingKeyword(Microsoft.CodeAnalysis.SyntaxToken usingKeyword) { throw null; }
    }
    public sealed partial class UsingStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal UsingStatementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax Declaration { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken UsingKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax WithDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax WithUsingKeyword(Microsoft.CodeAnalysis.SyntaxToken usingKeyword) { throw null; }
    }
    public sealed partial class VariableDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal VariableDeclarationSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax> Variables { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax AddVariables(params Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax> variables) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax WithVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax> variables) { throw null; }
    }
    public sealed partial class VariableDeclaratorSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal VariableDeclaratorSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax ArgumentList { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax Initializer { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax Update(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer) { throw null; }
    }
    public abstract partial class VariableDesignationSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal VariableDesignationSyntax() { }
    }
    public sealed partial class WarningDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal WarningDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WarningKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken warningKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax WithWarningKeyword(Microsoft.CodeAnalysis.SyntaxToken warningKeyword) { throw null; }
    }
    public sealed partial class WhenClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal WhenClauseSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WhenKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken whenKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax WithWhenKeyword(Microsoft.CodeAnalysis.SyntaxToken whenKeyword) { throw null; }
    }
    public sealed partial class WhereClauseSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax
    {
        internal WhereClauseSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WhereKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken whereKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax WithWhereKeyword(Microsoft.CodeAnalysis.SyntaxToken whereKeyword) { throw null; }
    }
    public sealed partial class WhileStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal WhileStatementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WhileKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken whileKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WithWhileKeyword(Microsoft.CodeAnalysis.SyntaxToken whileKeyword) { throw null; }
    }
    public abstract partial class XmlAttributeSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal XmlAttributeSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxToken EndQuoteToken { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken EqualsToken { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken StartQuoteToken { get; }
    }
    public sealed partial class XmlCDataSectionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax
    {
        internal XmlCDataSectionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken EndCDataToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken StartCDataToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList TextTokens { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax AddTextTokens(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken startCDataToken, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken endCDataToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax WithEndCDataToken(Microsoft.CodeAnalysis.SyntaxToken endCDataToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax WithStartCDataToken(Microsoft.CodeAnalysis.SyntaxToken startCDataToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax WithTextTokens(Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
    }
    public sealed partial class XmlCommentSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax
    {
        internal XmlCommentSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken LessThanExclamationMinusMinusToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken MinusMinusGreaterThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList TextTokens { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax AddTextTokens(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax Update(Microsoft.CodeAnalysis.SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken minusMinusGreaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax WithLessThanExclamationMinusMinusToken(Microsoft.CodeAnalysis.SyntaxToken lessThanExclamationMinusMinusToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax WithMinusMinusGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken minusMinusGreaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax WithTextTokens(Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
    }
    public sealed partial class XmlCrefAttributeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax
    {
        internal XmlCrefAttributeSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax Cref { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndQuoteToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EqualsToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken StartQuoteToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax WithCref(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax WithEndQuoteToken(Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax WithStartQuoteToken(Microsoft.CodeAnalysis.SyntaxToken startQuoteToken) { throw null; }
    }
    public sealed partial class XmlElementEndTagSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal XmlElementEndTagSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken GreaterThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LessThanSlashToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax Update(Microsoft.CodeAnalysis.SyntaxToken lessThanSlashToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax WithGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax WithLessThanSlashToken(Microsoft.CodeAnalysis.SyntaxToken lessThanSlashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
    }
    public sealed partial class XmlElementStartTagSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal XmlElementStartTagSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> Attributes { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken GreaterThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LessThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax AddAttributes(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax Update(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax WithAttributes(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax WithGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax WithLessThanToken(Microsoft.CodeAnalysis.SyntaxToken lessThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
    }
    public sealed partial class XmlElementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax
    {
        internal XmlElementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> Content { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax EndTag { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax StartTag { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax AddContent(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax AddStartTagAttributes(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content, Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax endTag) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax WithContent(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax WithEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax endTag) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax WithStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax startTag) { throw null; }
    }
    public sealed partial class XmlEmptyElementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax
    {
        internal XmlEmptyElementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> Attributes { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LessThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SlashGreaterThanToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax AddAttributes(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes, Microsoft.CodeAnalysis.SyntaxToken slashGreaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax WithAttributes(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax WithLessThanToken(Microsoft.CodeAnalysis.SyntaxToken lessThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax WithSlashGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken slashGreaterThanToken) { throw null; }
    }
    public enum XmlNameAttributeElementKind : byte
    {
        Parameter = (byte)0,
        ParameterReference = (byte)1,
        TypeParameter = (byte)2,
        TypeParameterReference = (byte)3,
    }
    public sealed partial class XmlNameAttributeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax
    {
        internal XmlNameAttributeSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndQuoteToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EqualsToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken StartQuoteToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax identifier, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax WithEndQuoteToken(Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax WithIdentifier(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax WithStartQuoteToken(Microsoft.CodeAnalysis.SyntaxToken startQuoteToken) { throw null; }
    }
    public sealed partial class XmlNameSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal XmlNameSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken LocalName { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax Prefix { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax prefix, Microsoft.CodeAnalysis.SyntaxToken localName) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax WithLocalName(Microsoft.CodeAnalysis.SyntaxToken localName) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax WithPrefix(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax prefix) { throw null; }
    }
    public abstract partial class XmlNodeSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal XmlNodeSyntax() { }
    }
    public sealed partial class XmlPrefixSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal XmlPrefixSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Prefix { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax Update(Microsoft.CodeAnalysis.SyntaxToken prefix, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax WithPrefix(Microsoft.CodeAnalysis.SyntaxToken prefix) { throw null; }
    }
    public sealed partial class XmlProcessingInstructionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax
    {
        internal XmlProcessingInstructionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken EndProcessingInstructionToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken StartProcessingInstructionToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList TextTokens { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax AddTextTokens(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken startProcessingInstructionToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken endProcessingInstructionToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax WithEndProcessingInstructionToken(Microsoft.CodeAnalysis.SyntaxToken endProcessingInstructionToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax WithStartProcessingInstructionToken(Microsoft.CodeAnalysis.SyntaxToken startProcessingInstructionToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax WithTextTokens(Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
    }
    public sealed partial class XmlTextAttributeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax
    {
        internal XmlTextAttributeSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndQuoteToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EqualsToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken StartQuoteToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList TextTokens { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax AddTextTokens(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax WithEndQuoteToken(Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax WithStartQuoteToken(Microsoft.CodeAnalysis.SyntaxToken startQuoteToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax WithTextTokens(Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
    }
    public sealed partial class XmlTextSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax
    {
        internal XmlTextSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxTokenList TextTokens { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax AddTextTokens(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax Update(Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax WithTextTokens(Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
    }
    public sealed partial class YieldStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal YieldStatementSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ReturnOrBreakKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken YieldKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken yieldKeyword, Microsoft.CodeAnalysis.SyntaxToken returnOrBreakKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax WithReturnOrBreakKeyword(Microsoft.CodeAnalysis.SyntaxToken returnOrBreakKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax WithYieldKeyword(Microsoft.CodeAnalysis.SyntaxToken yieldKeyword) { throw null; }
    }
}
