[assembly:System.Diagnostics.DebuggableAttribute((System.Diagnostics.DebuggableAttribute.DebuggingModes)(2))]
[assembly:System.Reflection.AssemblyCompanyAttribute("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyCopyrightAttribute("Â© Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyFileVersionAttribute("1.3.0.60613")]
[assembly:System.Reflection.AssemblyInformationalVersionAttribute("1.3.0.60613")]
[assembly:System.Reflection.AssemblyMetadataAttribute("Serviceable", "True")]
[assembly:System.Runtime.CompilerServices.CompilationRelaxationsAttribute(8)]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("csc, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("csi, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("DynamicProxyGenAssembly2, PublicKey=0024000004800000940000000602000000240000525341310004000001000100c547cac37abd99c8db225ef2f6c8a3602f3b3606cc9891605d02baa56104f4cfc0734aa39b93bf7852f7d9266654753cc297e7d2edfe0bac1cdcf9f717241550e0a7b191195b7667bb4f64bcb8e2121380fd1d9d46ad2d92d2d15605093924cceaf74c4861eff62abf69b9291ed0a340e113be11e6a7d3113e92484cf7045cc7")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.Build.Tasks.CodeAnalysis, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.CompilerServer, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.CSharp, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.CSharp.ExpressionEvaluator.ExpressionCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.CSharp.Scripting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.CSharp.Scripting.Desktop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.CSharp.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.ExpressionEvaluator.ExpressionCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.Scripting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.Scripting.Desktop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.VisualBasic, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.VisualBasic.ExpressionEvaluator.ExpressionCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.VisualBasic.Scripting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.VisualBasic.Scripting.Desktop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Microsoft.CodeAnalysis.VisualBasic.Scripting.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CompilerServer.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.CommandLine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.Emit.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.EnC.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.Semantic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.Symbol.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.Syntax.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.Test.Utilities.Desktop, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.CSharp.WinRT.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.VisualBasic.CommandLine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.VisualBasic.Emit.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.VisualBasic.EnC.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.VisualBasic.Semantic.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.VisualBasic.Symbol.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.VisualBasic.Syntax.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Compilers.VisualBasic.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.DebuggerVisualizers, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Diagnostics.Analyzers.FxCop.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Diagnostics.Analyzers.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Diagnostics.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.ExpressionEvaluator.CSharp.ExpressionCompiler.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.ExpressionEvaluator.ExpressionCompiler.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.ExpressionEvaluator.VisualBasic.ExpressionCompiler.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.InteractiveHost.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Test.Utilities, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Test.Utilities.Desktop, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("Roslyn.Test.Utilities.FX45, PublicKey=002400000480000094000000060200000024000052534131000400000100010055e0217eb635f69281051f9a823e0c7edd90f28063eb6c7a742a19b4f6139778ee0af438f47aed3b6e9f99838aa8dba689c7a71ddb860c96d923830b57bbd5cd6119406ddb9b002cf1c723bf272d6acbb7129e9d6dd5a5309c94e0ff4b2c884d45a55f475cd7dba59198086f61f5a8c8b5e601c0edbf269733f6f578fc8579c2")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("vbc, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("VBCSCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("VBCSCompilerPortable, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.InternalsVisibleToAttribute("vbi, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute(WrapNonExceptionThrows=true)]
[assembly:System.Runtime.Versioning.TargetFrameworkAttribute(".NETPortable,Version=v4.5,Profile=Profile7", FrameworkDisplayName=".NET Portable Subset")]
namespace Microsoft.CodeAnalysis
{
    public enum Accessibility
    {
        Friend = 4,
        Internal = 4,
        NotApplicable = 0,
        Private = 1,
        Protected = 3,
        ProtectedAndFriend = 2,
        ProtectedAndInternal = 2,
        ProtectedOrFriend = 5,
        ProtectedOrInternal = 5,
        Public = 6,
    }
    public abstract partial class AdditionalText
    {
        protected AdditionalText() { }
        public abstract string Path { get; }
        public abstract Microsoft.CodeAnalysis.Text.SourceText GetText(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
    }
    public static partial class AnnotationExtensions
    {
        public static TNode WithAdditionalAnnotations<TNode>(this TNode node, params Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TNode WithAdditionalAnnotations<TNode>(this TNode node, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> annotations) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TNode WithoutAnnotations<TNode>(this TNode node, params Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TNode WithoutAnnotations<TNode>(this TNode node, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> annotations) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TNode WithoutAnnotations<TNode>(this TNode node, string annotationKind) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
    public sealed partial class AssemblyIdentity : System.IEquatable<Microsoft.CodeAnalysis.AssemblyIdentity>
    {
        public AssemblyIdentity(string name, System.Version version=null, string cultureName=null, System.Collections.Immutable.ImmutableArray<byte> publicKeyOrToken=default(System.Collections.Immutable.ImmutableArray<byte>), bool hasPublicKey=false, bool isRetargetable=false, System.Reflection.AssemblyContentType contentType=(System.Reflection.AssemblyContentType)(0)) { }
        public System.Reflection.AssemblyContentType ContentType { get { throw null; } }
        public string CultureName { get { throw null; } }
        public System.Reflection.AssemblyNameFlags Flags { get { throw null; } }
        public bool HasPublicKey { get { throw null; } }
        public bool IsRetargetable { get { throw null; } }
        public bool IsStrongName { get { throw null; } }
        public string Name { get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<byte> PublicKey { get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<byte> PublicKeyToken { get { throw null; } }
        public System.Version Version { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.AssemblyIdentity obj) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public static Microsoft.CodeAnalysis.AssemblyIdentity FromAssemblyDefinition(System.Reflection.Assembly assembly) { throw null; }
        public string GetDisplayName(bool fullKey=false) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.AssemblyIdentity left, Microsoft.CodeAnalysis.AssemblyIdentity right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.AssemblyIdentity left, Microsoft.CodeAnalysis.AssemblyIdentity right) { throw null; }
        public override string ToString() { throw null; }
        public static bool TryParseDisplayName(string displayName, out Microsoft.CodeAnalysis.AssemblyIdentity identity) { identity = default(Microsoft.CodeAnalysis.AssemblyIdentity); throw null; }
        public static bool TryParseDisplayName(string displayName, out Microsoft.CodeAnalysis.AssemblyIdentity identity, out Microsoft.CodeAnalysis.AssemblyIdentityParts parts) { identity = default(Microsoft.CodeAnalysis.AssemblyIdentity); parts = default(Microsoft.CodeAnalysis.AssemblyIdentityParts); throw null; }
    }
    public partial class AssemblyIdentityComparer
    {
        internal AssemblyIdentityComparer() { }
        public static System.StringComparer CultureComparer { get { throw null; } }
        public static Microsoft.CodeAnalysis.AssemblyIdentityComparer Default { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static System.StringComparer SimpleNameComparer { get { throw null; } }
        public Microsoft.CodeAnalysis.AssemblyIdentityComparer.ComparisonResult Compare(Microsoft.CodeAnalysis.AssemblyIdentity reference, Microsoft.CodeAnalysis.AssemblyIdentity definition) { throw null; }
        public bool ReferenceMatchesDefinition(Microsoft.CodeAnalysis.AssemblyIdentity reference, Microsoft.CodeAnalysis.AssemblyIdentity definition) { throw null; }
        public bool ReferenceMatchesDefinition(string referenceDisplayName, Microsoft.CodeAnalysis.AssemblyIdentity definition) { throw null; }
        public enum ComparisonResult
        {
            Equivalent = 1,
            EquivalentIgnoringVersion = 2,
            NotEquivalent = 0,
        }
    }
    [System.FlagsAttribute]
    public enum AssemblyIdentityParts
    {
        ContentType = 512,
        Culture = 32,
        Name = 1,
        PublicKey = 64,
        PublicKeyOrToken = 192,
        PublicKeyToken = 128,
        Retargetability = 256,
        Unknown = 1024,
        Version = 30,
        VersionBuild = 8,
        VersionMajor = 2,
        VersionMinor = 4,
        VersionRevision = 16,
    }
    public sealed partial class AssemblyMetadata : Microsoft.CodeAnalysis.Metadata
    {
        internal AssemblyMetadata() { }
        public override Microsoft.CodeAnalysis.MetadataImageKind Kind { get { throw null; } }
        protected override Microsoft.CodeAnalysis.Metadata CommonCopy() { throw null; }
        public static Microsoft.CodeAnalysis.AssemblyMetadata Create(Microsoft.CodeAnalysis.ModuleMetadata module) { throw null; }
        public static Microsoft.CodeAnalysis.AssemblyMetadata Create(params Microsoft.CodeAnalysis.ModuleMetadata[] modules) { throw null; }
        public static Microsoft.CodeAnalysis.AssemblyMetadata Create(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ModuleMetadata> modules) { throw null; }
        public static Microsoft.CodeAnalysis.AssemblyMetadata Create(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ModuleMetadata> modules) { throw null; }
        public static Microsoft.CodeAnalysis.AssemblyMetadata CreateFromFile(string path) { throw null; }
        public static Microsoft.CodeAnalysis.AssemblyMetadata CreateFromImage(System.Collections.Generic.IEnumerable<byte> peImage) { throw null; }
        public static Microsoft.CodeAnalysis.AssemblyMetadata CreateFromImage(System.Collections.Immutable.ImmutableArray<byte> peImage) { throw null; }
        public static Microsoft.CodeAnalysis.AssemblyMetadata CreateFromStream(System.IO.Stream peStream, bool leaveOpen=false) { throw null; }
        public static Microsoft.CodeAnalysis.AssemblyMetadata CreateFromStream(System.IO.Stream peStream, System.Reflection.PortableExecutable.PEStreamOptions options) { throw null; }
        public override void Dispose() { }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ModuleMetadata> GetModules() { throw null; }
        public Microsoft.CodeAnalysis.PortableExecutableReference GetReference(Microsoft.CodeAnalysis.DocumentationProvider documentation=null, System.Collections.Immutable.ImmutableArray<string> aliases=default(System.Collections.Immutable.ImmutableArray<string>), bool embedInteropTypes=false, string filePath=null, string display=null) { throw null; }
    }
    public abstract partial class AttributeData
    {
        protected AttributeData() { }
        public Microsoft.CodeAnalysis.SyntaxReference ApplicationSyntaxReference { get { throw null; } }
        public Microsoft.CodeAnalysis.INamedTypeSymbol AttributeClass { get { throw null; } }
        public Microsoft.CodeAnalysis.IMethodSymbol AttributeConstructor { get { throw null; } }
        protected abstract Microsoft.CodeAnalysis.SyntaxReference CommonApplicationSyntaxReference { get; }
        protected abstract Microsoft.CodeAnalysis.INamedTypeSymbol CommonAttributeClass { get; }
        protected abstract Microsoft.CodeAnalysis.IMethodSymbol CommonAttributeConstructor { get; }
        protected internal abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.TypedConstant> CommonConstructorArguments { get; }
        protected internal abstract System.Collections.Immutable.ImmutableArray<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.TypedConstant>> CommonNamedArguments { get; }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.TypedConstant> ConstructorArguments { get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.TypedConstant>> NamedArguments { get { throw null; } }
    }
    public enum CandidateReason
    {
        Ambiguous = 15,
        Inaccessible = 8,
        LateBound = 14,
        MemberGroup = 16,
        None = 0,
        NotAnAttributeType = 4,
        NotAnEvent = 2,
        NotATypeOrNamespace = 1,
        NotAValue = 9,
        NotAVariable = 10,
        NotAWithEventsMember = 3,
        NotCreatable = 6,
        NotInvocable = 11,
        NotReferencable = 7,
        OverloadResolutionFailure = 13,
        StaticInstanceMismatch = 12,
        WrongArity = 5,
    }
    public static partial class CaseInsensitiveComparison
    {
        public static System.StringComparer Comparer { get { throw null; } }
        public static int Compare(string left, string right) { throw null; }
        public static bool EndsWith(string value, string possibleEnd) { throw null; }
        public static bool Equals(string left, string right) { throw null; }
        public static int GetHashCode(string value) { throw null; }
        public static char ToLower(char c) { throw null; }
        public static string ToLower(string value) { throw null; }
        public static void ToLower(System.Text.StringBuilder builder) { }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct ChildSyntaxList : System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken>, System.Collections.Generic.IReadOnlyCollection<Microsoft.CodeAnalysis.SyntaxNodeOrToken>, System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.SyntaxNodeOrToken>, System.Collections.IEnumerable, System.IEquatable<Microsoft.CodeAnalysis.ChildSyntaxList>
    {
        public int Count { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken this[int index] { get { throw null; } }
        public bool Any() { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.ChildSyntaxList other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken First() { throw null; }
        public Microsoft.CodeAnalysis.ChildSyntaxList.Enumerator GetEnumerator() { throw null; }
        public override int GetHashCode() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken Last() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.ChildSyntaxList list1, Microsoft.CodeAnalysis.ChildSyntaxList list2) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.ChildSyntaxList list1, Microsoft.CodeAnalysis.ChildSyntaxList list2) { throw null; }
        public Microsoft.CodeAnalysis.ChildSyntaxList.Reversed Reverse() { throw null; }
        System.Collections.Generic.IEnumerator<Microsoft.CodeAnalysis.SyntaxNodeOrToken> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken>.GetEnumerator() { throw null; }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public partial struct Enumerator
        {
            public Microsoft.CodeAnalysis.SyntaxNodeOrToken Current { get { throw null; } }
            public bool MoveNext() { throw null; }
            public void Reset() { }
        }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public partial struct Reversed : System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken>, System.Collections.IEnumerable, System.IEquatable<Microsoft.CodeAnalysis.ChildSyntaxList.Reversed>
        {
            public bool Equals(Microsoft.CodeAnalysis.ChildSyntaxList.Reversed other) { throw null; }
            public override bool Equals(object obj) { throw null; }
            public Microsoft.CodeAnalysis.ChildSyntaxList.Reversed.Enumerator GetEnumerator() { throw null; }
            public override int GetHashCode() { throw null; }
            System.Collections.Generic.IEnumerator<Microsoft.CodeAnalysis.SyntaxNodeOrToken> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken>.GetEnumerator() { throw null; }
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
            [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
            public partial struct Enumerator
            {
                public Microsoft.CodeAnalysis.SyntaxNodeOrToken Current { get { throw null; } }
                public bool MoveNext() { throw null; }
                public void Reset() { }
            }
        }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct CommandLineAnalyzerReference : System.IEquatable<Microsoft.CodeAnalysis.CommandLineAnalyzerReference>
    {
        public CommandLineAnalyzerReference(string path) { throw null;}
        public string FilePath { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.CommandLineAnalyzerReference other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    public abstract partial class CommandLineArguments
    {
        internal CommandLineArguments() { }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CommandLineSourceFile> AdditionalFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CommandLineAnalyzerReference> AnalyzerReferences { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string AppConfigPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string BaseDirectory { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.Text.SourceHashAlgorithm ChecksumAlgorithm { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string CompilationName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.CompilationOptions CompilationOptions { get { throw null; } }
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CompilationOptionsCore { get; }
        public bool DisplayHelp { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool DisplayLogo { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string DocumentationPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.Emit.EmitOptions EmitOptions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool EmitPdb { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Text.Encoding Encoding { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string ErrorLogPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> Errors { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool InteractiveMode { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<string> KeyFileSearchPaths { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ResourceDescription> ManifestResources { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CommandLineReference> MetadataReferences { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool NoWin32Manifest { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string OutputDirectory { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string OutputFileName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.ParseOptions ParseOptions { get { throw null; } }
        protected abstract Microsoft.CodeAnalysis.ParseOptions ParseOptionsCore { get; }
        public System.Collections.Immutable.ImmutableArray<System.Collections.Generic.KeyValuePair<string, string>> PathMap { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string PdbPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Globalization.CultureInfo PreferredUILang { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool PrintFullPaths { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<string> ReferencePaths { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool ReportAnalyzer { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<string> ScriptArguments { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CommandLineSourceFile> SourceFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<string> SourcePaths { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string TouchedFilesPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool Utf8Output { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string Win32Icon { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string Win32Manifest { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string Win32ResourceFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference> ResolveAnalyzerReferences(Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader analyzerLoader) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> ResolveMetadataReferences(Microsoft.CodeAnalysis.MetadataReferenceResolver metadataResolver) { throw null; }
    }
    public abstract partial class CommandLineParser
    {
        internal CommandLineParser() { }
        protected abstract string RegularFileExtension { get; }
        protected abstract string ScriptFileExtension { get; }
        public Microsoft.CodeAnalysis.CommandLineArguments Parse(System.Collections.Generic.IEnumerable<string> args, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories) { throw null; }
        protected System.Collections.Immutable.ImmutableArray<System.Collections.Generic.KeyValuePair<string, string>> ParsePathMap(string pathMap, System.Collections.Generic.IList<Microsoft.CodeAnalysis.Diagnostic> errors) { throw null; }
        public static System.Collections.Generic.IEnumerable<string> SplitCommandLineIntoArguments(string commandLine, bool removeHashComments) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct CommandLineReference : System.IEquatable<Microsoft.CodeAnalysis.CommandLineReference>
    {
        public Microsoft.CodeAnalysis.MetadataReferenceProperties Properties { get { throw null; } }
        public string Reference { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.CommandLineReference other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct CommandLineSourceFile
    {
        public bool IsScript { get { throw null; } }
        public string Path { get { throw null; } }
    }
    public abstract partial class Compilation
    {
        internal Compilation() { }
        public Microsoft.CodeAnalysis.IAssemblySymbol Assembly { get { throw null; } }
        public string AssemblyName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        protected abstract Microsoft.CodeAnalysis.IAssemblySymbol CommonAssembly { get; }
        protected abstract Microsoft.CodeAnalysis.ITypeSymbol CommonDynamicType { get; }
        protected abstract Microsoft.CodeAnalysis.INamespaceSymbol CommonGlobalNamespace { get; }
        protected abstract Microsoft.CodeAnalysis.INamedTypeSymbol CommonObjectType { get; }
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonOptions { get; }
        protected abstract Microsoft.CodeAnalysis.INamedTypeSymbol CommonScriptClass { get; }
        protected abstract Microsoft.CodeAnalysis.IModuleSymbol CommonSourceModule { get; }
        protected abstract System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> CommonSyntaxTrees { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.MetadataReference> DirectiveReferences { get; }
        public Microsoft.CodeAnalysis.ITypeSymbol DynamicType { get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.MetadataReference> ExternalReferences { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.INamespaceSymbol GlobalNamespace { get { throw null; } }
        public abstract bool IsCaseSensitive { get; }
        public abstract string Language { get; }
        public Microsoft.CodeAnalysis.INamedTypeSymbol ObjectType { get { throw null; } }
        public Microsoft.CodeAnalysis.CompilationOptions Options { get { throw null; } }
        public abstract System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.AssemblyIdentity> ReferencedAssemblyNames { get; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> References { get { throw null; } }
        public Microsoft.CodeAnalysis.INamedTypeSymbol ScriptClass { get { throw null; } }
        public Microsoft.CodeAnalysis.ScriptCompilationInfo ScriptCompilationInfo { get { throw null; } }
        public Microsoft.CodeAnalysis.IModuleSymbol SourceModule { get { throw null; } }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> SyntaxTrees { get { throw null; } }
        public Microsoft.CodeAnalysis.Compilation AddReferences(params Microsoft.CodeAnalysis.MetadataReference[] references) { throw null; }
        public Microsoft.CodeAnalysis.Compilation AddReferences(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> references) { throw null; }
        public Microsoft.CodeAnalysis.Compilation AddSyntaxTrees(params Microsoft.CodeAnalysis.SyntaxTree[] trees) { throw null; }
        public Microsoft.CodeAnalysis.Compilation AddSyntaxTrees(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> trees) { throw null; }
        protected abstract void AppendDefaultVersionResource(System.IO.Stream resourceStream);
        public Microsoft.CodeAnalysis.Compilation Clone() { throw null; }
        protected abstract Microsoft.CodeAnalysis.Compilation CommonAddSyntaxTrees(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> trees);
        protected abstract Microsoft.CodeAnalysis.Compilation CommonClone();
        protected abstract bool CommonContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree syntaxTree);
        protected abstract Microsoft.CodeAnalysis.IArrayTypeSymbol CommonCreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol elementType, int rank);
        protected abstract Microsoft.CodeAnalysis.IPointerTypeSymbol CommonCreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol elementType);
        protected abstract Microsoft.CodeAnalysis.ISymbol CommonGetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference reference);
        protected abstract Microsoft.CodeAnalysis.INamespaceSymbol CommonGetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol namespaceSymbol);
        protected abstract Microsoft.CodeAnalysis.IMethodSymbol CommonGetEntryPoint(System.Threading.CancellationToken cancellationToken);
        protected abstract Microsoft.CodeAnalysis.SemanticModel CommonGetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree syntaxTree, bool ignoreAccessibility);
        protected abstract Microsoft.CodeAnalysis.INamedTypeSymbol CommonGetSpecialType(Microsoft.CodeAnalysis.SpecialType specialType);
        protected abstract Microsoft.CodeAnalysis.INamedTypeSymbol CommonGetTypeByMetadataName(string metadataName);
        protected abstract Microsoft.CodeAnalysis.Compilation CommonRemoveAllSyntaxTrees();
        protected abstract Microsoft.CodeAnalysis.Compilation CommonRemoveSyntaxTrees(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> trees);
        protected abstract Microsoft.CodeAnalysis.Compilation CommonReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree oldTree, Microsoft.CodeAnalysis.SyntaxTree newTree);
        protected abstract Microsoft.CodeAnalysis.Compilation CommonWithAssemblyName(string outputName);
        protected abstract Microsoft.CodeAnalysis.Compilation CommonWithOptions(Microsoft.CodeAnalysis.CompilationOptions options);
        protected abstract Microsoft.CodeAnalysis.Compilation CommonWithReferences(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> newReferences);
        protected abstract Microsoft.CodeAnalysis.Compilation CommonWithScriptCompilationInfo(Microsoft.CodeAnalysis.ScriptCompilationInfo info);
        public abstract bool ContainsSymbolsWithName(System.Func<string, bool> predicate, Microsoft.CodeAnalysis.SymbolFilter filter=(Microsoft.CodeAnalysis.SymbolFilter)(6), System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public bool ContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree syntaxTree) { throw null; }
        public Microsoft.CodeAnalysis.IArrayTypeSymbol CreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol elementType, int rank=1) { throw null; }
        public System.IO.Stream CreateDefaultWin32Resources(bool versionResource, bool noManifest, System.IO.Stream manifestContents, System.IO.Stream iconInIcoFormat) { throw null; }
        public abstract Microsoft.CodeAnalysis.INamedTypeSymbol CreateErrorTypeSymbol(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name, int arity);
        public Microsoft.CodeAnalysis.IPointerTypeSymbol CreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol pointedAtType) { throw null; }
        public Microsoft.CodeAnalysis.Emit.EmitResult Emit(System.IO.Stream peStream, System.IO.Stream pdbStream=null, System.IO.Stream xmlDocumentationStream=null, System.IO.Stream win32Resources=null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ResourceDescription> manifestResources=null, Microsoft.CodeAnalysis.Emit.EmitOptions options=null, Microsoft.CodeAnalysis.IMethodSymbol debugEntryPoint=null, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
        public Microsoft.CodeAnalysis.Emit.EmitResult Emit(System.IO.Stream peStream, System.IO.Stream pdbStream, System.IO.Stream xmlDocumentationStream, System.IO.Stream win32Resources, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ResourceDescription> manifestResources, Microsoft.CodeAnalysis.Emit.EmitOptions options, System.Threading.CancellationToken cancellationToken) { throw null; }
        public Microsoft.CodeAnalysis.Emit.EmitDifferenceResult EmitDifference(Microsoft.CodeAnalysis.Emit.EmitBaseline baseline, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Emit.SemanticEdit> edits, System.Func<Microsoft.CodeAnalysis.ISymbol, bool> isAddedSymbol, System.IO.Stream metadataStream, System.IO.Stream ilStream, System.IO.Stream pdbStream, System.Collections.Generic.ICollection<System.Reflection.Metadata.MethodDefinitionHandle> updatedMethods, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public Microsoft.CodeAnalysis.Emit.EmitDifferenceResult EmitDifference(Microsoft.CodeAnalysis.Emit.EmitBaseline baseline, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Emit.SemanticEdit> edits, System.IO.Stream metadataStream, System.IO.Stream ilStream, System.IO.Stream pdbStream, System.Collections.Generic.ICollection<System.Reflection.Metadata.MethodDefinitionHandle> updatedMethods, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public Microsoft.CodeAnalysis.ISymbol GetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference reference) { throw null; }
        public Microsoft.CodeAnalysis.INamespaceSymbol GetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol namespaceSymbol) { throw null; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetDeclarationDiagnostics(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public Microsoft.CodeAnalysis.IMethodSymbol GetEntryPoint(System.Threading.CancellationToken cancellationToken) { throw null; }
        public Microsoft.CodeAnalysis.MetadataReference GetMetadataReference(Microsoft.CodeAnalysis.IAssemblySymbol assemblySymbol) { throw null; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetMethodBodyDiagnostics(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetParseDiagnostics(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public Microsoft.CodeAnalysis.SemanticModel GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree syntaxTree, bool ignoreAccessibility=false) { throw null; }
        public Microsoft.CodeAnalysis.INamedTypeSymbol GetSpecialType(Microsoft.CodeAnalysis.SpecialType specialType) { throw null; }
        public abstract System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ISymbol> GetSymbolsWithName(System.Func<string, bool> predicate, Microsoft.CodeAnalysis.SymbolFilter filter=(Microsoft.CodeAnalysis.SymbolFilter)(6), System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public Microsoft.CodeAnalysis.INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName) { throw null; }
        public Microsoft.CodeAnalysis.Compilation RemoveAllReferences() { throw null; }
        public Microsoft.CodeAnalysis.Compilation RemoveAllSyntaxTrees() { throw null; }
        public Microsoft.CodeAnalysis.Compilation RemoveReferences(params Microsoft.CodeAnalysis.MetadataReference[] references) { throw null; }
        public Microsoft.CodeAnalysis.Compilation RemoveReferences(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> references) { throw null; }
        public Microsoft.CodeAnalysis.Compilation RemoveSyntaxTrees(params Microsoft.CodeAnalysis.SyntaxTree[] trees) { throw null; }
        public Microsoft.CodeAnalysis.Compilation RemoveSyntaxTrees(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> trees) { throw null; }
        public Microsoft.CodeAnalysis.Compilation ReplaceReference(Microsoft.CodeAnalysis.MetadataReference oldReference, Microsoft.CodeAnalysis.MetadataReference newReference) { throw null; }
        public Microsoft.CodeAnalysis.Compilation ReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree oldTree, Microsoft.CodeAnalysis.SyntaxTree newTree) { throw null; }
        protected static System.Collections.Generic.IReadOnlyDictionary<string, string> SyntaxTreeCommonFeatures(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> trees) { throw null; }
        public abstract Microsoft.CodeAnalysis.CompilationReference ToMetadataReference(System.Collections.Immutable.ImmutableArray<string> aliases=default(System.Collections.Immutable.ImmutableArray<string>), bool embedInteropTypes=false);
        public Microsoft.CodeAnalysis.Compilation WithAssemblyName(string assemblyName) { throw null; }
        public Microsoft.CodeAnalysis.Compilation WithOptions(Microsoft.CodeAnalysis.CompilationOptions options) { throw null; }
        public Microsoft.CodeAnalysis.Compilation WithReferences(params Microsoft.CodeAnalysis.MetadataReference[] newReferences) { throw null; }
        public Microsoft.CodeAnalysis.Compilation WithReferences(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> newReferences) { throw null; }
        public Microsoft.CodeAnalysis.Compilation WithScriptCompilationInfo(Microsoft.CodeAnalysis.ScriptCompilationInfo info) { throw null; }
    }
    public abstract partial class CompilationOptions
    {
        internal CompilationOptions() { }
        public Microsoft.CodeAnalysis.AssemblyIdentityComparer AssemblyIdentityComparer { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public bool CheckOverflow { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public bool ConcurrentBuild { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public string CryptoKeyContainer { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public string CryptoKeyFile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public System.Collections.Immutable.ImmutableArray<byte> CryptoPublicKey { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public System.Nullable<bool> DelaySign { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public bool Deterministic { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> Errors { get { throw null; } }
        [System.ObsoleteAttribute]
        protected internal System.Collections.Immutable.ImmutableArray<string> Features { get { throw null; } protected set { } }
        public Microsoft.CodeAnalysis.ReportDiagnostic GeneralDiagnosticOption { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public string MainTypeName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public Microsoft.CodeAnalysis.MetadataReferenceResolver MetadataReferenceResolver { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public string ModuleName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public Microsoft.CodeAnalysis.OptimizationLevel OptimizationLevel { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public Microsoft.CodeAnalysis.OutputKind OutputKind { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public Microsoft.CodeAnalysis.Platform Platform { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public bool PublicSign { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public bool ReportSuppressedDiagnostics { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public string ScriptClassName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public Microsoft.CodeAnalysis.SourceReferenceResolver SourceReferenceResolver { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic> SpecificDiagnosticOptions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public Microsoft.CodeAnalysis.StrongNameProvider StrongNameProvider { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public int WarningLevel { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public Microsoft.CodeAnalysis.XmlReferenceResolver XmlReferenceResolver { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonWithAssemblyIdentityComparer(Microsoft.CodeAnalysis.AssemblyIdentityComparer comparer);
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonWithDeterministic(bool deterministic);
        [System.ObsoleteAttribute]
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonWithFeatures(System.Collections.Immutable.ImmutableArray<string> features);
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonWithGeneralDiagnosticOption(Microsoft.CodeAnalysis.ReportDiagnostic generalDiagnosticOption);
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonWithMetadataReferenceResolver(Microsoft.CodeAnalysis.MetadataReferenceResolver resolver);
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonWithOptimizationLevel(Microsoft.CodeAnalysis.OptimizationLevel value);
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonWithOutputKind(Microsoft.CodeAnalysis.OutputKind kind);
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonWithPlatform(Microsoft.CodeAnalysis.Platform platform);
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonWithPublicSign(bool publicSign);
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonWithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics);
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonWithSourceReferenceResolver(Microsoft.CodeAnalysis.SourceReferenceResolver resolver);
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonWithSpecificDiagnosticOptions(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>> specificDiagnosticOptions);
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonWithSpecificDiagnosticOptions(System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic> specificDiagnosticOptions);
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonWithStrongNameProvider(Microsoft.CodeAnalysis.StrongNameProvider provider);
        protected abstract Microsoft.CodeAnalysis.CompilationOptions CommonWithXmlReferenceResolver(Microsoft.CodeAnalysis.XmlReferenceResolver resolver);
        public abstract override bool Equals(object obj);
        protected bool EqualsHelper(Microsoft.CodeAnalysis.CompilationOptions other) { throw null; }
        public abstract override int GetHashCode();
        protected int GetHashCodeHelper() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.CompilationOptions left, Microsoft.CodeAnalysis.CompilationOptions right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.CompilationOptions left, Microsoft.CodeAnalysis.CompilationOptions right) { throw null; }
        public Microsoft.CodeAnalysis.CompilationOptions WithAssemblyIdentityComparer(Microsoft.CodeAnalysis.AssemblyIdentityComparer comparer) { throw null; }
        public Microsoft.CodeAnalysis.CompilationOptions WithDeterministic(bool deterministic) { throw null; }
        public Microsoft.CodeAnalysis.CompilationOptions WithGeneralDiagnosticOption(Microsoft.CodeAnalysis.ReportDiagnostic value) { throw null; }
        public Microsoft.CodeAnalysis.CompilationOptions WithMetadataReferenceResolver(Microsoft.CodeAnalysis.MetadataReferenceResolver resolver) { throw null; }
        public Microsoft.CodeAnalysis.CompilationOptions WithOptimizationLevel(Microsoft.CodeAnalysis.OptimizationLevel value) { throw null; }
        public Microsoft.CodeAnalysis.CompilationOptions WithOutputKind(Microsoft.CodeAnalysis.OutputKind kind) { throw null; }
        public Microsoft.CodeAnalysis.CompilationOptions WithPlatform(Microsoft.CodeAnalysis.Platform platform) { throw null; }
        public Microsoft.CodeAnalysis.CompilationOptions WithPublicSign(bool publicSign) { throw null; }
        public Microsoft.CodeAnalysis.CompilationOptions WithReportSuppressedDiagnostics(bool value) { throw null; }
        public Microsoft.CodeAnalysis.CompilationOptions WithSourceReferenceResolver(Microsoft.CodeAnalysis.SourceReferenceResolver resolver) { throw null; }
        public Microsoft.CodeAnalysis.CompilationOptions WithSpecificDiagnosticOptions(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>> value) { throw null; }
        public Microsoft.CodeAnalysis.CompilationOptions WithSpecificDiagnosticOptions(System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic> value) { throw null; }
        public Microsoft.CodeAnalysis.CompilationOptions WithStrongNameProvider(Microsoft.CodeAnalysis.StrongNameProvider provider) { throw null; }
        public Microsoft.CodeAnalysis.CompilationOptions WithXmlReferenceResolver(Microsoft.CodeAnalysis.XmlReferenceResolver resolver) { throw null; }
    }
    public abstract partial class CompilationReference : Microsoft.CodeAnalysis.MetadataReference, System.IEquatable<Microsoft.CodeAnalysis.CompilationReference>
    {
        internal CompilationReference() : base (default(Microsoft.CodeAnalysis.MetadataReferenceProperties)) { }
        public Microsoft.CodeAnalysis.Compilation Compilation { get { throw null; } }
        public override string Display { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.CompilationReference other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public new Microsoft.CodeAnalysis.CompilationReference WithAliases(System.Collections.Generic.IEnumerable<string> aliases) { throw null; }
        public new Microsoft.CodeAnalysis.CompilationReference WithAliases(System.Collections.Immutable.ImmutableArray<string> aliases) { throw null; }
        public new Microsoft.CodeAnalysis.CompilationReference WithEmbedInteropTypes(bool value) { throw null; }
        public new Microsoft.CodeAnalysis.CompilationReference WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties properties) { throw null; }
    }
    public abstract partial class ControlFlowAnalysis
    {
        protected ControlFlowAnalysis() { }
        public abstract bool EndPointIsReachable { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SyntaxNode> EntryPoints { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SyntaxNode> ExitPoints { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SyntaxNode> ReturnStatements { get; }
        public abstract bool StartPointIsReachable { get; }
        public abstract bool Succeeded { get; }
    }
    public abstract partial class CustomModifier
    {
        protected CustomModifier() { }
        public abstract bool IsOptional { get; }
        public abstract Microsoft.CodeAnalysis.INamedTypeSymbol Modifier { get; }
    }
    public abstract partial class DataFlowAnalysis
    {
        protected DataFlowAnalysis() { }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> AlwaysAssigned { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> Captured { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> DataFlowsIn { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> DataFlowsOut { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> ReadInside { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> ReadOutside { get; }
        public abstract bool Succeeded { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> UnsafeAddressTaken { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> VariablesDeclared { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> WrittenInside { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> WrittenOutside { get; }
    }
    public sealed partial class DesktopAssemblyIdentityComparer : Microsoft.CodeAnalysis.AssemblyIdentityComparer
    {
        internal DesktopAssemblyIdentityComparer() { }
        public static new Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer Default { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer LoadFromXml(System.IO.Stream input) { throw null; }
    }
    public partial class DesktopStrongNameProvider : Microsoft.CodeAnalysis.StrongNameProvider
    {
        public DesktopStrongNameProvider(System.Collections.Immutable.ImmutableArray<string> keyFileSearchPaths=default(System.Collections.Immutable.ImmutableArray<string>)) { }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
    public abstract partial class Diagnostic : System.IEquatable<Microsoft.CodeAnalysis.Diagnostic>, System.IFormattable
    {
        protected Diagnostic() { }
        public abstract System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Location> AdditionalLocations { get; }
        public virtual Microsoft.CodeAnalysis.DiagnosticSeverity DefaultSeverity { get { throw null; } }
        public abstract Microsoft.CodeAnalysis.DiagnosticDescriptor Descriptor { get; }
        public abstract string Id { get; }
        public abstract bool IsSuppressed { get; }
        public bool IsWarningAsError { get { throw null; } }
        public abstract Microsoft.CodeAnalysis.Location Location { get; }
        public virtual System.Collections.Immutable.ImmutableDictionary<string, string> Properties { get { throw null; } }
        public abstract Microsoft.CodeAnalysis.DiagnosticSeverity Severity { get; }
        public abstract int WarningLevel { get; }
        public static Microsoft.CodeAnalysis.Diagnostic Create(Microsoft.CodeAnalysis.DiagnosticDescriptor descriptor, Microsoft.CodeAnalysis.Location location, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Location> additionalLocations, System.Collections.Immutable.ImmutableDictionary<string, string> properties, params object[] messageArgs) { throw null; }
        public static Microsoft.CodeAnalysis.Diagnostic Create(Microsoft.CodeAnalysis.DiagnosticDescriptor descriptor, Microsoft.CodeAnalysis.Location location, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Location> additionalLocations, params object[] messageArgs) { throw null; }
        public static Microsoft.CodeAnalysis.Diagnostic Create(Microsoft.CodeAnalysis.DiagnosticDescriptor descriptor, Microsoft.CodeAnalysis.Location location, System.Collections.Immutable.ImmutableDictionary<string, string> properties, params object[] messageArgs) { throw null; }
        public static Microsoft.CodeAnalysis.Diagnostic Create(Microsoft.CodeAnalysis.DiagnosticDescriptor descriptor, Microsoft.CodeAnalysis.Location location, params object[] messageArgs) { throw null; }
        public static Microsoft.CodeAnalysis.Diagnostic Create(string id, string category, Microsoft.CodeAnalysis.LocalizableString message, Microsoft.CodeAnalysis.DiagnosticSeverity severity, Microsoft.CodeAnalysis.DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, Microsoft.CodeAnalysis.LocalizableString title=null, Microsoft.CodeAnalysis.LocalizableString description=null, string helpLink=null, Microsoft.CodeAnalysis.Location location=null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Location> additionalLocations=null, System.Collections.Generic.IEnumerable<string> customTags=null, System.Collections.Immutable.ImmutableDictionary<string, string> properties=null) { throw null; }
        public static Microsoft.CodeAnalysis.Diagnostic Create(string id, string category, Microsoft.CodeAnalysis.LocalizableString message, Microsoft.CodeAnalysis.DiagnosticSeverity severity, Microsoft.CodeAnalysis.DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, bool isSuppressed, Microsoft.CodeAnalysis.LocalizableString title=null, Microsoft.CodeAnalysis.LocalizableString description=null, string helpLink=null, Microsoft.CodeAnalysis.Location location=null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Location> additionalLocations=null, System.Collections.Generic.IEnumerable<string> customTags=null, System.Collections.Immutable.ImmutableDictionary<string, string> properties=null) { throw null; }
        public abstract bool Equals(Microsoft.CodeAnalysis.Diagnostic obj);
        public abstract override bool Equals(object obj);
        public abstract override int GetHashCode();
        public abstract string GetMessage(System.IFormatProvider formatProvider=null);
        public Microsoft.CodeAnalysis.Diagnostics.SuppressionInfo GetSuppressionInfo(Microsoft.CodeAnalysis.Compilation compilation) { throw null; }
        string System.IFormattable.ToString(string ignored, System.IFormatProvider formatProvider) { throw null; }
        public override string ToString() { throw null; }
    }
    public sealed partial class DiagnosticDescriptor : System.IEquatable<Microsoft.CodeAnalysis.DiagnosticDescriptor>
    {
        public DiagnosticDescriptor(string id, Microsoft.CodeAnalysis.LocalizableString title, Microsoft.CodeAnalysis.LocalizableString messageFormat, string category, Microsoft.CodeAnalysis.DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, Microsoft.CodeAnalysis.LocalizableString description=null, string helpLinkUri=null, params string[] customTags) { }
        public DiagnosticDescriptor(string id, string title, string messageFormat, string category, Microsoft.CodeAnalysis.DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, string description=null, string helpLinkUri=null, params string[] customTags) { }
        public string Category { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Generic.IEnumerable<string> CustomTags { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.DiagnosticSeverity DefaultSeverity { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.LocalizableString Description { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string HelpLinkUri { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string Id { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool IsEnabledByDefault { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.LocalizableString MessageFormat { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.LocalizableString Title { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.DiagnosticDescriptor other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public Microsoft.CodeAnalysis.ReportDiagnostic GetEffectiveSeverity(Microsoft.CodeAnalysis.CompilationOptions compilationOptions) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    public partial class DiagnosticFormatter
    {
        public DiagnosticFormatter() { }
        public virtual string Format(Microsoft.CodeAnalysis.Diagnostic diagnostic, System.IFormatProvider formatter=null) { throw null; }
    }
    public enum DiagnosticSeverity
    {
        Error = 3,
        Hidden = 0,
        Info = 1,
        Warning = 2,
    }
    public sealed partial class DllImportData
    {
        internal DllImportData() { }
        public System.Nullable<bool> BestFitMapping { get { throw null; } }
        public System.Runtime.InteropServices.CallingConvention CallingConvention { get { throw null; } }
        public System.Runtime.InteropServices.CharSet CharacterSet { get { throw null; } }
        public string EntryPointName { get { throw null; } }
        public bool ExactSpelling { get { throw null; } }
        public string ModuleName { get { throw null; } }
        public bool SetLastError { get { throw null; } }
        public System.Nullable<bool> ThrowOnUnmappableCharacter { get { throw null; } }
    }
    public static partial class DocumentationCommentId
    {
        public static string CreateDeclarationId(Microsoft.CodeAnalysis.ISymbol symbol) { throw null; }
        public static string CreateReferenceId(Microsoft.CodeAnalysis.ISymbol symbol) { throw null; }
        public static Microsoft.CodeAnalysis.ISymbol GetFirstSymbolForDeclarationId(string id, Microsoft.CodeAnalysis.Compilation compilation) { throw null; }
        public static Microsoft.CodeAnalysis.ISymbol GetFirstSymbolForReferenceId(string id, Microsoft.CodeAnalysis.Compilation compilation) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> GetSymbolsForDeclarationId(string id, Microsoft.CodeAnalysis.Compilation compilation) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> GetSymbolsForReferenceId(string id, Microsoft.CodeAnalysis.Compilation compilation) { throw null; }
    }
    public enum DocumentationMode : byte
    {
        Diagnose = (byte)2,
        None = (byte)0,
        Parse = (byte)1,
    }
    public abstract partial class DocumentationProvider
    {
        protected DocumentationProvider() { }
        public static Microsoft.CodeAnalysis.DocumentationProvider Default { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public abstract override bool Equals(object obj);
        protected internal abstract string GetDocumentationForSymbol(string documentationMemberID, System.Globalization.CultureInfo preferredCulture, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public abstract override int GetHashCode();
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct FileLinePositionSpan : System.IEquatable<Microsoft.CodeAnalysis.FileLinePositionSpan>
    {
        public FileLinePositionSpan(string path, Microsoft.CodeAnalysis.Text.LinePosition start, Microsoft.CodeAnalysis.Text.LinePosition end) { throw null;}
        public FileLinePositionSpan(string path, Microsoft.CodeAnalysis.Text.LinePositionSpan span) { throw null;}
        public Microsoft.CodeAnalysis.Text.LinePosition EndLinePosition { get { throw null; } }
        public bool HasMappedPath { get { throw null; } }
        public bool IsValid { get { throw null; } }
        public string Path { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.LinePositionSpan Span { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.LinePosition StartLinePosition { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.FileLinePositionSpan other) { throw null; }
        public override bool Equals(object other) { throw null; }
        public override int GetHashCode() { throw null; }
        public override string ToString() { throw null; }
    }
    public static partial class FileSystemExtensions
    {
        public static Microsoft.CodeAnalysis.Emit.EmitResult Emit(this Microsoft.CodeAnalysis.Compilation compilation, string outputPath, string pdbPath=null, string xmlDocPath=null, string win32ResourcesPath=null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ResourceDescription> manifestResources=null, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
    }
    public partial interface IAliasSymbol : Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        Microsoft.CodeAnalysis.INamespaceOrTypeSymbol Target { get; }
    }
    public partial interface IAnalyzerAssemblyLoader
    {
        void AddDependencyLocation(string fullPath);
        System.Reflection.Assembly LoadFromPath(string fullPath);
    }
    public partial interface IArrayTypeSymbol : Microsoft.CodeAnalysis.INamespaceOrTypeSymbol, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.ITypeSymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CustomModifier> CustomModifiers { get; }
        Microsoft.CodeAnalysis.ITypeSymbol ElementType { get; }
        int Rank { get; }
        bool Equals(Microsoft.CodeAnalysis.IArrayTypeSymbol other);
    }
    public partial interface IAssemblySymbol : Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        Microsoft.CodeAnalysis.INamespaceSymbol GlobalNamespace { get; }
        Microsoft.CodeAnalysis.AssemblyIdentity Identity { get; }
        bool IsInteractive { get; }
        bool MightContainExtensionMethods { get; }
        System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.IModuleSymbol> Modules { get; }
        System.Collections.Generic.ICollection<string> NamespaceNames { get; }
        System.Collections.Generic.ICollection<string> TypeNames { get; }
        Microsoft.CodeAnalysis.AssemblyMetadata GetMetadata();
        Microsoft.CodeAnalysis.INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName);
        bool GivesAccessTo(Microsoft.CodeAnalysis.IAssemblySymbol toAssembly);
        Microsoft.CodeAnalysis.INamedTypeSymbol ResolveForwardedType(string fullyQualifiedMetadataName);
    }
    public partial interface ICompilationUnitSyntax
    {
        Microsoft.CodeAnalysis.SyntaxToken EndOfFileToken { get; }
    }
    public partial interface IDynamicTypeSymbol : Microsoft.CodeAnalysis.INamespaceOrTypeSymbol, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.ITypeSymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
    }
    public partial interface IErrorTypeSymbol : Microsoft.CodeAnalysis.INamedTypeSymbol, Microsoft.CodeAnalysis.INamespaceOrTypeSymbol, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.ITypeSymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        Microsoft.CodeAnalysis.CandidateReason CandidateReason { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> CandidateSymbols { get; }
    }
    public partial interface IEventSymbol : Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        Microsoft.CodeAnalysis.IMethodSymbol AddMethod { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IEventSymbol> ExplicitInterfaceImplementations { get; }
        bool IsWindowsRuntimeEvent { get; }
        new Microsoft.CodeAnalysis.IEventSymbol OriginalDefinition { get; }
        Microsoft.CodeAnalysis.IEventSymbol OverriddenEvent { get; }
        Microsoft.CodeAnalysis.IMethodSymbol RaiseMethod { get; }
        Microsoft.CodeAnalysis.IMethodSymbol RemoveMethod { get; }
        Microsoft.CodeAnalysis.ITypeSymbol Type { get; }
    }
    public partial interface IFieldSymbol : Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        Microsoft.CodeAnalysis.ISymbol AssociatedSymbol { get; }
        object ConstantValue { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CustomModifier> CustomModifiers { get; }
        bool HasConstantValue { get; }
        bool IsConst { get; }
        bool IsReadOnly { get; }
        bool IsVolatile { get; }
        new Microsoft.CodeAnalysis.IFieldSymbol OriginalDefinition { get; }
        Microsoft.CodeAnalysis.ITypeSymbol Type { get; }
    }
    public partial interface ILabelSymbol : Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        Microsoft.CodeAnalysis.IMethodSymbol ContainingMethod { get; }
    }
    public partial interface ILocalSymbol : Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        object ConstantValue { get; }
        bool HasConstantValue { get; }
        bool IsConst { get; }
        bool IsFunctionValue { get; }
        Microsoft.CodeAnalysis.ITypeSymbol Type { get; }
    }
    public partial interface IMethodSymbol : Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        int Arity { get; }
        Microsoft.CodeAnalysis.INamedTypeSymbol AssociatedAnonymousDelegate { get; }
        Microsoft.CodeAnalysis.ISymbol AssociatedSymbol { get; }
        Microsoft.CodeAnalysis.IMethodSymbol ConstructedFrom { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IMethodSymbol> ExplicitInterfaceImplementations { get; }
        bool HidesBaseMethodsByName { get; }
        bool IsAsync { get; }
        bool IsCheckedBuiltin { get; }
        bool IsExtensionMethod { get; }
        bool IsGenericMethod { get; }
        bool IsVararg { get; }
        Microsoft.CodeAnalysis.MethodKind MethodKind { get; }
        new Microsoft.CodeAnalysis.IMethodSymbol OriginalDefinition { get; }
        Microsoft.CodeAnalysis.IMethodSymbol OverriddenMethod { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IParameterSymbol> Parameters { get; }
        Microsoft.CodeAnalysis.IMethodSymbol PartialDefinitionPart { get; }
        Microsoft.CodeAnalysis.IMethodSymbol PartialImplementationPart { get; }
        Microsoft.CodeAnalysis.ITypeSymbol ReceiverType { get; }
        Microsoft.CodeAnalysis.IMethodSymbol ReducedFrom { get; }
        bool ReturnsVoid { get; }
        Microsoft.CodeAnalysis.ITypeSymbol ReturnType { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CustomModifier> ReturnTypeCustomModifiers { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ITypeSymbol> TypeArguments { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ITypeParameterSymbol> TypeParameters { get; }
        Microsoft.CodeAnalysis.IMethodSymbol Construct(params Microsoft.CodeAnalysis.ITypeSymbol[] typeArguments);
        Microsoft.CodeAnalysis.DllImportData GetDllImportData();
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.AttributeData> GetReturnTypeAttributes();
        Microsoft.CodeAnalysis.ITypeSymbol GetTypeInferredDuringReduction(Microsoft.CodeAnalysis.ITypeParameterSymbol reducedFromTypeParameter);
        Microsoft.CodeAnalysis.IMethodSymbol ReduceExtensionMethod(Microsoft.CodeAnalysis.ITypeSymbol receiverType);
    }
    public partial interface IModuleSymbol : Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        Microsoft.CodeAnalysis.INamespaceSymbol GlobalNamespace { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.AssemblyIdentity> ReferencedAssemblies { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IAssemblySymbol> ReferencedAssemblySymbols { get; }
        Microsoft.CodeAnalysis.ModuleMetadata GetMetadata();
        Microsoft.CodeAnalysis.INamespaceSymbol GetModuleNamespace(Microsoft.CodeAnalysis.INamespaceSymbol namespaceSymbol);
    }
    public partial interface INamedTypeSymbol : Microsoft.CodeAnalysis.INamespaceOrTypeSymbol, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.ITypeSymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        int Arity { get; }
        Microsoft.CodeAnalysis.ISymbol AssociatedSymbol { get; }
        Microsoft.CodeAnalysis.INamedTypeSymbol ConstructedFrom { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IMethodSymbol> Constructors { get; }
        Microsoft.CodeAnalysis.IMethodSymbol DelegateInvokeMethod { get; }
        Microsoft.CodeAnalysis.INamedTypeSymbol EnumUnderlyingType { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IMethodSymbol> InstanceConstructors { get; }
        bool IsGenericType { get; }
        bool IsImplicitClass { get; }
        bool IsScriptClass { get; }
        bool IsUnboundGenericType { get; }
        System.Collections.Generic.IEnumerable<string> MemberNames { get; }
        bool MightContainExtensionMethods { get; }
        new Microsoft.CodeAnalysis.INamedTypeSymbol OriginalDefinition { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IMethodSymbol> StaticConstructors { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ITypeSymbol> TypeArguments { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ITypeParameterSymbol> TypeParameters { get; }
        Microsoft.CodeAnalysis.INamedTypeSymbol Construct(params Microsoft.CodeAnalysis.ITypeSymbol[] typeArguments);
        Microsoft.CodeAnalysis.INamedTypeSymbol ConstructUnboundGenericType();
    }
    public partial interface INamespaceOrTypeSymbol : Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        bool IsNamespace { get; }
        bool IsType { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> GetMembers();
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> GetMembers(string name);
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.INamedTypeSymbol> GetTypeMembers();
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.INamedTypeSymbol> GetTypeMembers(string name);
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.INamedTypeSymbol> GetTypeMembers(string name, int arity);
    }
    public partial interface INamespaceSymbol : Microsoft.CodeAnalysis.INamespaceOrTypeSymbol, Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.INamespaceSymbol> ConstituentNamespaces { get; }
        Microsoft.CodeAnalysis.Compilation ContainingCompilation { get; }
        bool IsGlobalNamespace { get; }
        Microsoft.CodeAnalysis.NamespaceKind NamespaceKind { get; }
        new System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.INamespaceOrTypeSymbol> GetMembers();
        new System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.INamespaceOrTypeSymbol> GetMembers(string name);
        System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.INamespaceSymbol> GetNamespaceMembers();
    }
    public partial interface IOperation
    {
        Microsoft.CodeAnalysis.Optional<object> ConstantValue { get; }
        bool IsInvalid { get; }
        Microsoft.CodeAnalysis.OperationKind Kind { get; }
        Microsoft.CodeAnalysis.SyntaxNode Syntax { get; }
        Microsoft.CodeAnalysis.ITypeSymbol Type { get; }
        void Accept(Microsoft.CodeAnalysis.Semantics.OperationVisitor visitor);
        TResult Accept<TArgument, TResult>(Microsoft.CodeAnalysis.Semantics.OperationVisitor<TArgument, TResult> visitor, TArgument argument);
    }
    public partial interface IParameterSymbol : Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CustomModifier> CustomModifiers { get; }
        object ExplicitDefaultValue { get; }
        bool HasExplicitDefaultValue { get; }
        bool IsOptional { get; }
        bool IsParams { get; }
        bool IsThis { get; }
        int Ordinal { get; }
        new Microsoft.CodeAnalysis.IParameterSymbol OriginalDefinition { get; }
        Microsoft.CodeAnalysis.RefKind RefKind { get; }
        Microsoft.CodeAnalysis.ITypeSymbol Type { get; }
    }
    public partial interface IPointerTypeSymbol : Microsoft.CodeAnalysis.INamespaceOrTypeSymbol, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.ITypeSymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CustomModifier> CustomModifiers { get; }
        Microsoft.CodeAnalysis.ITypeSymbol PointedAtType { get; }
    }
    public partial interface IPreprocessingSymbol : Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
    }
    public partial interface IPropertySymbol : Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IPropertySymbol> ExplicitInterfaceImplementations { get; }
        Microsoft.CodeAnalysis.IMethodSymbol GetMethod { get; }
        bool IsIndexer { get; }
        bool IsReadOnly { get; }
        bool IsWithEvents { get; }
        bool IsWriteOnly { get; }
        new Microsoft.CodeAnalysis.IPropertySymbol OriginalDefinition { get; }
        Microsoft.CodeAnalysis.IPropertySymbol OverriddenProperty { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IParameterSymbol> Parameters { get; }
        Microsoft.CodeAnalysis.IMethodSymbol SetMethod { get; }
        Microsoft.CodeAnalysis.ITypeSymbol Type { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CustomModifier> TypeCustomModifiers { get; }
    }
    public partial interface IRangeVariableSymbol : Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
    }
    public partial interface ISkippedTokensTriviaSyntax
    {
        Microsoft.CodeAnalysis.SyntaxTokenList Tokens { get; }
    }
    public partial interface ISourceAssemblySymbol : Microsoft.CodeAnalysis.IAssemblySymbol, Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        Microsoft.CodeAnalysis.Compilation Compilation { get; }
    }
    public partial interface IStructuredTriviaSyntax
    {
        Microsoft.CodeAnalysis.SyntaxTrivia ParentTrivia { get; }
    }
    public partial interface ISymbol : System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        bool CanBeReferencedByName { get; }
        Microsoft.CodeAnalysis.IAssemblySymbol ContainingAssembly { get; }
        Microsoft.CodeAnalysis.IModuleSymbol ContainingModule { get; }
        Microsoft.CodeAnalysis.INamespaceSymbol ContainingNamespace { get; }
        Microsoft.CodeAnalysis.ISymbol ContainingSymbol { get; }
        Microsoft.CodeAnalysis.INamedTypeSymbol ContainingType { get; }
        Microsoft.CodeAnalysis.Accessibility DeclaredAccessibility { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SyntaxReference> DeclaringSyntaxReferences { get; }
        bool HasUnsupportedMetadata { get; }
        bool IsAbstract { get; }
        bool IsDefinition { get; }
        bool IsExtern { get; }
        bool IsImplicitlyDeclared { get; }
        bool IsOverride { get; }
        bool IsSealed { get; }
        bool IsStatic { get; }
        bool IsVirtual { get; }
        Microsoft.CodeAnalysis.SymbolKind Kind { get; }
        string Language { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Location> Locations { get; }
        string MetadataName { get; }
        string Name { get; }
        Microsoft.CodeAnalysis.ISymbol OriginalDefinition { get; }
        void Accept(Microsoft.CodeAnalysis.SymbolVisitor visitor);
        TResult Accept<TResult>(Microsoft.CodeAnalysis.SymbolVisitor<TResult> visitor);
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.AttributeData> GetAttributes();
        string GetDocumentationCommentId();
        string GetDocumentationCommentXml(System.Globalization.CultureInfo preferredCulture=null, bool expandIncludes=false, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SymbolDisplayPart> ToDisplayParts(Microsoft.CodeAnalysis.SymbolDisplayFormat format=null);
        string ToDisplayString(Microsoft.CodeAnalysis.SymbolDisplayFormat format=null);
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SymbolDisplayPart> ToMinimalDisplayParts(Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SymbolDisplayFormat format=null);
        string ToMinimalDisplayString(Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SymbolDisplayFormat format=null);
    }
    public static partial class ISymbolExtensions
    {
        public static Microsoft.CodeAnalysis.IMethodSymbol GetConstructedReducedFrom(this Microsoft.CodeAnalysis.IMethodSymbol method) { throw null; }
    }
    public partial interface ITypeParameterSymbol : Microsoft.CodeAnalysis.INamespaceOrTypeSymbol, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.ITypeSymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ITypeSymbol> ConstraintTypes { get; }
        Microsoft.CodeAnalysis.IMethodSymbol DeclaringMethod { get; }
        Microsoft.CodeAnalysis.INamedTypeSymbol DeclaringType { get; }
        bool HasConstructorConstraint { get; }
        bool HasReferenceTypeConstraint { get; }
        bool HasValueTypeConstraint { get; }
        int Ordinal { get; }
        new Microsoft.CodeAnalysis.ITypeParameterSymbol OriginalDefinition { get; }
        Microsoft.CodeAnalysis.ITypeParameterSymbol ReducedFrom { get; }
        Microsoft.CodeAnalysis.TypeParameterKind TypeParameterKind { get; }
        Microsoft.CodeAnalysis.VarianceKind Variance { get; }
    }
    public partial interface ITypeSymbol : Microsoft.CodeAnalysis.INamespaceOrTypeSymbol, Microsoft.CodeAnalysis.ISymbol, System.IEquatable<Microsoft.CodeAnalysis.ISymbol>
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.INamedTypeSymbol> AllInterfaces { get; }
        Microsoft.CodeAnalysis.INamedTypeSymbol BaseType { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.INamedTypeSymbol> Interfaces { get; }
        bool IsAnonymousType { get; }
        bool IsReferenceType { get; }
        bool IsValueType { get; }
        new Microsoft.CodeAnalysis.ITypeSymbol OriginalDefinition { get; }
        Microsoft.CodeAnalysis.SpecialType SpecialType { get; }
        Microsoft.CodeAnalysis.TypeKind TypeKind { get; }
        Microsoft.CodeAnalysis.ISymbol FindImplementationForInterfaceMember(Microsoft.CodeAnalysis.ISymbol interfaceMember);
    }
    public static partial class LanguageNames
    {
        public const string CSharp = "C#";
        public const string VisualBasic = "Visual Basic";
    }
    public enum LineVisibility
    {
        BeforeFirstLineDirective = 0,
        Hidden = 1,
        Visible = 2,
    }
    public sealed partial class LocalizableResourceString : Microsoft.CodeAnalysis.LocalizableString
    {
        public LocalizableResourceString(string nameOfLocalizableResource, System.Resources.ResourceManager resourceManager, System.Type resourceSource) { }
        public LocalizableResourceString(string nameOfLocalizableResource, System.Resources.ResourceManager resourceManager, System.Type resourceSource, params string[] formatArguments) { }
        protected override bool AreEqual(object other) { throw null; }
        protected override int GetHash() { throw null; }
        protected override string GetText(System.IFormatProvider formatProvider) { throw null; }
    }
    public abstract partial class LocalizableString : System.IEquatable<Microsoft.CodeAnalysis.LocalizableString>, System.IFormattable
    {
        protected LocalizableString() { }
        public event System.EventHandler<System.Exception> OnException { add { } remove { } }
        protected abstract bool AreEqual(object other);
        public bool Equals(Microsoft.CodeAnalysis.LocalizableString other) { throw null; }
        public sealed override bool Equals(object other) { throw null; }
        protected abstract int GetHash();
        public sealed override int GetHashCode() { throw null; }
        protected abstract string GetText(System.IFormatProvider formatProvider);
        public static explicit operator string (Microsoft.CodeAnalysis.LocalizableString localizableResource) { throw null; }
        public static implicit operator Microsoft.CodeAnalysis.LocalizableString (string fixedResource) { throw null; }
        string System.IFormattable.ToString(string ignored, System.IFormatProvider formatProvider) { throw null; }
        public sealed override string ToString() { throw null; }
        public string ToString(System.IFormatProvider formatProvider) { throw null; }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
    public abstract partial class Location
    {
        internal Location() { }
        public bool IsInMetadata { get { throw null; } }
        public bool IsInSource { get { throw null; } }
        public abstract Microsoft.CodeAnalysis.LocationKind Kind { get; }
        public virtual Microsoft.CodeAnalysis.IModuleSymbol MetadataModule { get { throw null; } }
        public static Microsoft.CodeAnalysis.Location None { get { throw null; } }
        public virtual Microsoft.CodeAnalysis.Text.TextSpan SourceSpan { get { throw null; } }
        public virtual Microsoft.CodeAnalysis.SyntaxTree SourceTree { get { throw null; } }
        public static Microsoft.CodeAnalysis.Location Create(Microsoft.CodeAnalysis.SyntaxTree syntaxTree, Microsoft.CodeAnalysis.Text.TextSpan textSpan) { throw null; }
        public static Microsoft.CodeAnalysis.Location Create(string filePath, Microsoft.CodeAnalysis.Text.TextSpan textSpan, Microsoft.CodeAnalysis.Text.LinePositionSpan lineSpan) { throw null; }
        public abstract override bool Equals(object obj);
        protected virtual string GetDebuggerDisplay() { throw null; }
        public abstract override int GetHashCode();
        public virtual Microsoft.CodeAnalysis.FileLinePositionSpan GetLineSpan() { throw null; }
        public virtual Microsoft.CodeAnalysis.FileLinePositionSpan GetMappedLineSpan() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.Location left, Microsoft.CodeAnalysis.Location right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.Location left, Microsoft.CodeAnalysis.Location right) { throw null; }
        public override string ToString() { throw null; }
    }
    public enum LocationKind : byte
    {
        ExternalFile = (byte)4,
        MetadataFile = (byte)2,
        None = (byte)0,
        SourceFile = (byte)1,
        XmlFile = (byte)3,
    }
    public abstract partial class Metadata : System.IDisposable
    {
        internal Metadata() { }
        public Microsoft.CodeAnalysis.MetadataId Id { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public abstract Microsoft.CodeAnalysis.MetadataImageKind Kind { get; }
        protected abstract Microsoft.CodeAnalysis.Metadata CommonCopy();
        public Microsoft.CodeAnalysis.Metadata Copy() { throw null; }
        public abstract void Dispose();
    }
    public sealed partial class MetadataId
    {
        internal MetadataId() { }
    }
    public enum MetadataImageKind : byte
    {
        Assembly = (byte)0,
        Module = (byte)1,
    }
    public abstract partial class MetadataReference
    {
        protected MetadataReference(Microsoft.CodeAnalysis.MetadataReferenceProperties properties) { }
        public virtual string Display { get { throw null; } }
        public Microsoft.CodeAnalysis.MetadataReferenceProperties Properties { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
        [System.ObsoleteAttribute("Use CreateFromFile(assembly.Location) instead", true)]
        public static Microsoft.CodeAnalysis.MetadataReference CreateFromAssembly(System.Reflection.Assembly assembly) { throw null; }
        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
        [System.ObsoleteAttribute("Use CreateFromFile(assembly.Location) instead", true)]
        public static Microsoft.CodeAnalysis.MetadataReference CreateFromAssembly(System.Reflection.Assembly assembly, Microsoft.CodeAnalysis.MetadataReferenceProperties properties, Microsoft.CodeAnalysis.DocumentationProvider documentation=null) { throw null; }
        public static Microsoft.CodeAnalysis.PortableExecutableReference CreateFromFile(string path, Microsoft.CodeAnalysis.MetadataReferenceProperties properties=default(Microsoft.CodeAnalysis.MetadataReferenceProperties), Microsoft.CodeAnalysis.DocumentationProvider documentation=null) { throw null; }
        public static Microsoft.CodeAnalysis.PortableExecutableReference CreateFromImage(System.Collections.Generic.IEnumerable<byte> peImage, Microsoft.CodeAnalysis.MetadataReferenceProperties properties=default(Microsoft.CodeAnalysis.MetadataReferenceProperties), Microsoft.CodeAnalysis.DocumentationProvider documentation=null, string filePath=null) { throw null; }
        public static Microsoft.CodeAnalysis.PortableExecutableReference CreateFromImage(System.Collections.Immutable.ImmutableArray<byte> peImage, Microsoft.CodeAnalysis.MetadataReferenceProperties properties=default(Microsoft.CodeAnalysis.MetadataReferenceProperties), Microsoft.CodeAnalysis.DocumentationProvider documentation=null, string filePath=null) { throw null; }
        public static Microsoft.CodeAnalysis.PortableExecutableReference CreateFromStream(System.IO.Stream peStream, Microsoft.CodeAnalysis.MetadataReferenceProperties properties=default(Microsoft.CodeAnalysis.MetadataReferenceProperties), Microsoft.CodeAnalysis.DocumentationProvider documentation=null, string filePath=null) { throw null; }
        public Microsoft.CodeAnalysis.MetadataReference WithAliases(System.Collections.Generic.IEnumerable<string> aliases) { throw null; }
        public Microsoft.CodeAnalysis.MetadataReference WithAliases(System.Collections.Immutable.ImmutableArray<string> aliases) { throw null; }
        public Microsoft.CodeAnalysis.MetadataReference WithEmbedInteropTypes(bool value) { throw null; }
        public Microsoft.CodeAnalysis.MetadataReference WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties properties) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct MetadataReferenceProperties : System.IEquatable<Microsoft.CodeAnalysis.MetadataReferenceProperties>
    {
        public MetadataReferenceProperties(Microsoft.CodeAnalysis.MetadataImageKind kind=(Microsoft.CodeAnalysis.MetadataImageKind)(0), System.Collections.Immutable.ImmutableArray<string> aliases=default(System.Collections.Immutable.ImmutableArray<string>), bool embedInteropTypes=false) { throw null;}
        public System.Collections.Immutable.ImmutableArray<string> Aliases { get { throw null; } }
        public static Microsoft.CodeAnalysis.MetadataReferenceProperties Assembly { get { throw null; } }
        public bool EmbedInteropTypes { get { throw null; } }
        public static string GlobalAlias { get { throw null; } }
        public Microsoft.CodeAnalysis.MetadataImageKind Kind { get { throw null; } }
        public static Microsoft.CodeAnalysis.MetadataReferenceProperties Module { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.MetadataReferenceProperties other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.MetadataReferenceProperties left, Microsoft.CodeAnalysis.MetadataReferenceProperties right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.MetadataReferenceProperties left, Microsoft.CodeAnalysis.MetadataReferenceProperties right) { throw null; }
        public Microsoft.CodeAnalysis.MetadataReferenceProperties WithAliases(System.Collections.Generic.IEnumerable<string> aliases) { throw null; }
        public Microsoft.CodeAnalysis.MetadataReferenceProperties WithAliases(System.Collections.Immutable.ImmutableArray<string> aliases) { throw null; }
        public Microsoft.CodeAnalysis.MetadataReferenceProperties WithEmbedInteropTypes(bool embedInteropTypes) { throw null; }
    }
    public abstract partial class MetadataReferenceResolver
    {
        protected MetadataReferenceResolver() { }
        public virtual bool ResolveMissingAssemblies { get { throw null; } }
        public abstract override bool Equals(object other);
        public abstract override int GetHashCode();
        public virtual Microsoft.CodeAnalysis.PortableExecutableReference ResolveMissingAssembly(Microsoft.CodeAnalysis.MetadataReference definition, Microsoft.CodeAnalysis.AssemblyIdentity referenceIdentity) { throw null; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.PortableExecutableReference> ResolveReference(string reference, string baseFilePath, Microsoft.CodeAnalysis.MetadataReferenceProperties properties);
    }
    public enum MethodKind
    {
        AnonymousFunction = 0,
        BuiltinOperator = 15,
        Constructor = 1,
        Conversion = 2,
        DeclareMethod = 16,
        DelegateInvoke = 3,
        Destructor = 4,
        EventAdd = 5,
        EventRaise = 6,
        EventRemove = 7,
        ExplicitInterfaceImplementation = 8,
        LambdaMethod = 0,
        Ordinary = 10,
        PropertyGet = 11,
        PropertySet = 12,
        ReducedExtension = 13,
        SharedConstructor = 14,
        StaticConstructor = 14,
        UserDefinedOperator = 9,
    }
    public static partial class ModelExtensions
    {
        public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode statement) { throw null; }
        public static Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlow(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode firstStatement, Microsoft.CodeAnalysis.SyntaxNode lastStatement) { throw null; }
        public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode statementOrExpression) { throw null; }
        public static Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlow(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode firstStatement, Microsoft.CodeAnalysis.SyntaxNode lastStatement) { throw null; }
        public static Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode nameSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode declaration, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> GetMemberGroup(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SyntaxNode nameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SyntaxNode expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) { throw null; }
        public static Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SyntaxNode expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(this Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
    }
    public sealed partial class ModuleMetadata : Microsoft.CodeAnalysis.Metadata
    {
        internal ModuleMetadata() { }
        public override Microsoft.CodeAnalysis.MetadataImageKind Kind { get { throw null; } }
        public string Name { get { throw null; } }
        protected override Microsoft.CodeAnalysis.Metadata CommonCopy() { throw null; }
        public static Microsoft.CodeAnalysis.ModuleMetadata CreateFromFile(string path) { throw null; }
        public static Microsoft.CodeAnalysis.ModuleMetadata CreateFromImage(System.Collections.Generic.IEnumerable<byte> peImage) { throw null; }
        public static Microsoft.CodeAnalysis.ModuleMetadata CreateFromImage(System.Collections.Immutable.ImmutableArray<byte> peImage) { throw null; }
        public static Microsoft.CodeAnalysis.ModuleMetadata CreateFromImage(System.IntPtr peImage, int size) { throw null; }
        public static Microsoft.CodeAnalysis.ModuleMetadata CreateFromMetadata(System.IntPtr metadata, int size) { throw null; }
        public static Microsoft.CodeAnalysis.ModuleMetadata CreateFromStream(System.IO.Stream peStream, bool leaveOpen=false) { throw null; }
        public static Microsoft.CodeAnalysis.ModuleMetadata CreateFromStream(System.IO.Stream peStream, System.Reflection.PortableExecutable.PEStreamOptions options) { throw null; }
        public override void Dispose() { }
        public System.Reflection.Metadata.MetadataReader GetMetadataReader() { throw null; }
        public System.Collections.Immutable.ImmutableArray<string> GetModuleNames() { throw null; }
        public System.Guid GetModuleVersionId() { throw null; }
        public Microsoft.CodeAnalysis.PortableExecutableReference GetReference(Microsoft.CodeAnalysis.DocumentationProvider documentation=null, string filePath=null, string display=null) { throw null; }
    }
    public enum NamespaceKind
    {
        Assembly = 2,
        Compilation = 3,
        Module = 1,
    }
    public enum OperationKind
    {
        AddressOfExpression = 515,
        Argument = 1031,
        ArrayCreationExpression = 276,
        ArrayElementReferenceExpression = 260,
        ArrayInitializer = 1029,
        AssignmentExpression = 280,
        AwaitExpression = 279,
        BinaryOperatorExpression = 270,
        BlockStatement = 2,
        BranchStatement = 8,
        CatchClause = 1032,
        CompoundAssignmentExpression = 281,
        ConditionalAccessExpression = 284,
        ConditionalAccessInstanceExpression = 285,
        ConditionalChoiceExpression = 271,
        ConversionExpression = 258,
        DefaultValueExpression = 512,
        EmptyStatement = 9,
        EndStatement = 81,
        EventAssignmentExpression = 283,
        EventReferenceExpression = 268,
        ExpressionStatement = 17,
        FieldInitializerAtDeclaration = 1025,
        FieldInitializerInCreation = 1024,
        FieldReferenceExpression = 264,
        FixedStatement = 48,
        IfStatement = 5,
        IncrementExpression = 518,
        IndexedPropertyReferenceExpression = 267,
        InstanceReferenceExpression = 277,
        InvalidExpression = 256,
        InvalidStatement = 1,
        InvocationExpression = 259,
        IsTypeExpression = 278,
        LabelStatement = 7,
        LambdaExpression = 273,
        LateBoundMemberReferenceExpression = 769,
        LiteralExpression = 257,
        LocalReferenceExpression = 261,
        LockStatement = 13,
        LoopStatement = 6,
        MethodBindingExpression = 265,
        None = 0,
        NullCoalescingExpression = 272,
        ObjectCreationExpression = 274,
        OmittedArgumentExpression = 768,
        ParameterInitializerAtDeclaration = 1028,
        ParameterReferenceExpression = 262,
        ParenthesizedExpression = 282,
        PlaceholderExpression = 770,
        PointerIndirectionReferenceExpression = 516,
        PropertyInitializerAtDeclaration = 1027,
        PropertyInitializerInCreation = 1026,
        PropertyReferenceExpression = 266,
        RangeCaseClause = 1036,
        RelationalCaseClause = 1035,
        ReturnStatement = 11,
        SingleValueCaseClause = 1034,
        SizeOfExpression = 514,
        StopStatement = 80,
        SwitchCase = 1033,
        SwitchStatement = 4,
        SyntheticLocalReferenceExpression = 263,
        ThrowStatement = 10,
        TryStatement = 14,
        TypeOfExpression = 513,
        TypeParameterObjectCreationExpression = 275,
        UnaryOperatorExpression = 269,
        UnboundLambdaExpression = 517,
        UsingStatement = 15,
        VariableDeclaration = 1030,
        VariableDeclarationStatement = 3,
        WithStatement = 82,
        YieldBreakStatement = 12,
        YieldReturnStatement = 16,
    }
    public enum OptimizationLevel
    {
        Debug = 0,
        Release = 1,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Optional<T>
    {
        public Optional(T value) { throw null;}
        public bool HasValue { get { throw null; } }
        public T Value { get { throw null; } }
        public static implicit operator Microsoft.CodeAnalysis.Optional<T> (T value) { throw null; }
    }
    public enum OutputKind
    {
        ConsoleApplication = 0,
        DynamicallyLinkedLibrary = 2,
        NetModule = 3,
        WindowsApplication = 1,
        WindowsRuntimeApplication = 5,
        WindowsRuntimeMetadata = 4,
    }
    public abstract partial class ParseOptions
    {
        internal ParseOptions() { }
        public Microsoft.CodeAnalysis.DocumentationMode DocumentationMode { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public abstract System.Collections.Generic.IReadOnlyDictionary<string, string> Features { get; }
        public Microsoft.CodeAnalysis.SourceCodeKind Kind { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]protected set { } }
        public abstract System.Collections.Generic.IEnumerable<string> PreprocessorSymbolNames { get; }
        protected abstract Microsoft.CodeAnalysis.ParseOptions CommonWithDocumentationMode(Microsoft.CodeAnalysis.DocumentationMode documentationMode);
        protected abstract Microsoft.CodeAnalysis.ParseOptions CommonWithFeatures(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> features);
        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
        public abstract Microsoft.CodeAnalysis.ParseOptions CommonWithKind(Microsoft.CodeAnalysis.SourceCodeKind kind);
        public abstract override bool Equals(object obj);
        protected bool EqualsHelper(Microsoft.CodeAnalysis.ParseOptions other) { throw null; }
        public abstract override int GetHashCode();
        protected int GetHashCodeHelper() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.ParseOptions left, Microsoft.CodeAnalysis.ParseOptions right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.ParseOptions left, Microsoft.CodeAnalysis.ParseOptions right) { throw null; }
        public Microsoft.CodeAnalysis.ParseOptions WithDocumentationMode(Microsoft.CodeAnalysis.DocumentationMode documentationMode) { throw null; }
        public Microsoft.CodeAnalysis.ParseOptions WithFeatures(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> features) { throw null; }
        public Microsoft.CodeAnalysis.ParseOptions WithKind(Microsoft.CodeAnalysis.SourceCodeKind kind) { throw null; }
    }
    public enum Platform
    {
        AnyCpu = 0,
        AnyCpu32BitPreferred = 4,
        Arm = 5,
        Itanium = 3,
        X64 = 2,
        X86 = 1,
    }
    public abstract partial class PortableExecutableReference : Microsoft.CodeAnalysis.MetadataReference
    {
        protected PortableExecutableReference(Microsoft.CodeAnalysis.MetadataReferenceProperties properties, string fullPath=null, Microsoft.CodeAnalysis.DocumentationProvider initialDocumentation=null) : base (default(Microsoft.CodeAnalysis.MetadataReferenceProperties)) { }
        public override string Display { get { throw null; } }
        public string FilePath { get { throw null; } }
        protected abstract Microsoft.CodeAnalysis.DocumentationProvider CreateDocumentationProvider();
        public Microsoft.CodeAnalysis.Metadata GetMetadata() { throw null; }
        protected abstract Microsoft.CodeAnalysis.Metadata GetMetadataImpl();
        public new Microsoft.CodeAnalysis.PortableExecutableReference WithAliases(System.Collections.Generic.IEnumerable<string> aliases) { throw null; }
        public new Microsoft.CodeAnalysis.PortableExecutableReference WithAliases(System.Collections.Immutable.ImmutableArray<string> aliases) { throw null; }
        public new Microsoft.CodeAnalysis.PortableExecutableReference WithEmbedInteropTypes(bool value) { throw null; }
        public new Microsoft.CodeAnalysis.PortableExecutableReference WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties properties) { throw null; }
        protected abstract Microsoft.CodeAnalysis.PortableExecutableReference WithPropertiesImpl(Microsoft.CodeAnalysis.MetadataReferenceProperties properties);
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct PreprocessingSymbolInfo : System.IEquatable<Microsoft.CodeAnalysis.PreprocessingSymbolInfo>
    {
        public bool IsDefined { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.IPreprocessingSymbol Symbol { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.PreprocessingSymbolInfo other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    public enum RefKind : byte
    {
        None = (byte)0,
        Out = (byte)2,
        Ref = (byte)1,
    }
    public enum ReportDiagnostic
    {
        Default = 0,
        Error = 1,
        Hidden = 4,
        Info = 3,
        Suppress = 5,
        Warn = 2,
    }
    public sealed partial class ResourceDescription
    {
        public ResourceDescription(string resourceName, System.Func<System.IO.Stream> dataProvider, bool isPublic) { }
        public ResourceDescription(string resourceName, string fileName, System.Func<System.IO.Stream> dataProvider, bool isPublic) { }
    }
    public partial class RuleSet
    {
        public RuleSet(string filePath, Microsoft.CodeAnalysis.ReportDiagnostic generalOption, System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic> specificOptions, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.RuleSetInclude> includes) { }
        public string FilePath { get { throw null; } }
        public Microsoft.CodeAnalysis.ReportDiagnostic GeneralDiagnosticOption { get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.RuleSetInclude> Includes { get { throw null; } }
        public System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic> SpecificDiagnosticOptions { get { throw null; } }
        public static Microsoft.CodeAnalysis.ReportDiagnostic GetDiagnosticOptionsFromRulesetFile(string rulesetFileFullPath, out System.Collections.Generic.Dictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic> specificDiagnosticOptions) { specificDiagnosticOptions = default(System.Collections.Generic.Dictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic>); throw null; }
        public static System.Collections.Immutable.ImmutableArray<string> GetEffectiveIncludesFromFile(string filePath) { throw null; }
        public static Microsoft.CodeAnalysis.RuleSet LoadEffectiveRuleSetFromFile(string filePath) { throw null; }
        public Microsoft.CodeAnalysis.RuleSet WithEffectiveAction(Microsoft.CodeAnalysis.ReportDiagnostic action) { throw null; }
    }
    public partial class RuleSetInclude
    {
        public RuleSetInclude(string includePath, Microsoft.CodeAnalysis.ReportDiagnostic action) { }
        public Microsoft.CodeAnalysis.ReportDiagnostic Action { get { throw null; } }
        public string IncludePath { get { throw null; } }
        public Microsoft.CodeAnalysis.RuleSet LoadRuleSet(Microsoft.CodeAnalysis.RuleSet parent) { throw null; }
    }
    public abstract partial class ScriptCompilationInfo
    {
        internal ScriptCompilationInfo() { }
        public System.Type GlobalsType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.Compilation PreviousScriptCompilation { get { throw null; } }
        public System.Type ReturnType { get { throw null; } }
        public Microsoft.CodeAnalysis.ScriptCompilationInfo WithPreviousScriptCompilation(Microsoft.CodeAnalysis.Compilation compilation) { throw null; }
    }
    public abstract partial class SemanticModel
    {
        protected SemanticModel() { }
        public Microsoft.CodeAnalysis.Compilation Compilation { get { throw null; } }
        protected abstract Microsoft.CodeAnalysis.Compilation CompilationCore { get; }
        public virtual bool IgnoresAccessibility { get { throw null; } }
        public abstract bool IsSpeculativeSemanticModel { get; }
        public abstract string Language { get; }
        public abstract int OriginalPositionForSpeculation { get; }
        public Microsoft.CodeAnalysis.SemanticModel ParentModel { get { throw null; } }
        protected abstract Microsoft.CodeAnalysis.SemanticModel ParentModelCore { get; }
        public Microsoft.CodeAnalysis.SyntaxTree SyntaxTree { get { throw null; } }
        protected abstract Microsoft.CodeAnalysis.SyntaxTree SyntaxTreeCore { get; }
        protected abstract Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlowCore(Microsoft.CodeAnalysis.SyntaxNode statement);
        protected abstract Microsoft.CodeAnalysis.ControlFlowAnalysis AnalyzeControlFlowCore(Microsoft.CodeAnalysis.SyntaxNode firstStatement, Microsoft.CodeAnalysis.SyntaxNode lastStatement);
        protected abstract Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlowCore(Microsoft.CodeAnalysis.SyntaxNode statementOrExpression);
        protected abstract Microsoft.CodeAnalysis.DataFlowAnalysis AnalyzeDataFlowCore(Microsoft.CodeAnalysis.SyntaxNode firstStatement, Microsoft.CodeAnalysis.SyntaxNode lastStatement);
        protected abstract Microsoft.CodeAnalysis.IAliasSymbol GetAliasInfoCore(Microsoft.CodeAnalysis.SyntaxNode nameSyntax, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public Microsoft.CodeAnalysis.Optional<object> GetConstantValue(Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        protected abstract Microsoft.CodeAnalysis.Optional<object> GetConstantValueCore(Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetDeclarationDiagnostics(System.Nullable<Microsoft.CodeAnalysis.Text.TextSpan> span=default(System.Nullable<Microsoft.CodeAnalysis.Text.TextSpan>), System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        protected abstract Microsoft.CodeAnalysis.ISymbol GetDeclaredSymbolCore(Microsoft.CodeAnalysis.SyntaxNode declaration, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        protected abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> GetDeclaredSymbolsCore(Microsoft.CodeAnalysis.SyntaxNode declaration, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(System.Nullable<Microsoft.CodeAnalysis.Text.TextSpan> span=default(System.Nullable<Microsoft.CodeAnalysis.Text.TextSpan>), System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public Microsoft.CodeAnalysis.ISymbol GetEnclosingSymbol(int position, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        protected abstract Microsoft.CodeAnalysis.ISymbol GetEnclosingSymbolCore(int position, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        protected abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> GetMemberGroupCore(Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetMethodBodyDiagnostics(System.Nullable<Microsoft.CodeAnalysis.Text.TextSpan> span=default(System.Nullable<Microsoft.CodeAnalysis.Text.TextSpan>), System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public Microsoft.CodeAnalysis.IOperation GetOperation(Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        protected abstract Microsoft.CodeAnalysis.IOperation GetOperationCore(Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken);
        public Microsoft.CodeAnalysis.PreprocessingSymbolInfo GetPreprocessingSymbolInfo(Microsoft.CodeAnalysis.SyntaxNode nameSyntax) { throw null; }
        protected abstract Microsoft.CodeAnalysis.PreprocessingSymbolInfo GetPreprocessingSymbolInfoCore(Microsoft.CodeAnalysis.SyntaxNode nameSyntax);
        protected abstract Microsoft.CodeAnalysis.IAliasSymbol GetSpeculativeAliasInfoCore(int position, Microsoft.CodeAnalysis.SyntaxNode nameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);
        protected abstract Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfoCore(int position, Microsoft.CodeAnalysis.SyntaxNode expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);
        protected abstract Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfoCore(int position, Microsoft.CodeAnalysis.SyntaxNode expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption);
        protected abstract Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfoCore(Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetSyntaxDiagnostics(System.Nullable<Microsoft.CodeAnalysis.Text.TextSpan> span=default(System.Nullable<Microsoft.CodeAnalysis.Text.TextSpan>), System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        protected internal virtual Microsoft.CodeAnalysis.SyntaxNode GetTopmostNodeForDiagnosticAnalysis(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SyntaxNode declaringSyntax) { throw null; }
        protected abstract Microsoft.CodeAnalysis.TypeInfo GetTypeInfoCore(Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public bool IsAccessible(int position, Microsoft.CodeAnalysis.ISymbol symbol) { throw null; }
        protected abstract bool IsAccessibleCore(int position, Microsoft.CodeAnalysis.ISymbol symbol);
        public bool IsEventUsableAsField(int position, Microsoft.CodeAnalysis.IEventSymbol eventSymbol) { throw null; }
        protected abstract bool IsEventUsableAsFieldCore(int position, Microsoft.CodeAnalysis.IEventSymbol eventSymbol);
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> LookupBaseMembers(int position, string name=null) { throw null; }
        protected abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> LookupBaseMembersCore(int position, string name);
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> LookupLabels(int position, string name=null) { throw null; }
        protected abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> LookupLabelsCore(int position, string name);
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> LookupNamespacesAndTypes(int position, Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container=null, string name=null) { throw null; }
        protected abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> LookupNamespacesAndTypesCore(int position, Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name);
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> LookupStaticMembers(int position, Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container=null, string name=null) { throw null; }
        protected abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> LookupStaticMembersCore(int position, Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name);
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> LookupSymbols(int position, Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container=null, string name=null, bool includeReducedExtensionMethods=false) { throw null; }
        protected abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> LookupSymbolsCore(int position, Microsoft.CodeAnalysis.INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods);
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct SeparatedSyntaxList<TNode> : System.Collections.Generic.IEnumerable<TNode>, System.Collections.Generic.IReadOnlyCollection<TNode>, System.Collections.Generic.IReadOnlyList<TNode>, System.Collections.IEnumerable, System.IEquatable<Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode>> where TNode : Microsoft.CodeAnalysis.SyntaxNode
    {
        public int Count { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan FullSpan { get { throw null; } }
        public TNode this[int index] { get { throw null; } }
        public int SeparatorCount { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan Span { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> Add(TNode node) { throw null; }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> AddRange(System.Collections.Generic.IEnumerable<TNode> nodes) { throw null; }
        public bool Any() { throw null; }
        public bool Contains(TNode node) { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public TNode First() { throw null; }
        public TNode FirstOrDefault() { throw null; }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode>.Enumerator GetEnumerator() { throw null; }
        public override int GetHashCode() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken GetSeparator(int index) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> GetSeparators() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList GetWithSeparators() { throw null; }
        public int IndexOf(System.Func<TNode, bool> predicate) { throw null; }
        public int IndexOf(TNode node) { throw null; }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> Insert(int index, TNode node) { throw null; }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> InsertRange(int index, System.Collections.Generic.IEnumerable<TNode> nodes) { throw null; }
        public TNode Last() { throw null; }
        public int LastIndexOf(System.Func<TNode, bool> predicate) { throw null; }
        public int LastIndexOf(TNode node) { throw null; }
        public TNode LastOrDefault() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> left, Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> left, Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> right) { throw null; }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> Remove(TNode node) { throw null; }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> RemoveAt(int index) { throw null; }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> Replace(TNode nodeInList, TNode newNode) { throw null; }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> ReplaceRange(TNode nodeInList, System.Collections.Generic.IEnumerable<TNode> newNodes) { throw null; }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> ReplaceSeparator(Microsoft.CodeAnalysis.SyntaxToken separatorToken, Microsoft.CodeAnalysis.SyntaxToken newSeparator) { throw null; }
        System.Collections.Generic.IEnumerator<TNode> System.Collections.Generic.IEnumerable<TNode>.GetEnumerator() { throw null; }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
        public string ToFullString() { throw null; }
        public override string ToString() { throw null; }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public partial struct Enumerator
        {
            public TNode Current { get { throw null; } }
            public override bool Equals(object obj) { throw null; }
            public override int GetHashCode() { throw null; }
            public bool MoveNext() { throw null; }
            public void Reset() { }
        }
    }
    public enum SourceCodeKind
    {
        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
        [System.ObsoleteAttribute("Use Script instead", false)]
        Interactive = 2,
        Regular = 0,
        Script = 1,
    }
    public partial class SourceFileResolver : Microsoft.CodeAnalysis.SourceReferenceResolver, System.IEquatable<Microsoft.CodeAnalysis.SourceFileResolver>
    {
        public SourceFileResolver(System.Collections.Generic.IEnumerable<string> searchPaths, string baseDirectory) { }
        public SourceFileResolver(System.Collections.Immutable.ImmutableArray<string> searchPaths, string baseDirectory) { }
        public SourceFileResolver(System.Collections.Immutable.ImmutableArray<string> searchPaths, string baseDirectory, System.Collections.Immutable.ImmutableArray<System.Collections.Generic.KeyValuePair<string, string>> pathMap) { }
        public string BaseDirectory { get { throw null; } }
        public static Microsoft.CodeAnalysis.SourceFileResolver Default { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<System.Collections.Generic.KeyValuePair<string, string>> PathMap { get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<string> SearchPaths { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.SourceFileResolver other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        protected virtual bool FileExists(string resolvedPath) { throw null; }
        public override int GetHashCode() { throw null; }
        public override string NormalizePath(string path, string baseFilePath) { throw null; }
        public override System.IO.Stream OpenRead(string resolvedPath) { throw null; }
        public override string ResolveReference(string path, string baseFilePath) { throw null; }
    }
    public abstract partial class SourceReferenceResolver
    {
        protected SourceReferenceResolver() { }
        public abstract override bool Equals(object other);
        public abstract override int GetHashCode();
        public abstract string NormalizePath(string path, string baseFilePath);
        public abstract System.IO.Stream OpenRead(string resolvedPath);
        public virtual Microsoft.CodeAnalysis.Text.SourceText ReadText(string resolvedPath) { throw null; }
        public abstract string ResolveReference(string path, string baseFilePath);
    }
    public enum SpecialType : sbyte
    {
        Count = (sbyte)43,
        None = (sbyte)0,
        System_ArgIterator = (sbyte)37,
        System_Array = (sbyte)23,
        System_AsyncCallback = (sbyte)43,
        System_Boolean = (sbyte)7,
        System_Byte = (sbyte)10,
        System_Char = (sbyte)8,
        System_Collections_Generic_ICollection_T = (sbyte)27,
        System_Collections_Generic_IEnumerable_T = (sbyte)25,
        System_Collections_Generic_IEnumerator_T = (sbyte)29,
        System_Collections_Generic_IList_T = (sbyte)26,
        System_Collections_Generic_IReadOnlyCollection_T = (sbyte)31,
        System_Collections_Generic_IReadOnlyList_T = (sbyte)30,
        System_Collections_IEnumerable = (sbyte)24,
        System_Collections_IEnumerator = (sbyte)28,
        System_DateTime = (sbyte)33,
        System_Decimal = (sbyte)17,
        System_Delegate = (sbyte)4,
        System_Double = (sbyte)19,
        System_Enum = (sbyte)2,
        System_IAsyncResult = (sbyte)42,
        System_IDisposable = (sbyte)35,
        System_Int16 = (sbyte)11,
        System_Int32 = (sbyte)13,
        System_Int64 = (sbyte)15,
        System_IntPtr = (sbyte)21,
        System_MulticastDelegate = (sbyte)3,
        System_Nullable_T = (sbyte)32,
        System_Object = (sbyte)1,
        System_RuntimeArgumentHandle = (sbyte)38,
        System_RuntimeFieldHandle = (sbyte)39,
        System_RuntimeMethodHandle = (sbyte)40,
        System_RuntimeTypeHandle = (sbyte)41,
        System_Runtime_CompilerServices_IsVolatile = (sbyte)34,
        System_SByte = (sbyte)9,
        System_Single = (sbyte)18,
        System_String = (sbyte)20,
        System_TypedReference = (sbyte)36,
        System_UInt16 = (sbyte)12,
        System_UInt32 = (sbyte)14,
        System_UInt64 = (sbyte)16,
        System_UIntPtr = (sbyte)22,
        System_ValueType = (sbyte)5,
        System_Void = (sbyte)6,
    }
    public enum SpeculativeBindingOption
    {
        BindAsExpression = 0,
        BindAsTypeOrNamespace = 1,
    }
    public abstract partial class StrongNameProvider
    {
        protected StrongNameProvider() { }
        public abstract override bool Equals(object other);
        public abstract override int GetHashCode();
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct SubsystemVersion : System.IEquatable<Microsoft.CodeAnalysis.SubsystemVersion>
    {
        public bool IsValid { get { throw null; } }
        public int Major { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public int Minor { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SubsystemVersion None { get { throw null; } }
        public static Microsoft.CodeAnalysis.SubsystemVersion Windows2000 { get { throw null; } }
        public static Microsoft.CodeAnalysis.SubsystemVersion Windows7 { get { throw null; } }
        public static Microsoft.CodeAnalysis.SubsystemVersion Windows8 { get { throw null; } }
        public static Microsoft.CodeAnalysis.SubsystemVersion WindowsVista { get { throw null; } }
        public static Microsoft.CodeAnalysis.SubsystemVersion WindowsXP { get { throw null; } }
        public static Microsoft.CodeAnalysis.SubsystemVersion Create(int major, int minor) { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.SubsystemVersion other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public override string ToString() { throw null; }
        public static bool TryParse(string str, out Microsoft.CodeAnalysis.SubsystemVersion version) { version = default(Microsoft.CodeAnalysis.SubsystemVersion); throw null; }
    }
    public enum SymbolDisplayDelegateStyle
    {
        NameAndParameters = 1,
        NameAndSignature = 2,
        NameOnly = 0,
    }
    public enum SymbolDisplayExtensionMethodStyle
    {
        Default = 0,
        InstanceMethod = 1,
        StaticMethod = 2,
    }
    public static partial class SymbolDisplayExtensions
    {
        public static string ToDisplayString(this System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SymbolDisplayPart> parts) { throw null; }
    }
    public partial class SymbolDisplayFormat
    {
        public SymbolDisplayFormat(Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle globalNamespaceStyle=(Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle)(0), Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle typeQualificationStyle=(Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle)(0), Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions genericsOptions=(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions)(0), Microsoft.CodeAnalysis.SymbolDisplayMemberOptions memberOptions=(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)(0), Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle delegateStyle=(Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle)(0), Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle extensionMethodStyle=(Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle)(0), Microsoft.CodeAnalysis.SymbolDisplayParameterOptions parameterOptions=(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)(0), Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle propertyStyle=(Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle)(0), Microsoft.CodeAnalysis.SymbolDisplayLocalOptions localOptions=(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions)(0), Microsoft.CodeAnalysis.SymbolDisplayKindOptions kindOptions=(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)(0), Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions miscellaneousOptions=(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)(0)) { }
        public static Microsoft.CodeAnalysis.SymbolDisplayFormat CSharpErrorMessageFormat { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SymbolDisplayFormat CSharpShortErrorMessageFormat { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle DelegateStyle { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle ExtensionMethodStyle { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SymbolDisplayFormat FullyQualifiedFormat { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions GenericsOptions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle GlobalNamespaceStyle { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.SymbolDisplayKindOptions KindOptions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.SymbolDisplayLocalOptions LocalOptions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.SymbolDisplayMemberOptions MemberOptions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SymbolDisplayFormat MinimallyQualifiedFormat { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions MiscellaneousOptions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.SymbolDisplayParameterOptions ParameterOptions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle PropertyStyle { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle TypeQualificationStyle { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SymbolDisplayFormat VisualBasicErrorMessageFormat { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SymbolDisplayFormat VisualBasicShortErrorMessageFormat { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat AddGenericsOptions(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions options) { throw null; }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat AddKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions options) { throw null; }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat AddLocalOptions(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions options) { throw null; }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat AddMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions options) { throw null; }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat AddMiscellaneousOptions(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions options) { throw null; }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat AddParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions options) { throw null; }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat RemoveKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions options) { throw null; }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat RemoveMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions options) { throw null; }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat RemoveParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions options) { throw null; }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat WithGenericsOptions(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions options) { throw null; }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat WithGlobalNamespaceStyle(Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle style) { throw null; }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat WithKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions options) { throw null; }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat WithLocalOptions(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions options) { throw null; }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat WithMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions options) { throw null; }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat WithMiscellaneousOptions(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions options) { throw null; }
        public Microsoft.CodeAnalysis.SymbolDisplayFormat WithParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions options) { throw null; }
    }
    [System.FlagsAttribute]
    public enum SymbolDisplayGenericsOptions
    {
        IncludeTypeConstraints = 2,
        IncludeTypeParameters = 1,
        IncludeVariance = 4,
        None = 0,
    }
    public enum SymbolDisplayGlobalNamespaceStyle
    {
        Included = 2,
        Omitted = 0,
        OmittedAsContaining = 1,
    }
    [System.FlagsAttribute]
    public enum SymbolDisplayKindOptions
    {
        IncludeMemberKeyword = 4,
        IncludeNamespaceKeyword = 1,
        IncludeTypeKeyword = 2,
        None = 0,
    }
    [System.FlagsAttribute]
    public enum SymbolDisplayLocalOptions
    {
        IncludeConstantValue = 2,
        IncludeType = 1,
        None = 0,
    }
    [System.FlagsAttribute]
    public enum SymbolDisplayMemberOptions
    {
        IncludeAccessibility = 4,
        IncludeConstantValue = 64,
        IncludeContainingType = 32,
        IncludeExplicitInterface = 8,
        IncludeModifiers = 2,
        IncludeParameters = 16,
        IncludeType = 1,
        None = 0,
    }
    [System.FlagsAttribute]
    public enum SymbolDisplayMiscellaneousOptions
    {
        EscapeKeywordIdentifiers = 2,
        ExpandNullable = 32,
        None = 0,
        RemoveAttributeSuffix = 16,
        UseAsterisksInMultiDimensionalArrays = 4,
        UseErrorTypeSymbolName = 8,
        UseSpecialTypes = 1,
    }
    [System.FlagsAttribute]
    public enum SymbolDisplayParameterOptions
    {
        IncludeDefaultValue = 16,
        IncludeExtensionThis = 1,
        IncludeName = 8,
        IncludeOptionalBrackets = 32,
        IncludeParamsRefOut = 2,
        IncludeType = 4,
        None = 0,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct SymbolDisplayPart
    {
        public SymbolDisplayPart(Microsoft.CodeAnalysis.SymbolDisplayPartKind kind, Microsoft.CodeAnalysis.ISymbol symbol, string text) { throw null;}
        public Microsoft.CodeAnalysis.SymbolDisplayPartKind Kind { get { throw null; } }
        public Microsoft.CodeAnalysis.ISymbol Symbol { get { throw null; } }
        public override string ToString() { throw null; }
    }
    public enum SymbolDisplayPartKind
    {
        AliasName = 0,
        AnonymousTypeIndicator = 24,
        AssemblyName = 1,
        ClassName = 2,
        DelegateName = 3,
        EnumName = 4,
        ErrorTypeName = 5,
        EventName = 6,
        FieldName = 7,
        InterfaceName = 8,
        Keyword = 9,
        LabelName = 10,
        LineBreak = 11,
        LocalName = 14,
        MethodName = 15,
        ModuleName = 16,
        NamespaceName = 17,
        NumericLiteral = 12,
        Operator = 18,
        ParameterName = 19,
        PropertyName = 20,
        Punctuation = 21,
        RangeVariableName = 27,
        Space = 22,
        StringLiteral = 13,
        StructName = 23,
        Text = 25,
        TypeParameterName = 26,
    }
    public enum SymbolDisplayPropertyStyle
    {
        NameOnly = 0,
        ShowReadWriteDescriptor = 1,
    }
    public enum SymbolDisplayTypeQualificationStyle
    {
        NameAndContainingTypes = 1,
        NameAndContainingTypesAndNamespaces = 2,
        NameOnly = 0,
    }
    [System.FlagsAttribute]
    public enum SymbolFilter
    {
        All = 7,
        Member = 4,
        Namespace = 1,
        None = 0,
        Type = 2,
        TypeAndMember = 6,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct SymbolInfo : System.IEquatable<Microsoft.CodeAnalysis.SymbolInfo>
    {
        public Microsoft.CodeAnalysis.CandidateReason CandidateReason { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> CandidateSymbols { get { throw null; } }
        public Microsoft.CodeAnalysis.ISymbol Symbol { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.SymbolInfo other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    public enum SymbolKind
    {
        Alias = 0,
        ArrayType = 1,
        Assembly = 2,
        DynamicType = 3,
        ErrorType = 4,
        Event = 5,
        Field = 6,
        Label = 7,
        Local = 8,
        Method = 9,
        NamedType = 11,
        Namespace = 12,
        NetModule = 10,
        Parameter = 13,
        PointerType = 14,
        Preprocessing = 18,
        Property = 15,
        RangeVariable = 16,
        TypeParameter = 17,
    }
    public abstract partial class SymbolVisitor
    {
        protected SymbolVisitor() { }
        public virtual void DefaultVisit(Microsoft.CodeAnalysis.ISymbol symbol) { }
        public virtual void Visit(Microsoft.CodeAnalysis.ISymbol symbol) { }
        public virtual void VisitAlias(Microsoft.CodeAnalysis.IAliasSymbol symbol) { }
        public virtual void VisitArrayType(Microsoft.CodeAnalysis.IArrayTypeSymbol symbol) { }
        public virtual void VisitAssembly(Microsoft.CodeAnalysis.IAssemblySymbol symbol) { }
        public virtual void VisitDynamicType(Microsoft.CodeAnalysis.IDynamicTypeSymbol symbol) { }
        public virtual void VisitEvent(Microsoft.CodeAnalysis.IEventSymbol symbol) { }
        public virtual void VisitField(Microsoft.CodeAnalysis.IFieldSymbol symbol) { }
        public virtual void VisitLabel(Microsoft.CodeAnalysis.ILabelSymbol symbol) { }
        public virtual void VisitLocal(Microsoft.CodeAnalysis.ILocalSymbol symbol) { }
        public virtual void VisitMethod(Microsoft.CodeAnalysis.IMethodSymbol symbol) { }
        public virtual void VisitModule(Microsoft.CodeAnalysis.IModuleSymbol symbol) { }
        public virtual void VisitNamedType(Microsoft.CodeAnalysis.INamedTypeSymbol symbol) { }
        public virtual void VisitNamespace(Microsoft.CodeAnalysis.INamespaceSymbol symbol) { }
        public virtual void VisitParameter(Microsoft.CodeAnalysis.IParameterSymbol symbol) { }
        public virtual void VisitPointerType(Microsoft.CodeAnalysis.IPointerTypeSymbol symbol) { }
        public virtual void VisitProperty(Microsoft.CodeAnalysis.IPropertySymbol symbol) { }
        public virtual void VisitRangeVariable(Microsoft.CodeAnalysis.IRangeVariableSymbol symbol) { }
        public virtual void VisitTypeParameter(Microsoft.CodeAnalysis.ITypeParameterSymbol symbol) { }
    }
    public abstract partial class SymbolVisitor<TResult>
    {
        protected SymbolVisitor() { }
        public virtual TResult DefaultVisit(Microsoft.CodeAnalysis.ISymbol symbol) { throw null; }
        public virtual TResult Visit(Microsoft.CodeAnalysis.ISymbol symbol) { throw null; }
        public virtual TResult VisitAlias(Microsoft.CodeAnalysis.IAliasSymbol symbol) { throw null; }
        public virtual TResult VisitArrayType(Microsoft.CodeAnalysis.IArrayTypeSymbol symbol) { throw null; }
        public virtual TResult VisitAssembly(Microsoft.CodeAnalysis.IAssemblySymbol symbol) { throw null; }
        public virtual TResult VisitDynamicType(Microsoft.CodeAnalysis.IDynamicTypeSymbol symbol) { throw null; }
        public virtual TResult VisitEvent(Microsoft.CodeAnalysis.IEventSymbol symbol) { throw null; }
        public virtual TResult VisitField(Microsoft.CodeAnalysis.IFieldSymbol symbol) { throw null; }
        public virtual TResult VisitLabel(Microsoft.CodeAnalysis.ILabelSymbol symbol) { throw null; }
        public virtual TResult VisitLocal(Microsoft.CodeAnalysis.ILocalSymbol symbol) { throw null; }
        public virtual TResult VisitMethod(Microsoft.CodeAnalysis.IMethodSymbol symbol) { throw null; }
        public virtual TResult VisitModule(Microsoft.CodeAnalysis.IModuleSymbol symbol) { throw null; }
        public virtual TResult VisitNamedType(Microsoft.CodeAnalysis.INamedTypeSymbol symbol) { throw null; }
        public virtual TResult VisitNamespace(Microsoft.CodeAnalysis.INamespaceSymbol symbol) { throw null; }
        public virtual TResult VisitParameter(Microsoft.CodeAnalysis.IParameterSymbol symbol) { throw null; }
        public virtual TResult VisitPointerType(Microsoft.CodeAnalysis.IPointerTypeSymbol symbol) { throw null; }
        public virtual TResult VisitProperty(Microsoft.CodeAnalysis.IPropertySymbol symbol) { throw null; }
        public virtual TResult VisitRangeVariable(Microsoft.CodeAnalysis.IRangeVariableSymbol symbol) { throw null; }
        public virtual TResult VisitTypeParameter(Microsoft.CodeAnalysis.ITypeParameterSymbol symbol) { throw null; }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
    public sealed partial class SyntaxAnnotation : System.IEquatable<Microsoft.CodeAnalysis.SyntaxAnnotation>
    {
        public SyntaxAnnotation() { }
        public SyntaxAnnotation(string kind) { }
        public SyntaxAnnotation(string kind, string data) { }
        public string Data { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxAnnotation ElasticAnnotation { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string Kind { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.SyntaxAnnotation other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.SyntaxAnnotation left, Microsoft.CodeAnalysis.SyntaxAnnotation right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.SyntaxAnnotation left, Microsoft.CodeAnalysis.SyntaxAnnotation right) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct SyntaxList<TNode> : System.Collections.Generic.IEnumerable<TNode>, System.Collections.Generic.IReadOnlyCollection<TNode>, System.Collections.Generic.IReadOnlyList<TNode>, System.Collections.IEnumerable, System.IEquatable<Microsoft.CodeAnalysis.SyntaxList<TNode>> where TNode : Microsoft.CodeAnalysis.SyntaxNode
    {
        public int Count { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan FullSpan { get { throw null; } }
        public TNode this[int index] { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan Span { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<TNode> Add(TNode node) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxList<TNode> AddRange(System.Collections.Generic.IEnumerable<TNode> nodes) { throw null; }
        public bool Any() { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.SyntaxList<TNode> other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public TNode First() { throw null; }
        public TNode FirstOrDefault() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxList<TNode>.Enumerator GetEnumerator() { throw null; }
        public override int GetHashCode() { throw null; }
        public int IndexOf(System.Func<TNode, bool> predicate) { throw null; }
        public int IndexOf(TNode node) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxList<TNode> Insert(int index, TNode node) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxList<TNode> InsertRange(int index, System.Collections.Generic.IEnumerable<TNode> nodes) { throw null; }
        public TNode Last() { throw null; }
        public int LastIndexOf(System.Func<TNode, bool> predicate) { throw null; }
        public int LastIndexOf(TNode node) { throw null; }
        public TNode LastOrDefault() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.SyntaxList<TNode> left, Microsoft.CodeAnalysis.SyntaxList<TNode> right) { throw null; }
        public static implicit operator Microsoft.CodeAnalysis.SyntaxList<TNode> (Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.SyntaxNode> nodes) { throw null; }
        public static implicit operator Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.SyntaxNode> (Microsoft.CodeAnalysis.SyntaxList<TNode> nodes) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.SyntaxList<TNode> left, Microsoft.CodeAnalysis.SyntaxList<TNode> right) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxList<TNode> Remove(TNode node) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxList<TNode> RemoveAt(int index) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxList<TNode> Replace(TNode nodeInList, TNode newNode) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxList<TNode> ReplaceRange(TNode nodeInList, System.Collections.Generic.IEnumerable<TNode> newNodes) { throw null; }
        System.Collections.Generic.IEnumerator<TNode> System.Collections.Generic.IEnumerable<TNode>.GetEnumerator() { throw null; }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
        public string ToFullString() { throw null; }
        public override string ToString() { throw null; }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public partial struct Enumerator
        {
            public TNode Current { get { throw null; } }
            public override bool Equals(object obj) { throw null; }
            public override int GetHashCode() { throw null; }
            public bool MoveNext() { throw null; }
            public void Reset() { }
        }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
    public abstract partial class SyntaxNode
    {
        internal SyntaxNode() { }
        public bool ContainsAnnotations { get { throw null; } }
        public bool ContainsDiagnostics { get { throw null; } }
        public bool ContainsDirectives { get { throw null; } }
        public bool ContainsSkippedText { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan FullSpan { get { throw null; } }
        public bool HasLeadingTrivia { get { throw null; } }
        public bool HasStructuredTrivia { get { throw null; } }
        public bool HasTrailingTrivia { get { throw null; } }
        public bool IsMissing { get { throw null; } }
        public bool IsStructuredTrivia { get { throw null; } }
        protected abstract string KindText { get; }
        public abstract string Language { get; }
        public Microsoft.CodeAnalysis.SyntaxNode Parent { get { throw null; } }
        public virtual Microsoft.CodeAnalysis.SyntaxTrivia ParentTrivia { get { throw null; } }
        public int RawKind { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan Span { get { throw null; } }
        public int SpanStart { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTree SyntaxTree { get { throw null; } }
        protected abstract Microsoft.CodeAnalysis.SyntaxTree SyntaxTreeCore { get; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> Ancestors(bool ascendOutOfTrivia=true) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> AncestorsAndSelf(bool ascendOutOfTrivia=true) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> ChildNodes() { throw null; }
        public Microsoft.CodeAnalysis.ChildSyntaxList ChildNodesAndTokens() { throw null; }
        public abstract Microsoft.CodeAnalysis.SyntaxNodeOrToken ChildThatContainsPosition(int position);
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> ChildTokens() { throw null; }
        public bool Contains(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public T CopyAnnotationsTo<T>(T node) where T : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> DescendantNodes(Microsoft.CodeAnalysis.Text.TextSpan span, System.Func<Microsoft.CodeAnalysis.SyntaxNode, bool> descendIntoChildren=null, bool descendIntoTrivia=false) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> DescendantNodes(System.Func<Microsoft.CodeAnalysis.SyntaxNode, bool> descendIntoChildren=null, bool descendIntoTrivia=false) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> DescendantNodesAndSelf(Microsoft.CodeAnalysis.Text.TextSpan span, System.Func<Microsoft.CodeAnalysis.SyntaxNode, bool> descendIntoChildren=null, bool descendIntoTrivia=false) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> DescendantNodesAndSelf(System.Func<Microsoft.CodeAnalysis.SyntaxNode, bool> descendIntoChildren=null, bool descendIntoTrivia=false) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken> DescendantNodesAndTokens(Microsoft.CodeAnalysis.Text.TextSpan span, System.Func<Microsoft.CodeAnalysis.SyntaxNode, bool> descendIntoChildren=null, bool descendIntoTrivia=false) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken> DescendantNodesAndTokens(System.Func<Microsoft.CodeAnalysis.SyntaxNode, bool> descendIntoChildren=null, bool descendIntoTrivia=false) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf(Microsoft.CodeAnalysis.Text.TextSpan span, System.Func<Microsoft.CodeAnalysis.SyntaxNode, bool> descendIntoChildren=null, bool descendIntoTrivia=false) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf(System.Func<Microsoft.CodeAnalysis.SyntaxNode, bool> descendIntoChildren=null, bool descendIntoTrivia=false) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> DescendantTokens(Microsoft.CodeAnalysis.Text.TextSpan span, System.Func<Microsoft.CodeAnalysis.SyntaxNode, bool> descendIntoChildren=null, bool descendIntoTrivia=false) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> DescendantTokens(System.Func<Microsoft.CodeAnalysis.SyntaxNode, bool> descendIntoChildren=null, bool descendIntoTrivia=false) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> DescendantTrivia(Microsoft.CodeAnalysis.Text.TextSpan span, System.Func<Microsoft.CodeAnalysis.SyntaxNode, bool> descendIntoChildren=null, bool descendIntoTrivia=false) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> DescendantTrivia(System.Func<Microsoft.CodeAnalysis.SyntaxNode, bool> descendIntoChildren=null, bool descendIntoTrivia=false) { throw null; }
        protected abstract bool EquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode other);
        public Microsoft.CodeAnalysis.SyntaxNode FindNode(Microsoft.CodeAnalysis.Text.TextSpan span, bool findInsideTrivia=false, bool getInnermostNodeForTie=false) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken FindToken(int position, bool findInsideTrivia=false) { throw null; }
        protected virtual Microsoft.CodeAnalysis.SyntaxToken FindTokenCore(int position, bool findInsideTrivia) { throw null; }
        protected virtual Microsoft.CodeAnalysis.SyntaxToken FindTokenCore(int position, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, bool> stepInto) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTrivia FindTrivia(int position, bool findInsideTrivia=false) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTrivia FindTrivia(int position, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, bool> stepInto) { throw null; }
        protected virtual Microsoft.CodeAnalysis.SyntaxTrivia FindTriviaCore(int position, bool findInsideTrivia) { throw null; }
        public TNode FirstAncestorOrSelf<TNode>(System.Func<TNode, bool> predicate=null, bool ascendOutOfTrivia=true) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> GetAnnotatedNodes(Microsoft.CodeAnalysis.SyntaxAnnotation syntaxAnnotation) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> GetAnnotatedNodes(string annotationKind) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(Microsoft.CodeAnalysis.SyntaxAnnotation annotation) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(string annotationKind) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(params string[] annotationKinds) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> GetAnnotatedTokens(Microsoft.CodeAnalysis.SyntaxAnnotation syntaxAnnotation) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> GetAnnotatedTokens(string annotationKind) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> GetAnnotatedTrivia(Microsoft.CodeAnalysis.SyntaxAnnotation annotation) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> GetAnnotatedTrivia(string annotationKind) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> GetAnnotatedTrivia(params string[] annotationKinds) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> GetAnnotations(System.Collections.Generic.IEnumerable<string> annotationKinds) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> GetAnnotations(string annotationKind) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken GetFirstToken(bool includeZeroWidth=false, bool includeSkipped=false, bool includeDirectives=false, bool includeDocumentationComments=false) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken GetLastToken(bool includeZeroWidth=false, bool includeSkipped=false, bool includeDirectives=false, bool includeDocumentationComments=false) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTriviaList GetLeadingTrivia() { throw null; }
        public Microsoft.CodeAnalysis.Location GetLocation() { throw null; }
        protected T GetRedAtZero<T>(ref T field) where T : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        protected T GetRed<T>(ref T field, int slot) where T : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public Microsoft.CodeAnalysis.SyntaxReference GetReference() { throw null; }
        public Microsoft.CodeAnalysis.Text.SourceText GetText(System.Text.Encoding encoding=null, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm=(Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)(1)) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTriviaList GetTrailingTrivia() { throw null; }
        public bool HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation annotation) { throw null; }
        public bool HasAnnotations(System.Collections.Generic.IEnumerable<string> annotationKinds) { throw null; }
        public bool HasAnnotations(string annotationKind) { throw null; }
        protected internal abstract Microsoft.CodeAnalysis.SyntaxNode InsertNodesInListCore(Microsoft.CodeAnalysis.SyntaxNode nodeInList, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> nodesToInsert, bool insertBefore);
        protected internal abstract Microsoft.CodeAnalysis.SyntaxNode InsertTokensInListCore(Microsoft.CodeAnalysis.SyntaxToken originalToken, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> newTokens, bool insertBefore);
        protected internal abstract Microsoft.CodeAnalysis.SyntaxNode InsertTriviaInListCore(Microsoft.CodeAnalysis.SyntaxTrivia originalTrivia, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> newTrivia, bool insertBefore);
        public bool IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNode other) { throw null; }
        public bool IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNode node, bool topLevel=false) { throw null; }
        protected abstract bool IsEquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode node, bool topLevel=false);
        public bool IsPartOfStructuredTrivia() { throw null; }
        protected internal abstract Microsoft.CodeAnalysis.SyntaxNode NormalizeWhitespaceCore(string indentation, string eol, bool elasticTrivia);
        protected internal abstract Microsoft.CodeAnalysis.SyntaxNode RemoveNodesCore(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> nodes, Microsoft.CodeAnalysis.SyntaxRemoveOptions options);
        protected internal abstract Microsoft.CodeAnalysis.SyntaxNode ReplaceCore<TNode>(System.Collections.Generic.IEnumerable<TNode> nodes=null, System.Func<TNode, TNode, Microsoft.CodeAnalysis.SyntaxNode> computeReplacementNode=null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> tokens=null, System.Func<Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken> computeReplacementToken=null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivia=null, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia> computeReplacementTrivia=null) where TNode : Microsoft.CodeAnalysis.SyntaxNode;
        protected internal abstract Microsoft.CodeAnalysis.SyntaxNode ReplaceNodeInListCore(Microsoft.CodeAnalysis.SyntaxNode originalNode, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> replacementNodes);
        protected internal abstract Microsoft.CodeAnalysis.SyntaxNode ReplaceTokenInListCore(Microsoft.CodeAnalysis.SyntaxToken originalToken, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> newTokens);
        protected internal abstract Microsoft.CodeAnalysis.SyntaxNode ReplaceTriviaInListCore(Microsoft.CodeAnalysis.SyntaxTrivia originalTrivia, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> newTrivia);
        public abstract void SerializeTo(System.IO.Stream stream, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public abstract string ToFullString();
        public abstract override string ToString();
        public abstract void WriteTo(System.IO.TextWriter writer);
    }
    public static partial class SyntaxNodeExtensions
    {
        public static System.Collections.Generic.IEnumerable<TNode> GetCurrentNodes<TNode>(this Microsoft.CodeAnalysis.SyntaxNode root, System.Collections.Generic.IEnumerable<TNode> nodes) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static System.Collections.Generic.IEnumerable<TNode> GetCurrentNodes<TNode>(this Microsoft.CodeAnalysis.SyntaxNode root, TNode node) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TNode GetCurrentNode<TNode>(this Microsoft.CodeAnalysis.SyntaxNode root, TNode node) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot InsertNodesAfter<TRoot>(this TRoot root, Microsoft.CodeAnalysis.SyntaxNode nodeInList, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> newNodes) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot InsertNodesBefore<TRoot>(this TRoot root, Microsoft.CodeAnalysis.SyntaxNode nodeInList, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> newNodes) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot InsertTokensAfter<TRoot>(this TRoot root, Microsoft.CodeAnalysis.SyntaxToken tokenInList, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> newTokens) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot InsertTokensBefore<TRoot>(this TRoot root, Microsoft.CodeAnalysis.SyntaxToken tokenInList, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> newTokens) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot InsertTriviaAfter<TRoot>(this TRoot root, Microsoft.CodeAnalysis.SyntaxTrivia trivia, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> newTrivia) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot InsertTriviaBefore<TRoot>(this TRoot root, Microsoft.CodeAnalysis.SyntaxTrivia trivia, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> newTrivia) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TNode NormalizeWhitespace<TNode>(this TNode node, string indentation, bool elasticTrivia) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TNode NormalizeWhitespace<TNode>(this TNode node, string indentation="    ", string eol="\r\n", bool elasticTrivia=false) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot RemoveNodes<TRoot>(this TRoot root, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> nodes, Microsoft.CodeAnalysis.SyntaxRemoveOptions options) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot RemoveNode<TRoot>(this TRoot root, Microsoft.CodeAnalysis.SyntaxNode node, Microsoft.CodeAnalysis.SyntaxRemoveOptions options) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot ReplaceNodes<TRoot, TNode>(this TRoot root, System.Collections.Generic.IEnumerable<TNode> nodes, System.Func<TNode, TNode, Microsoft.CodeAnalysis.SyntaxNode> computeReplacementNode) where TRoot : Microsoft.CodeAnalysis.SyntaxNode where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot ReplaceNode<TRoot>(this TRoot root, Microsoft.CodeAnalysis.SyntaxNode oldNode, Microsoft.CodeAnalysis.SyntaxNode newNode) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot ReplaceNode<TRoot>(this TRoot root, Microsoft.CodeAnalysis.SyntaxNode oldNode, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> newNodes) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot ReplaceSyntax<TRoot>(this TRoot root, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> nodes, System.Func<Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SyntaxNode> computeReplacementNode, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> tokens, System.Func<Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken> computeReplacementToken, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivia, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia> computeReplacementTrivia) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot ReplaceTokens<TRoot>(this TRoot root, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> tokens, System.Func<Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken> computeReplacementToken) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot ReplaceToken<TRoot>(this TRoot root, Microsoft.CodeAnalysis.SyntaxToken oldToken, Microsoft.CodeAnalysis.SyntaxToken newToken) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot ReplaceToken<TRoot>(this TRoot root, Microsoft.CodeAnalysis.SyntaxToken tokenInList, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> newTokens) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot ReplaceTrivia<TRoot>(this TRoot root, Microsoft.CodeAnalysis.SyntaxTrivia trivia, Microsoft.CodeAnalysis.SyntaxTrivia newTrivia) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot ReplaceTrivia<TRoot>(this TRoot root, Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> newTrivia) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot ReplaceTrivia<TRoot>(this TRoot root, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivia, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia> computeReplacementTrivia) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot TrackNodes<TRoot>(this TRoot root, params Microsoft.CodeAnalysis.SyntaxNode[] nodes) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TRoot TrackNodes<TRoot>(this TRoot root, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> nodes) where TRoot : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TSyntax WithLeadingTrivia<TSyntax>(this TSyntax node, Microsoft.CodeAnalysis.SyntaxTriviaList trivia) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TSyntax WithLeadingTrivia<TSyntax>(this TSyntax node, params Microsoft.CodeAnalysis.SyntaxTrivia[] trivia) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TSyntax WithLeadingTrivia<TSyntax>(this TSyntax node, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivia) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TSyntax WithoutLeadingTrivia<TSyntax>(this TSyntax node) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TSyntax WithoutTrailingTrivia<TSyntax>(this TSyntax node) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TSyntax WithoutTrivia<TSyntax>(this TSyntax syntax) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TSyntax WithTrailingTrivia<TSyntax>(this TSyntax node, Microsoft.CodeAnalysis.SyntaxTriviaList trivia) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TSyntax WithTrailingTrivia<TSyntax>(this TSyntax node, params Microsoft.CodeAnalysis.SyntaxTrivia[] trivia) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TSyntax WithTrailingTrivia<TSyntax>(this TSyntax node, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivia) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static TSyntax WithTriviaFrom<TSyntax>(this TSyntax syntax, Microsoft.CodeAnalysis.SyntaxNode node) where TSyntax : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
    public partial struct SyntaxNodeOrToken : System.IEquatable<Microsoft.CodeAnalysis.SyntaxNodeOrToken>
    {
        public bool ContainsAnnotations { get { throw null; } }
        public bool ContainsDiagnostics { get { throw null; } }
        public bool ContainsDirectives { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan FullSpan { get { throw null; } }
        public bool HasLeadingTrivia { get { throw null; } }
        public bool HasTrailingTrivia { get { throw null; } }
        public bool IsMissing { get { throw null; } }
        public bool IsNode { get { throw null; } }
        public bool IsToken { get { throw null; } }
        public string Language { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxNode Parent { get { throw null; } }
        public int RawKind { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan Span { get { throw null; } }
        public int SpanStart { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTree SyntaxTree { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxNode AsNode() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken AsToken() { throw null; }
        public Microsoft.CodeAnalysis.ChildSyntaxList ChildNodesAndTokens() { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.SyntaxNodeOrToken other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> GetAnnotations(System.Collections.Generic.IEnumerable<string> annotationKinds) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> GetAnnotations(string annotationKind) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics() { throw null; }
        public static int GetFirstChildIndexSpanningPosition(Microsoft.CodeAnalysis.SyntaxNode node, int position) { throw null; }
        public override int GetHashCode() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTriviaList GetLeadingTrivia() { throw null; }
        public Microsoft.CodeAnalysis.Location GetLocation() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken GetNextSibling() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken GetPreviousSibling() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTriviaList GetTrailingTrivia() { throw null; }
        public bool HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation annotation) { throw null; }
        public bool HasAnnotations(System.Collections.Generic.IEnumerable<string> annotationKinds) { throw null; }
        public bool HasAnnotations(string annotationKind) { throw null; }
        public bool IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNodeOrToken other) { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.SyntaxNodeOrToken left, Microsoft.CodeAnalysis.SyntaxNodeOrToken right) { throw null; }
        public static explicit operator Microsoft.CodeAnalysis.SyntaxNode (Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) { throw null; }
        public static explicit operator Microsoft.CodeAnalysis.SyntaxToken (Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) { throw null; }
        public static implicit operator Microsoft.CodeAnalysis.SyntaxNodeOrToken (Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public static implicit operator Microsoft.CodeAnalysis.SyntaxNodeOrToken (Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.SyntaxNodeOrToken left, Microsoft.CodeAnalysis.SyntaxNodeOrToken right) { throw null; }
        public string ToFullString() { throw null; }
        public override string ToString() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithAdditionalAnnotations(params Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithAdditionalAnnotations(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> annotations) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithLeadingTrivia(params Microsoft.CodeAnalysis.SyntaxTrivia[] trivia) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithLeadingTrivia(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivia) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithoutAnnotations(params Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithoutAnnotations(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> annotations) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithoutAnnotations(string annotationKind) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithTrailingTrivia(params Microsoft.CodeAnalysis.SyntaxTrivia[] trivia) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken WithTrailingTrivia(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivia) { throw null; }
        public void WriteTo(System.IO.TextWriter writer) { }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct SyntaxNodeOrTokenList : System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken>, System.Collections.Generic.IReadOnlyCollection<Microsoft.CodeAnalysis.SyntaxNodeOrToken>, System.Collections.IEnumerable, System.IEquatable<Microsoft.CodeAnalysis.SyntaxNodeOrTokenList>
    {
        public int Count { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan FullSpan { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken this[int index] { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan Span { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList Add(Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList AddRange(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken> nodesOrTokens) { throw null; }
        public bool Any() { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken First() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken FirstOrDefault() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator GetEnumerator() { throw null; }
        public override int GetHashCode() { throw null; }
        public int IndexOf(Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList Insert(int index, Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList InsertRange(int index, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken> nodesAndTokens) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken Last() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrToken LastOrDefault() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList left, Microsoft.CodeAnalysis.SyntaxNodeOrTokenList right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList left, Microsoft.CodeAnalysis.SyntaxNodeOrTokenList right) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList Remove(Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrTokenInList) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList RemoveAt(int index) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList Replace(Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrTokenInList, Microsoft.CodeAnalysis.SyntaxNodeOrToken newNodeOrToken) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNodeOrTokenList ReplaceRange(Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrTokenInList, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken> newNodesAndTokens) { throw null; }
        System.Collections.Generic.IEnumerator<Microsoft.CodeAnalysis.SyntaxNodeOrToken> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken>.GetEnumerator() { throw null; }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
        public string ToFullString() { throw null; }
        public override string ToString() { throw null; }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public partial struct Enumerator : System.Collections.Generic.IEnumerator<Microsoft.CodeAnalysis.SyntaxNodeOrToken>, System.Collections.IEnumerator, System.IDisposable
        {
            public Microsoft.CodeAnalysis.SyntaxNodeOrToken Current { get { throw null; } }
            object System.Collections.IEnumerator.Current { get { throw null; } }
            public override bool Equals(object obj) { throw null; }
            public override int GetHashCode() { throw null; }
            public bool MoveNext() { throw null; }
            void System.Collections.IEnumerator.Reset() { }
            void System.IDisposable.Dispose() { }
        }
    }
    public abstract partial class SyntaxReference
    {
        protected SyntaxReference() { }
        public abstract Microsoft.CodeAnalysis.Text.TextSpan Span { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxTree SyntaxTree { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxNode GetSyntax(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public virtual System.Threading.Tasks.Task<Microsoft.CodeAnalysis.SyntaxNode> GetSyntaxAsync(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
    }
    [System.FlagsAttribute]
    public enum SyntaxRemoveOptions
    {
        AddElasticMarker = 32,
        KeepDirectives = 8,
        KeepEndOfLine = 16,
        KeepExteriorTrivia = 3,
        KeepLeadingTrivia = 1,
        KeepNoTrivia = 0,
        KeepTrailingTrivia = 2,
        KeepUnbalancedDirectives = 4,
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
    public partial struct SyntaxToken : System.IEquatable<Microsoft.CodeAnalysis.SyntaxToken>
    {
        public bool ContainsAnnotations { get { throw null; } }
        public bool ContainsDiagnostics { get { throw null; } }
        public bool ContainsDirectives { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan FullSpan { get { throw null; } }
        public bool HasLeadingTrivia { get { throw null; } }
        public bool HasStructuredTrivia { get { throw null; } }
        public bool HasTrailingTrivia { get { throw null; } }
        public bool IsMissing { get { throw null; } }
        public string Language { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTriviaList LeadingTrivia { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxNode Parent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public int RawKind { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan Span { get { throw null; } }
        public int SpanStart { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTree SyntaxTree { get { throw null; } }
        public string Text { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTriviaList TrailingTrivia { get { throw null; } }
        public object Value { get { throw null; } }
        public string ValueText { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CopyAnnotationsTo(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.SyntaxToken other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> GetAllTrivia() { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> GetAnnotations(System.Collections.Generic.IEnumerable<string> annotationKinds) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> GetAnnotations(string annotationKind) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> GetAnnotations(params string[] annotationKinds) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics() { throw null; }
        public override int GetHashCode() { throw null; }
        public Microsoft.CodeAnalysis.Location GetLocation() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken GetNextToken(bool includeZeroWidth=false, bool includeSkipped=false, bool includeDirectives=false, bool includeDocumentationComments=false) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken GetPreviousToken(bool includeZeroWidth=false, bool includeSkipped=false, bool includeDirectives=false, bool includeDocumentationComments=false) { throw null; }
        public bool HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation annotation) { throw null; }
        public bool HasAnnotations(string annotationKind) { throw null; }
        public bool HasAnnotations(params string[] annotationKinds) { throw null; }
        public bool IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public bool IsPartOfStructuredTrivia() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.SyntaxToken left, Microsoft.CodeAnalysis.SyntaxToken right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.SyntaxToken left, Microsoft.CodeAnalysis.SyntaxToken right) { throw null; }
        public string ToFullString() { throw null; }
        public override string ToString() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken WithAdditionalAnnotations(params Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken WithAdditionalAnnotations(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> annotations) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken WithLeadingTrivia(Microsoft.CodeAnalysis.SyntaxTriviaList trivia) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken WithLeadingTrivia(params Microsoft.CodeAnalysis.SyntaxTrivia[] trivia) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken WithLeadingTrivia(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivia) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken WithoutAnnotations(params Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken WithoutAnnotations(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> annotations) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken WithoutAnnotations(string annotationKind) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken WithTrailingTrivia(Microsoft.CodeAnalysis.SyntaxTriviaList trivia) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken WithTrailingTrivia(params Microsoft.CodeAnalysis.SyntaxTrivia[] trivia) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken WithTrailingTrivia(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivia) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken WithTriviaFrom(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public void WriteTo(System.IO.TextWriter writer) { }
    }
    public partial struct SyntaxTokenList : System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken>, System.Collections.Generic.IReadOnlyCollection<Microsoft.CodeAnalysis.SyntaxToken>, System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.SyntaxToken>, System.Collections.IEnumerable, System.IEquatable<Microsoft.CodeAnalysis.SyntaxTokenList>
    {
        public int Count { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan FullSpan { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken this[int index] { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan Span { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList Add(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTokenList AddRange(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> tokens) { throw null; }
        public bool Any() { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTokenList Create(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.SyntaxTokenList other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken First() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTokenList.Enumerator GetEnumerator() { throw null; }
        public override int GetHashCode() { throw null; }
        public int IndexOf(Microsoft.CodeAnalysis.SyntaxToken tokenInList) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTokenList Insert(int index, Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTokenList InsertRange(int index, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> tokens) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxToken Last() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.SyntaxTokenList left, Microsoft.CodeAnalysis.SyntaxTokenList right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.SyntaxTokenList left, Microsoft.CodeAnalysis.SyntaxTokenList right) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTokenList Remove(Microsoft.CodeAnalysis.SyntaxToken tokenInList) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTokenList RemoveAt(int index) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTokenList Replace(Microsoft.CodeAnalysis.SyntaxToken tokenInList, Microsoft.CodeAnalysis.SyntaxToken newToken) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTokenList ReplaceRange(Microsoft.CodeAnalysis.SyntaxToken tokenInList, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> newTokens) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTokenList.Reversed Reverse() { throw null; }
        System.Collections.Generic.IEnumerator<Microsoft.CodeAnalysis.SyntaxToken> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken>.GetEnumerator() { throw null; }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
        public string ToFullString() { throw null; }
        public override string ToString() { throw null; }
        public partial struct Enumerator
        {
            public Microsoft.CodeAnalysis.SyntaxToken Current { get { throw null; } }
            public override bool Equals(object obj) { throw null; }
            public override int GetHashCode() { throw null; }
            public bool MoveNext() { throw null; }
        }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public partial struct Reversed : System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken>, System.Collections.IEnumerable, System.IEquatable<Microsoft.CodeAnalysis.SyntaxTokenList.Reversed>
        {
            public Reversed(Microsoft.CodeAnalysis.SyntaxTokenList list) { throw null;}
            public bool Equals(Microsoft.CodeAnalysis.SyntaxTokenList.Reversed other) { throw null; }
            public override bool Equals(object obj) { throw null; }
            public Microsoft.CodeAnalysis.SyntaxTokenList.Reversed.Enumerator GetEnumerator() { throw null; }
            public override int GetHashCode() { throw null; }
            System.Collections.Generic.IEnumerator<Microsoft.CodeAnalysis.SyntaxToken> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken>.GetEnumerator() { throw null; }
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
            public partial struct Enumerator
            {
                public Enumerator(ref Microsoft.CodeAnalysis.SyntaxTokenList list) { throw null;}
                public Microsoft.CodeAnalysis.SyntaxToken Current { get { throw null; } }
                public override bool Equals(object obj) { throw null; }
                public override int GetHashCode() { throw null; }
                public bool MoveNext() { throw null; }
            }
        }
    }
    public abstract partial class SyntaxTree
    {
        protected SyntaxTree() { }
        public abstract System.Text.Encoding Encoding { get; }
        public abstract string FilePath { get; }
        public abstract bool HasCompilationUnitRoot { get; }
        public abstract int Length { get; }
        public Microsoft.CodeAnalysis.ParseOptions Options { get { throw null; } }
        protected abstract Microsoft.CodeAnalysis.ParseOptions OptionsCore { get; }
        public abstract System.Collections.Generic.IList<Microsoft.CodeAnalysis.Text.TextSpan> GetChangedSpans(Microsoft.CodeAnalysis.SyntaxTree syntaxTree);
        public abstract System.Collections.Generic.IList<Microsoft.CodeAnalysis.Text.TextChange> GetChanges(Microsoft.CodeAnalysis.SyntaxTree oldTree);
        public abstract System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNode node);
        public abstract System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken);
        public abstract System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(Microsoft.CodeAnalysis.SyntaxToken token);
        public abstract System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(Microsoft.CodeAnalysis.SyntaxTrivia trivia);
        public abstract System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public abstract Microsoft.CodeAnalysis.FileLinePositionSpan GetLineSpan(Microsoft.CodeAnalysis.Text.TextSpan span, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public virtual Microsoft.CodeAnalysis.LineVisibility GetLineVisibility(int position, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public abstract Microsoft.CodeAnalysis.Location GetLocation(Microsoft.CodeAnalysis.Text.TextSpan span);
        public abstract Microsoft.CodeAnalysis.FileLinePositionSpan GetMappedLineSpan(Microsoft.CodeAnalysis.Text.TextSpan span, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public abstract Microsoft.CodeAnalysis.SyntaxReference GetReference(Microsoft.CodeAnalysis.SyntaxNode node);
        public Microsoft.CodeAnalysis.SyntaxNode GetRoot(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public System.Threading.Tasks.Task<Microsoft.CodeAnalysis.SyntaxNode> GetRootAsync(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        protected abstract System.Threading.Tasks.Task<Microsoft.CodeAnalysis.SyntaxNode> GetRootAsyncCore(System.Threading.CancellationToken cancellationToken);
        protected abstract Microsoft.CodeAnalysis.SyntaxNode GetRootCore(System.Threading.CancellationToken cancellationToken);
        public abstract Microsoft.CodeAnalysis.Text.SourceText GetText(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
        public virtual System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Text.SourceText> GetTextAsync(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public abstract bool HasHiddenRegions();
        public abstract bool IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTree tree, bool topLevel=false);
        public override string ToString() { throw null; }
        public bool TryGetRoot(out Microsoft.CodeAnalysis.SyntaxNode root) { root = default(Microsoft.CodeAnalysis.SyntaxNode); throw null; }
        protected abstract bool TryGetRootCore(out Microsoft.CodeAnalysis.SyntaxNode root);
        public abstract bool TryGetText(out Microsoft.CodeAnalysis.Text.SourceText text);
        public abstract Microsoft.CodeAnalysis.SyntaxTree WithChangedText(Microsoft.CodeAnalysis.Text.SourceText newText);
        public abstract Microsoft.CodeAnalysis.SyntaxTree WithFilePath(string path);
        public abstract Microsoft.CodeAnalysis.SyntaxTree WithRootAndOptions(Microsoft.CodeAnalysis.SyntaxNode root, Microsoft.CodeAnalysis.ParseOptions options);
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
    public partial struct SyntaxTrivia : System.IEquatable<Microsoft.CodeAnalysis.SyntaxTrivia>
    {
        public bool ContainsDiagnostics { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan FullSpan { get { throw null; } }
        public bool HasStructure { get { throw null; } }
        public bool IsDirective { get { throw null; } }
        public string Language { get { throw null; } }
        public int RawKind { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan Span { get { throw null; } }
        public int SpanStart { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTree SyntaxTree { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Token { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTrivia CopyAnnotationsTo(Microsoft.CodeAnalysis.SyntaxTrivia trivia) { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.SyntaxTrivia other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> GetAnnotations(string annotationKind) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> GetAnnotations(params string[] annotationKinds) { throw null; }
        public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics() { throw null; }
        public override int GetHashCode() { throw null; }
        public Microsoft.CodeAnalysis.Location GetLocation() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxNode GetStructure() { throw null; }
        public bool HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation annotation) { throw null; }
        public bool HasAnnotations(string annotationKind) { throw null; }
        public bool HasAnnotations(params string[] annotationKinds) { throw null; }
        public bool IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTrivia trivia) { throw null; }
        public bool IsPartOfStructuredTrivia() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.SyntaxTrivia left, Microsoft.CodeAnalysis.SyntaxTrivia right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.SyntaxTrivia left, Microsoft.CodeAnalysis.SyntaxTrivia right) { throw null; }
        public string ToFullString() { throw null; }
        public override string ToString() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTrivia WithAdditionalAnnotations(params Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTrivia WithAdditionalAnnotations(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> annotations) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTrivia WithoutAnnotations(params Microsoft.CodeAnalysis.SyntaxAnnotation[] annotations) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTrivia WithoutAnnotations(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxAnnotation> annotations) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTrivia WithoutAnnotations(string annotationKind) { throw null; }
        public void WriteTo(System.IO.TextWriter writer) { }
    }
    public partial struct SyntaxTriviaList : System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia>, System.Collections.Generic.IReadOnlyCollection<Microsoft.CodeAnalysis.SyntaxTrivia>, System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.SyntaxTrivia>, System.Collections.IEnumerable, System.IEquatable<Microsoft.CodeAnalysis.SyntaxTriviaList>
    {
        public int Count { get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList Empty { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan FullSpan { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTrivia this[int index] { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan Span { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTriviaList Add(Microsoft.CodeAnalysis.SyntaxTrivia trivia) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTriviaList AddRange(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivia) { throw null; }
        public bool Any() { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList Create(Microsoft.CodeAnalysis.SyntaxTrivia trivia) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTrivia ElementAt(int index) { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.SyntaxTriviaList other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTrivia First() { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTriviaList.Enumerator GetEnumerator() { throw null; }
        public override int GetHashCode() { throw null; }
        public int IndexOf(Microsoft.CodeAnalysis.SyntaxTrivia triviaInList) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTriviaList Insert(int index, Microsoft.CodeAnalysis.SyntaxTrivia trivia) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTriviaList InsertRange(int index, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivia) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTrivia Last() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.SyntaxTriviaList left, Microsoft.CodeAnalysis.SyntaxTriviaList right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.SyntaxTriviaList left, Microsoft.CodeAnalysis.SyntaxTriviaList right) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTriviaList Remove(Microsoft.CodeAnalysis.SyntaxTrivia triviaInList) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTriviaList RemoveAt(int index) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTriviaList Replace(Microsoft.CodeAnalysis.SyntaxTrivia triviaInList, Microsoft.CodeAnalysis.SyntaxTrivia newTrivia) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTriviaList ReplaceRange(Microsoft.CodeAnalysis.SyntaxTrivia triviaInList, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> newTrivia) { throw null; }
        public Microsoft.CodeAnalysis.SyntaxTriviaList.Reversed Reverse() { throw null; }
        System.Collections.Generic.IEnumerator<Microsoft.CodeAnalysis.SyntaxTrivia> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia>.GetEnumerator() { throw null; }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
        public string ToFullString() { throw null; }
        public override string ToString() { throw null; }
        public partial struct Enumerator
        {
            public Microsoft.CodeAnalysis.SyntaxTrivia Current { get { throw null; } }
            public bool MoveNext() { throw null; }
        }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public partial struct Reversed : System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia>, System.Collections.IEnumerable, System.IEquatable<Microsoft.CodeAnalysis.SyntaxTriviaList.Reversed>
        {
            public Reversed(Microsoft.CodeAnalysis.SyntaxTriviaList list) { throw null;}
            public bool Equals(Microsoft.CodeAnalysis.SyntaxTriviaList.Reversed other) { throw null; }
            public override bool Equals(object obj) { throw null; }
            public Microsoft.CodeAnalysis.SyntaxTriviaList.Reversed.Enumerator GetEnumerator() { throw null; }
            public override int GetHashCode() { throw null; }
            System.Collections.Generic.IEnumerator<Microsoft.CodeAnalysis.SyntaxTrivia> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia>.GetEnumerator() { throw null; }
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
            public partial struct Enumerator
            {
                public Enumerator(ref Microsoft.CodeAnalysis.SyntaxTriviaList list) { throw null;}
                public Microsoft.CodeAnalysis.SyntaxTrivia Current { get { throw null; } }
                public bool MoveNext() { throw null; }
            }
        }
    }
    public abstract partial class SyntaxWalker
    {
        protected SyntaxWalker(Microsoft.CodeAnalysis.SyntaxWalkerDepth depth=(Microsoft.CodeAnalysis.SyntaxWalkerDepth)(0)) { }
        protected Microsoft.CodeAnalysis.SyntaxWalkerDepth Depth { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public virtual void Visit(Microsoft.CodeAnalysis.SyntaxNode node) { }
        protected virtual void VisitToken(Microsoft.CodeAnalysis.SyntaxToken token) { }
        protected virtual void VisitTrivia(Microsoft.CodeAnalysis.SyntaxTrivia trivia) { }
    }
    public enum SyntaxWalkerDepth
    {
        Node = 0,
        StructuredTrivia = 3,
        Token = 1,
        Trivia = 2,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct TypedConstant : System.IEquatable<Microsoft.CodeAnalysis.TypedConstant>
    {
        public bool IsNull { get { throw null; } }
        public Microsoft.CodeAnalysis.TypedConstantKind Kind { get { throw null; } }
        public Microsoft.CodeAnalysis.ITypeSymbol Type { get { throw null; } }
        public object Value { get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.TypedConstant> Values { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.TypedConstant other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    public enum TypedConstantKind
    {
        Array = 4,
        Enum = 2,
        Error = 0,
        Primitive = 1,
        Type = 3,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct TypeInfo : System.IEquatable<Microsoft.CodeAnalysis.TypeInfo>
    {
        public Microsoft.CodeAnalysis.ITypeSymbol ConvertedType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.ITypeSymbol Type { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.TypeInfo other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    public enum TypeKind : byte
    {
        Array = (byte)1,
        Class = (byte)2,
        Delegate = (byte)3,
        Dynamic = (byte)4,
        Enum = (byte)5,
        Error = (byte)6,
        Interface = (byte)7,
        Module = (byte)8,
        Pointer = (byte)9,
        Struct = (byte)10,
        Structure = (byte)10,
        Submission = (byte)12,
        TypeParameter = (byte)11,
        Unknown = (byte)0,
    }
    public enum TypeParameterKind
    {
        Cref = 2,
        Method = 1,
        Type = 0,
    }
    public sealed partial class UnresolvedMetadataReference : Microsoft.CodeAnalysis.MetadataReference
    {
        internal UnresolvedMetadataReference() : base (default(Microsoft.CodeAnalysis.MetadataReferenceProperties)) { }
        public override string Display { get { throw null; } }
        public string Reference { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
    }
    public enum VarianceKind : short
    {
        In = (short)2,
        None = (short)0,
        Out = (short)1,
    }
    public static partial class WellKnownDiagnosticTags
    {
        public const string AnalyzerException = "AnalyzerException";
        public const string Build = "Build";
        public const string Compiler = "Compiler";
        public const string EditAndContinue = "EditAndContinue";
        public const string NotConfigurable = "NotConfigurable";
        public const string Telemetry = "Telemetry";
        public const string Unnecessary = "Unnecessary";
    }
    public static partial class WellKnownMemberNames
    {
        public const string AdditionOperatorName = "op_Addition";
        public const string BitwiseAndOperatorName = "op_BitwiseAnd";
        public const string BitwiseOrOperatorName = "op_BitwiseOr";
        public const string CollectionInitializerAddMethodName = "Add";
        public const string ConcatenateOperatorName = "op_Concatenate";
        public const string CurrentPropertyName = "Current";
        public const string DecrementOperatorName = "op_Decrement";
        public const string DefaultScriptClassName = "Script";
        public const string DelegateBeginInvokeName = "BeginInvoke";
        public const string DelegateEndInvokeName = "EndInvoke";
        public const string DelegateInvokeName = "Invoke";
        public const string DestructorName = "Finalize";
        public const string DivisionOperatorName = "op_Division";
        public const string EntryPointMethodName = "Main";
        public const string EnumBackingFieldName = "value__";
        public const string EqualityOperatorName = "op_Equality";
        public const string ExclusiveOrOperatorName = "op_ExclusiveOr";
        public const string ExplicitConversionName = "op_Explicit";
        public const string ExponentOperatorName = "op_Exponent";
        public const string FalseOperatorName = "op_False";
        public const string GetAwaiter = "GetAwaiter";
        public const string GetEnumeratorMethodName = "GetEnumerator";
        public const string GetResult = "GetResult";
        public const string GreaterThanOperatorName = "op_GreaterThan";
        public const string GreaterThanOrEqualOperatorName = "op_GreaterThanOrEqual";
        public const string ImplicitConversionName = "op_Implicit";
        public const string IncrementOperatorName = "op_Increment";
        public const string Indexer = "this[]";
        public const string InequalityOperatorName = "op_Inequality";
        public const string InstanceConstructorName = ".ctor";
        public const string IntegerDivisionOperatorName = "op_IntegerDivision";
        public const string IsCompleted = "IsCompleted";
        public const string LeftShiftOperatorName = "op_LeftShift";
        public const string LessThanOperatorName = "op_LessThan";
        public const string LessThanOrEqualOperatorName = "op_LessThanOrEqual";
        public const string LikeOperatorName = "op_Like";
        public const string LogicalAndOperatorName = "op_LogicalAnd";
        public const string LogicalNotOperatorName = "op_LogicalNot";
        public const string LogicalOrOperatorName = "op_LogicalOr";
        public const string ModulusOperatorName = "op_Modulus";
        public const string MoveNextMethodName = "MoveNext";
        public const string MultiplyOperatorName = "op_Multiply";
        public const string ObjectEquals = "Equals";
        public const string ObjectGetHashCode = "GetHashCode";
        public const string ObjectToString = "ToString";
        public const string OnCompleted = "OnCompleted";
        public const string OnesComplementOperatorName = "op_OnesComplement";
        public const string RightShiftOperatorName = "op_RightShift";
        public const string StaticConstructorName = ".cctor";
        public const string SubtractionOperatorName = "op_Subtraction";
        public const string TrueOperatorName = "op_True";
        public const string UnaryNegationOperatorName = "op_UnaryNegation";
        public const string UnaryPlusOperatorName = "op_UnaryPlus";
        public const string UnsignedLeftShiftOperatorName = "op_UnsignedLeftShift";
        public const string UnsignedRightShiftOperatorName = "op_UnsignedRightShift";
        public const string ValuePropertyName = "Value";
    }
    public partial class XmlFileResolver : Microsoft.CodeAnalysis.XmlReferenceResolver
    {
        public XmlFileResolver(string baseDirectory) { }
        public string BaseDirectory { get { throw null; } }
        public static Microsoft.CodeAnalysis.XmlFileResolver Default { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public override bool Equals(object obj) { throw null; }
        protected virtual bool FileExists(string resolvedPath) { throw null; }
        public override int GetHashCode() { throw null; }
        public override System.IO.Stream OpenRead(string resolvedPath) { throw null; }
        public override string ResolveReference(string path, string baseFilePath) { throw null; }
    }
    public abstract partial class XmlReferenceResolver
    {
        protected XmlReferenceResolver() { }
        public abstract override bool Equals(object other);
        public abstract override int GetHashCode();
        public abstract System.IO.Stream OpenRead(string resolvedPath);
        public abstract string ResolveReference(string path, string baseFilePath);
    }
}
namespace Microsoft.CodeAnalysis.Diagnostics
{
    public abstract partial class AnalysisContext
    {
        protected AnalysisContext() { }
        public virtual void ConfigureGeneratedCodeAnalysis(Microsoft.CodeAnalysis.Diagnostics.GeneratedCodeAnalysisFlags analysisMode) { }
        public virtual void EnableConcurrentExecution() { }
        public abstract void RegisterCodeBlockAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext> action);
        public abstract void RegisterCodeBlockStartAction<TLanguageKindEnum>(System.Action<Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext<TLanguageKindEnum>> action) where TLanguageKindEnum : struct;
        public abstract void RegisterCompilationAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext> action);
        public abstract void RegisterCompilationStartAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext> action);
        public void RegisterOperationAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext> action, params Microsoft.CodeAnalysis.OperationKind[] operationKinds) { }
        public virtual void RegisterOperationAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext> action, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.OperationKind> operationKinds) { }
        public virtual void RegisterOperationBlockAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext> action) { }
        public virtual void RegisterOperationBlockStartAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext> action) { }
        public abstract void RegisterSemanticModelAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext> action);
        public void RegisterSymbolAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext> action, params Microsoft.CodeAnalysis.SymbolKind[] symbolKinds) { }
        public abstract void RegisterSymbolAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext> action, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SymbolKind> symbolKinds);
        public abstract void RegisterSyntaxNodeAction<TLanguageKindEnum>(System.Action<Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext> action, System.Collections.Immutable.ImmutableArray<TLanguageKindEnum> syntaxKinds) where TLanguageKindEnum : struct;
        public void RegisterSyntaxNodeAction<TLanguageKindEnum>(System.Action<Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds) where TLanguageKindEnum : struct { }
        public abstract void RegisterSyntaxTreeAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext> action);
        public bool TryGetValue<TValue>(Microsoft.CodeAnalysis.Text.SourceText text, Microsoft.CodeAnalysis.Diagnostics.SourceTextValueProvider<TValue> valueProvider, out TValue value) { value = default(TValue); throw null; }
    }
    public partial class AnalysisResult
    {
        internal AnalysisResult() { }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> Analyzers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableDictionary<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo> AnalyzerTelemetryInfo { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableDictionary<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>> CompilationDiagnostics { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableDictionary<Microsoft.CodeAnalysis.SyntaxTree, System.Collections.Immutable.ImmutableDictionary<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>>> SemanticDiagnostics { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableDictionary<Microsoft.CodeAnalysis.SyntaxTree, System.Collections.Immutable.ImmutableDictionary<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>>> SyntaxDiagnostics { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetAllDiagnostics() { throw null; }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetAllDiagnostics(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer analyzer) { throw null; }
    }
    public sealed partial class AnalyzerFileReference : Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference, System.IEquatable<Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference>
    {
        public AnalyzerFileReference(string fullPath, Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader assemblyLoader) { }
        public override string Display { get { throw null; } }
        public override string FullPath { get { throw null; } }
        public override object Id { get { throw null; } }
        public event System.EventHandler<Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs> AnalyzerLoadFailed { add { } remove { } }
        public bool Equals(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> GetAnalyzers(string language) { throw null; }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> GetAnalyzersForAllLanguages() { throw null; }
        public System.Reflection.Assembly GetAssembly() { throw null; }
        public override int GetHashCode() { throw null; }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
    public sealed partial class AnalyzerImageReference : Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference
    {
        public AnalyzerImageReference(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> analyzers, string fullPath=null, string display=null) { }
        public override string Display { get { throw null; } }
        public override string FullPath { get { throw null; } }
        public override object Id { get { throw null; } }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> GetAnalyzers(string language) { throw null; }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> GetAnalyzersForAllLanguages() { throw null; }
    }
    public sealed partial class AnalyzerLoadFailureEventArgs : System.EventArgs
    {
        public AnalyzerLoadFailureEventArgs(Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs.FailureErrorCode errorCode, string message, System.Exception exceptionOpt=null, string typeNameOpt=null) { }
        public Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs.FailureErrorCode ErrorCode { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Exception Exception { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string Message { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string TypeName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public enum FailureErrorCode
        {
            NoAnalyzers = 3,
            None = 0,
            UnableToCreateAnalyzer = 2,
            UnableToLoadAnalyzer = 1,
        }
    }
    public partial class AnalyzerOptions
    {
        public AnalyzerOptions(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.AdditionalText> additionalFiles) { }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.AdditionalText> AdditionalFiles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions WithAdditionalFiles(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.AdditionalText> additionalFiles) { throw null; }
    }
    public abstract partial class AnalyzerReference
    {
        protected AnalyzerReference() { }
        public virtual string Display { get { throw null; } }
        public abstract string FullPath { get; }
        public abstract object Id { get; }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> GetAnalyzers(string language);
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> GetAnalyzersForAllLanguages();
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct CodeBlockAnalysisContext
    {
        public CodeBlockAnalysisContext(Microsoft.CodeAnalysis.SyntaxNode codeBlock, Microsoft.CodeAnalysis.ISymbol owningSymbol, Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Action<Microsoft.CodeAnalysis.Diagnostic> reportDiagnostic, System.Func<Microsoft.CodeAnalysis.Diagnostic, bool> isSupportedDiagnostic, System.Threading.CancellationToken cancellationToken) { throw null;}
        public System.Threading.CancellationToken CancellationToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxNode CodeBlock { get { throw null; } }
        public Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions Options { get { throw null; } }
        public Microsoft.CodeAnalysis.ISymbol OwningSymbol { get { throw null; } }
        public Microsoft.CodeAnalysis.SemanticModel SemanticModel { get { throw null; } }
        public void ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic diagnostic) { }
    }
    public abstract partial class CodeBlockStartAnalysisContext<TLanguageKindEnum> where TLanguageKindEnum : struct
    {
        protected CodeBlockStartAnalysisContext(Microsoft.CodeAnalysis.SyntaxNode codeBlock, Microsoft.CodeAnalysis.ISymbol owningSymbol, Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Threading.CancellationToken cancellationToken) { }
        public System.Threading.CancellationToken CancellationToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxNode CodeBlock { get { throw null; } }
        public Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions Options { get { throw null; } }
        public Microsoft.CodeAnalysis.ISymbol OwningSymbol { get { throw null; } }
        public Microsoft.CodeAnalysis.SemanticModel SemanticModel { get { throw null; } }
        public abstract void RegisterCodeBlockEndAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext> action);
        public abstract void RegisterSyntaxNodeAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext> action, System.Collections.Immutable.ImmutableArray<TLanguageKindEnum> syntaxKinds);
        public void RegisterSyntaxNodeAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds) { }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct CompilationAnalysisContext
    {
        public CompilationAnalysisContext(Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Action<Microsoft.CodeAnalysis.Diagnostic> reportDiagnostic, System.Func<Microsoft.CodeAnalysis.Diagnostic, bool> isSupportedDiagnostic, System.Threading.CancellationToken cancellationToken) { throw null;}
        public System.Threading.CancellationToken CancellationToken { get { throw null; } }
        public Microsoft.CodeAnalysis.Compilation Compilation { get { throw null; } }
        public Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions Options { get { throw null; } }
        public void ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic diagnostic) { }
        public bool TryGetValue<TValue>(Microsoft.CodeAnalysis.SyntaxTree tree, Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeValueProvider<TValue> valueProvider, out TValue value) { value = default(TValue); throw null; }
        public bool TryGetValue<TValue>(Microsoft.CodeAnalysis.Text.SourceText text, Microsoft.CodeAnalysis.Diagnostics.SourceTextValueProvider<TValue> valueProvider, out TValue value) { value = default(TValue); throw null; }
    }
    public abstract partial class CompilationStartAnalysisContext
    {
        protected CompilationStartAnalysisContext(Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Threading.CancellationToken cancellationToken) { }
        public System.Threading.CancellationToken CancellationToken { get { throw null; } }
        public Microsoft.CodeAnalysis.Compilation Compilation { get { throw null; } }
        public Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions Options { get { throw null; } }
        public abstract void RegisterCodeBlockAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext> action);
        public abstract void RegisterCodeBlockStartAction<TLanguageKindEnum>(System.Action<Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext<TLanguageKindEnum>> action) where TLanguageKindEnum : struct;
        public abstract void RegisterCompilationEndAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext> action);
        public void RegisterOperationAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext> action, params Microsoft.CodeAnalysis.OperationKind[] operationKinds) { }
        public virtual void RegisterOperationAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext> action, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.OperationKind> operationKinds) { }
        public virtual void RegisterOperationBlockAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext> action) { }
        public virtual void RegisterOperationBlockStartAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext> action) { }
        public abstract void RegisterSemanticModelAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext> action);
        public void RegisterSymbolAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext> action, params Microsoft.CodeAnalysis.SymbolKind[] symbolKinds) { }
        public abstract void RegisterSymbolAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext> action, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SymbolKind> symbolKinds);
        public abstract void RegisterSyntaxNodeAction<TLanguageKindEnum>(System.Action<Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext> action, System.Collections.Immutable.ImmutableArray<TLanguageKindEnum> syntaxKinds) where TLanguageKindEnum : struct;
        public void RegisterSyntaxNodeAction<TLanguageKindEnum>(System.Action<Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds) where TLanguageKindEnum : struct { }
        public abstract void RegisterSyntaxTreeAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext> action);
        public bool TryGetValue<TValue>(Microsoft.CodeAnalysis.SyntaxTree tree, Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeValueProvider<TValue> valueProvider, out TValue value) { value = default(TValue); throw null; }
        public bool TryGetValue<TValue>(Microsoft.CodeAnalysis.Text.SourceText text, Microsoft.CodeAnalysis.Diagnostics.SourceTextValueProvider<TValue> valueProvider, out TValue value) { value = default(TValue); throw null; }
    }
    public partial class CompilationWithAnalyzers
    {
        public CompilationWithAnalyzers(Microsoft.CodeAnalysis.Compilation compilation, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> analyzers, Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Threading.CancellationToken cancellationToken) { }
        public CompilationWithAnalyzers(Microsoft.CodeAnalysis.Compilation compilation, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> analyzers, Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions analysisOptions) { }
        public Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions AnalysisOptions { get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> Analyzers { get { throw null; } }
        public System.Threading.CancellationToken CancellationToken { get { throw null; } }
        public Microsoft.CodeAnalysis.Compilation Compilation { get { throw null; } }
        public static void ClearAnalyzerState(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> analyzers) { }
        public System.Threading.Tasks.Task<System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>> GetAllDiagnosticsAsync() { throw null; }
        public System.Threading.Tasks.Task<System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>> GetAllDiagnosticsAsync(System.Threading.CancellationToken cancellationToken) { throw null; }
        public System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Diagnostics.AnalysisResult> GetAnalysisResultAsync(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> analyzers, System.Threading.CancellationToken cancellationToken) { throw null; }
        public System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Diagnostics.AnalysisResult> GetAnalysisResultAsync(System.Threading.CancellationToken cancellationToken) { throw null; }
        [System.ObsoleteAttribute("This API was found to have performance issues and hence has been deprecated. Instead, invoke the API 'GetAnalysisResultAsync' and access the property 'CompilationDiagnostics' on the returned 'AnalysisResult' to fetch the compilation diagnostics.")]
        public System.Threading.Tasks.Task<System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>> GetAnalyzerCompilationDiagnosticsAsync(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> analyzers, System.Threading.CancellationToken cancellationToken) { throw null; }
        [System.ObsoleteAttribute("This API was found to have performance issues and hence has been deprecated. Instead, invoke the API 'GetAnalysisResultAsync' and access the property 'CompilationDiagnostics' on the returned 'AnalysisResult' to fetch the compilation diagnostics.")]
        public System.Threading.Tasks.Task<System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>> GetAnalyzerCompilationDiagnosticsAsync(System.Threading.CancellationToken cancellationToken) { throw null; }
        public System.Threading.Tasks.Task<System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>> GetAnalyzerDiagnosticsAsync() { throw null; }
        public System.Threading.Tasks.Task<System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>> GetAnalyzerDiagnosticsAsync(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> analyzers, System.Threading.CancellationToken cancellationToken) { throw null; }
        public System.Threading.Tasks.Task<System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>> GetAnalyzerDiagnosticsAsync(System.Threading.CancellationToken cancellationToken) { throw null; }
        public System.Threading.Tasks.Task<System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>> GetAnalyzerSemanticDiagnosticsAsync(Microsoft.CodeAnalysis.SemanticModel model, System.Nullable<Microsoft.CodeAnalysis.Text.TextSpan> filterSpan, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> analyzers, System.Threading.CancellationToken cancellationToken) { throw null; }
        public System.Threading.Tasks.Task<System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>> GetAnalyzerSemanticDiagnosticsAsync(Microsoft.CodeAnalysis.SemanticModel model, System.Nullable<Microsoft.CodeAnalysis.Text.TextSpan> filterSpan, System.Threading.CancellationToken cancellationToken) { throw null; }
        public System.Threading.Tasks.Task<System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>> GetAnalyzerSyntaxDiagnosticsAsync(Microsoft.CodeAnalysis.SyntaxTree tree, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> analyzers, System.Threading.CancellationToken cancellationToken) { throw null; }
        public System.Threading.Tasks.Task<System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic>> GetAnalyzerSyntaxDiagnosticsAsync(Microsoft.CodeAnalysis.SyntaxTree tree, System.Threading.CancellationToken cancellationToken) { throw null; }
        public System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo> GetAnalyzerTelemetryInfoAsync(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer analyzer, System.Threading.CancellationToken cancellationToken) { throw null; }
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetEffectiveDiagnostics(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> diagnostics, Microsoft.CodeAnalysis.Compilation compilation) { throw null; }
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetEffectiveDiagnostics(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> diagnostics, Microsoft.CodeAnalysis.Compilation compilation) { throw null; }
        public static bool IsDiagnosticAnalyzerSuppressed(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer analyzer, Microsoft.CodeAnalysis.CompilationOptions options, System.Action<System.Exception, Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, Microsoft.CodeAnalysis.Diagnostic> onAnalyzerException=null) { throw null; }
    }
    public sealed partial class CompilationWithAnalyzersOptions
    {
        public CompilationWithAnalyzersOptions(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Action<System.Exception, Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, Microsoft.CodeAnalysis.Diagnostic> onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime) { }
        public CompilationWithAnalyzersOptions(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Action<System.Exception, Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, Microsoft.CodeAnalysis.Diagnostic> onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime, bool reportSuppressedDiagnostics) { }
        public CompilationWithAnalyzersOptions(Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Action<System.Exception, Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, Microsoft.CodeAnalysis.Diagnostic> onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime, bool reportSuppressedDiagnostics, System.Func<System.Exception, bool> analyzerExceptionFilter) { }
        public System.Func<System.Exception, bool> AnalyzerExceptionFilter { get { throw null; } }
        public bool ConcurrentAnalysis { get { throw null; } }
        public bool LogAnalyzerExecutionTime { get { throw null; } }
        public System.Action<System.Exception, Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, Microsoft.CodeAnalysis.Diagnostic> OnAnalyzerException { get { throw null; } }
        public Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions Options { get { throw null; } }
        public bool ReportSuppressedDiagnostics { get { throw null; } }
    }
    public abstract partial class DiagnosticAnalyzer
    {
        protected DiagnosticAnalyzer() { }
        public abstract System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.DiagnosticDescriptor> SupportedDiagnostics { get; }
        public sealed override bool Equals(object obj) { throw null; }
        public sealed override int GetHashCode() { throw null; }
        public abstract void Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext context);
        public sealed override string ToString() { throw null; }
    }
    [System.AttributeUsageAttribute((System.AttributeTargets)(4))]
    public sealed partial class DiagnosticAnalyzerAttribute : System.Attribute
    {
        public DiagnosticAnalyzerAttribute(string firstLanguage, params string[] additionalLanguages) { }
        public string[] Languages { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
    }
    public static partial class DiagnosticAnalyzerExtensions
    {
        public static Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers WithAnalyzers(this Microsoft.CodeAnalysis.Compilation compilation, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> analyzers, Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options=null, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers WithAnalyzers(this Microsoft.CodeAnalysis.Compilation compilation, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> analyzers, Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions analysisOptions) { throw null; }
    }
    [System.FlagsAttribute]
    public enum GeneratedCodeAnalysisFlags
    {
        Analyze = 1,
        None = 0,
        ReportDiagnostics = 2,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct OperationAnalysisContext
    {
        public OperationAnalysisContext(Microsoft.CodeAnalysis.IOperation operation, Microsoft.CodeAnalysis.ISymbol containingSymbol, Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Action<Microsoft.CodeAnalysis.Diagnostic> reportDiagnostic, System.Func<Microsoft.CodeAnalysis.Diagnostic, bool> isSupportedDiagnostic, System.Threading.CancellationToken cancellationToken) { throw null;}
        public System.Threading.CancellationToken CancellationToken { get { throw null; } }
        public Microsoft.CodeAnalysis.Compilation Compilation { get { throw null; } }
        public Microsoft.CodeAnalysis.ISymbol ContainingSymbol { get { throw null; } }
        public Microsoft.CodeAnalysis.IOperation Operation { get { throw null; } }
        public Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions Options { get { throw null; } }
        public void ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic diagnostic) { }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct OperationBlockAnalysisContext
    {
        public OperationBlockAnalysisContext(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IOperation> operationBlocks, Microsoft.CodeAnalysis.ISymbol owningSymbol, Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Action<Microsoft.CodeAnalysis.Diagnostic> reportDiagnostic, System.Func<Microsoft.CodeAnalysis.Diagnostic, bool> isSupportedDiagnostic, System.Threading.CancellationToken cancellationToken) { throw null;}
        public System.Threading.CancellationToken CancellationToken { get { throw null; } }
        public Microsoft.CodeAnalysis.Compilation Compilation { get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IOperation> OperationBlocks { get { throw null; } }
        public Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions Options { get { throw null; } }
        public Microsoft.CodeAnalysis.ISymbol OwningSymbol { get { throw null; } }
        public void ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic diagnostic) { }
    }
    public abstract partial class OperationBlockStartAnalysisContext
    {
        protected OperationBlockStartAnalysisContext(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IOperation> operationBlocks, Microsoft.CodeAnalysis.ISymbol owningSymbol, Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Threading.CancellationToken cancellationToken) { }
        public System.Threading.CancellationToken CancellationToken { get { throw null; } }
        public Microsoft.CodeAnalysis.Compilation Compilation { get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IOperation> OperationBlocks { get { throw null; } }
        public Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions Options { get { throw null; } }
        public Microsoft.CodeAnalysis.ISymbol OwningSymbol { get { throw null; } }
        public void RegisterOperationAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext> action, params Microsoft.CodeAnalysis.OperationKind[] operationKinds) { }
        public abstract void RegisterOperationAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext> action, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.OperationKind> operationKinds);
        public abstract void RegisterOperationBlockEndAction(System.Action<Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext> action);
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct SemanticModelAnalysisContext
    {
        public SemanticModelAnalysisContext(Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Action<Microsoft.CodeAnalysis.Diagnostic> reportDiagnostic, System.Func<Microsoft.CodeAnalysis.Diagnostic, bool> isSupportedDiagnostic, System.Threading.CancellationToken cancellationToken) { throw null;}
        public System.Threading.CancellationToken CancellationToken { get { throw null; } }
        public Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions Options { get { throw null; } }
        public Microsoft.CodeAnalysis.SemanticModel SemanticModel { get { throw null; } }
        public void ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic diagnostic) { }
    }
    public sealed partial class SourceTextValueProvider<TValue>
    {
        public SourceTextValueProvider(System.Func<Microsoft.CodeAnalysis.Text.SourceText, TValue> computeValue, System.Collections.Generic.IEqualityComparer<Microsoft.CodeAnalysis.Text.SourceText> sourceTextComparer=null) { }
    }
    public sealed partial class SuppressionInfo
    {
        internal SuppressionInfo() { }
        public Microsoft.CodeAnalysis.AttributeData Attribute { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string Id { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct SymbolAnalysisContext
    {
        public SymbolAnalysisContext(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Action<Microsoft.CodeAnalysis.Diagnostic> reportDiagnostic, System.Func<Microsoft.CodeAnalysis.Diagnostic, bool> isSupportedDiagnostic, System.Threading.CancellationToken cancellationToken) { throw null;}
        public System.Threading.CancellationToken CancellationToken { get { throw null; } }
        public Microsoft.CodeAnalysis.Compilation Compilation { get { throw null; } }
        public Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions Options { get { throw null; } }
        public Microsoft.CodeAnalysis.ISymbol Symbol { get { throw null; } }
        public void ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic diagnostic) { }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct SyntaxNodeAnalysisContext
    {
        public SyntaxNodeAnalysisContext(Microsoft.CodeAnalysis.SyntaxNode node, Microsoft.CodeAnalysis.ISymbol containingSymbol, Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Action<Microsoft.CodeAnalysis.Diagnostic> reportDiagnostic, System.Func<Microsoft.CodeAnalysis.Diagnostic, bool> isSupportedDiagnostic, System.Threading.CancellationToken cancellationToken) { throw null;}
        public SyntaxNodeAnalysisContext(Microsoft.CodeAnalysis.SyntaxNode node, Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Action<Microsoft.CodeAnalysis.Diagnostic> reportDiagnostic, System.Func<Microsoft.CodeAnalysis.Diagnostic, bool> isSupportedDiagnostic, System.Threading.CancellationToken cancellationToken) { throw null;}
        public System.Threading.CancellationToken CancellationToken { get { throw null; } }
        public Microsoft.CodeAnalysis.Compilation Compilation { get { throw null; } }
        public Microsoft.CodeAnalysis.ISymbol ContainingSymbol { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxNode Node { get { throw null; } }
        public Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions Options { get { throw null; } }
        public Microsoft.CodeAnalysis.SemanticModel SemanticModel { get { throw null; } }
        public void ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic diagnostic) { }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct SyntaxTreeAnalysisContext
    {
        public SyntaxTreeAnalysisContext(Microsoft.CodeAnalysis.SyntaxTree tree, Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions options, System.Action<Microsoft.CodeAnalysis.Diagnostic> reportDiagnostic, System.Func<Microsoft.CodeAnalysis.Diagnostic, bool> isSupportedDiagnostic, System.Threading.CancellationToken cancellationToken) { throw null;}
        public System.Threading.CancellationToken CancellationToken { get { throw null; } }
        public Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions Options { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTree Tree { get { throw null; } }
        public void ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic diagnostic) { }
    }
    public sealed partial class SyntaxTreeValueProvider<TValue>
    {
        public SyntaxTreeValueProvider(System.Func<Microsoft.CodeAnalysis.SyntaxTree, TValue> computeValue, System.Collections.Generic.IEqualityComparer<Microsoft.CodeAnalysis.SyntaxTree> syntaxTreeComparer=null) { }
    }
    public sealed partial class UnresolvedAnalyzerReference : Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference
    {
        public UnresolvedAnalyzerReference(string unresolvedPath) { }
        public override string Display { get { throw null; } }
        public override string FullPath { get { throw null; } }
        public override object Id { get { throw null; } }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> GetAnalyzers(string language) { throw null; }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> GetAnalyzersForAllLanguages() { throw null; }
    }
}
namespace Microsoft.CodeAnalysis.Diagnostics.Telemetry
{
    public sealed partial class AnalyzerTelemetryInfo
    {
        internal AnalyzerTelemetryInfo() { }
        public int CodeBlockActionsCount { get { throw null; } }
        public int CodeBlockEndActionsCount { get { throw null; } }
        public int CodeBlockStartActionsCount { get { throw null; } }
        public int CompilationActionsCount { get { throw null; } }
        public int CompilationEndActionsCount { get { throw null; } }
        public int CompilationStartActionsCount { get { throw null; } }
        public System.TimeSpan ExecutionTime { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public int OperationActionsCount { get { throw null; } }
        public int OperationBlockActionsCount { get { throw null; } }
        public int OperationBlockEndActionsCount { get { throw null; } }
        public int OperationBlockStartActionsCount { get { throw null; } }
        public int SemanticModelActionsCount { get { throw null; } }
        public int SymbolActionsCount { get { throw null; } }
        public int SyntaxNodeActionsCount { get { throw null; } }
        public int SyntaxTreeActionsCount { get { throw null; } }
    }
}
namespace Microsoft.CodeAnalysis.Emit
{
    public enum DebugInformationFormat
    {
        Embedded = 3,
        Pdb = 1,
        PortablePdb = 2,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct EditAndContinueMethodDebugInformation
    {
        public static Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation Create(System.Collections.Immutable.ImmutableArray<byte> compressedSlotMap, System.Collections.Immutable.ImmutableArray<byte> compressedLambdaMap) { throw null; }
    }
    public sealed partial class EmitBaseline
    {
        internal EmitBaseline() { }
        public Microsoft.CodeAnalysis.ModuleMetadata OriginalMetadata { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.Emit.EmitBaseline CreateInitialBaseline(Microsoft.CodeAnalysis.ModuleMetadata module, System.Func<System.Reflection.Metadata.MethodDefinitionHandle, Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation> debugInformationProvider) { throw null; }
    }
    public sealed partial class EmitDifferenceResult : Microsoft.CodeAnalysis.Emit.EmitResult
    {
        internal EmitDifferenceResult() { }
        public Microsoft.CodeAnalysis.Emit.EmitBaseline Baseline { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
    }
    public sealed partial class EmitOptions : System.IEquatable<Microsoft.CodeAnalysis.Emit.EmitOptions>
    {
        public EmitOptions(bool metadataOnly=false, Microsoft.CodeAnalysis.Emit.DebugInformationFormat debugInformationFormat=(Microsoft.CodeAnalysis.Emit.DebugInformationFormat)(0), string pdbFilePath=null, string outputNameOverride=null, int fileAlignment=0, ulong baseAddress=(ulong)0, bool highEntropyVirtualAddressSpace=false, Microsoft.CodeAnalysis.SubsystemVersion subsystemVersion=default(Microsoft.CodeAnalysis.SubsystemVersion), string runtimeMetadataVersion=null, bool tolerateErrors=false, bool includePrivateMembers=false) { }
        public ulong BaseAddress { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.Emit.DebugInformationFormat DebugInformationFormat { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool EmitMetadataOnly { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public int FileAlignment { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool HighEntropyVirtualAddressSpace { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool IncludePrivateMembers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string OutputNameOverride { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string PdbFilePath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public string RuntimeMetadataVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.SubsystemVersion SubsystemVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool TolerateErrors { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.Emit.EmitOptions other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.Emit.EmitOptions left, Microsoft.CodeAnalysis.Emit.EmitOptions right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.Emit.EmitOptions left, Microsoft.CodeAnalysis.Emit.EmitOptions right) { throw null; }
        public Microsoft.CodeAnalysis.Emit.EmitOptions WithBaseAddress(ulong value) { throw null; }
        public Microsoft.CodeAnalysis.Emit.EmitOptions WithDebugInformationFormat(Microsoft.CodeAnalysis.Emit.DebugInformationFormat format) { throw null; }
        public Microsoft.CodeAnalysis.Emit.EmitOptions WithEmitMetadataOnly(bool value) { throw null; }
        public Microsoft.CodeAnalysis.Emit.EmitOptions WithFileAlignment(int value) { throw null; }
        public Microsoft.CodeAnalysis.Emit.EmitOptions WithHighEntropyVirtualAddressSpace(bool value) { throw null; }
        public Microsoft.CodeAnalysis.Emit.EmitOptions WithIncludePrivateMembers(bool value) { throw null; }
        public Microsoft.CodeAnalysis.Emit.EmitOptions WithOutputNameOverride(string outputName) { throw null; }
        public Microsoft.CodeAnalysis.Emit.EmitOptions WithPdbFilePath(string path) { throw null; }
        public Microsoft.CodeAnalysis.Emit.EmitOptions WithRuntimeMetadataVersion(string version) { throw null; }
        public Microsoft.CodeAnalysis.Emit.EmitOptions WithSubsystemVersion(Microsoft.CodeAnalysis.SubsystemVersion subsystemVersion) { throw null; }
        public Microsoft.CodeAnalysis.Emit.EmitOptions WithTolerateErrors(bool value) { throw null; }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
    public partial class EmitResult
    {
        internal EmitResult() { }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> Diagnostics { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool Success { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        protected virtual string GetDebuggerDisplay() { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct SemanticEdit : System.IEquatable<Microsoft.CodeAnalysis.Emit.SemanticEdit>
    {
        public SemanticEdit(Microsoft.CodeAnalysis.Emit.SemanticEditKind kind, Microsoft.CodeAnalysis.ISymbol oldSymbol, Microsoft.CodeAnalysis.ISymbol newSymbol, System.Func<Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SyntaxNode> syntaxMap=null, bool preserveLocalVariables=false) { throw null;}
        public Microsoft.CodeAnalysis.Emit.SemanticEditKind Kind { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.ISymbol NewSymbol { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.ISymbol OldSymbol { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool PreserveLocalVariables { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public System.Func<Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SyntaxNode> SyntaxMap { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.Emit.SemanticEdit other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    public enum SemanticEditKind
    {
        Delete = 3,
        Insert = 2,
        None = 0,
        Update = 1,
    }
}
namespace Microsoft.CodeAnalysis.Semantics
{
    public enum ArgumentKind
    {
        DefaultValue = 4,
        Named = 2,
        None = 0,
        ParamArray = 3,
        Positional = 1,
    }
    public enum BinaryOperandsKind
    {
        Boolean = 1536,
        Decimal = 1280,
        Delegate = 3584,
        Dynamic = 2048,
        Enum = 1792,
        Floating = 1024,
        Integer = 512,
        IntegerPointer = 3072,
        Invalid = 65280,
        None = 0,
        Nullable = 3840,
        Object = 2304,
        OperatorMethod = 256,
        Pointer = 2560,
        PointerInteger = 2816,
        String = 3328,
        Unsigned = 768,
    }
    public enum BinaryOperationKind
    {
        BooleanAnd = 1546,
        BooleanConditionalAnd = 1549,
        BooleanConditionalOr = 1550,
        BooleanEquals = 1552,
        BooleanExclusiveOr = 1548,
        BooleanNotEquals = 1554,
        BooleanOr = 1547,
        DecimalAdd = 1281,
        DecimalDivide = 1284,
        DecimalEquals = 1296,
        DecimalGreaterThan = 1303,
        DecimalGreaterThanOrEqual = 1302,
        DecimalLessThan = 1300,
        DecimalLessThanOrEqual = 1301,
        DecimalMultiply = 1283,
        DecimalNotEquals = 1298,
        DecimalSubtract = 1282,
        DelegateEquals = 3600,
        DelegateNotEquals = 3602,
        DynamicAdd = 2049,
        DynamicAnd = 2058,
        DynamicDivide = 2052,
        DynamicEquals = 2064,
        DynamicExclusiveOr = 2060,
        DynamicGreaterThan = 2071,
        DynamicGreaterThanOrEqual = 2070,
        DynamicLeftShift = 2056,
        DynamicLessThan = 2068,
        DynamicLessThanOrEqual = 2069,
        DynamicMultiply = 2051,
        DynamicNotEquals = 2066,
        DynamicOr = 2059,
        DynamicRemainder = 2054,
        DynamicRightShift = 2057,
        DynamicSubtract = 2050,
        EnumAdd = 1793,
        EnumAnd = 1802,
        EnumEquals = 1808,
        EnumExclusiveOr = 1804,
        EnumGreaterThan = 1815,
        EnumGreaterThanOrEqual = 1814,
        EnumLessThan = 1812,
        EnumLessThanOrEqual = 1813,
        EnumNotEquals = 1810,
        EnumOr = 1803,
        EnumSubtract = 1794,
        FloatingAdd = 1025,
        FloatingDivide = 1028,
        FloatingEquals = 1040,
        FloatingGreaterThan = 1047,
        FloatingGreaterThanOrEqual = 1046,
        FloatingLessThan = 1044,
        FloatingLessThanOrEqual = 1045,
        FloatingMultiply = 1027,
        FloatingNotEquals = 1042,
        FloatingPower = 1031,
        FloatingRemainder = 1030,
        FloatingSubtract = 1026,
        IntegerAdd = 513,
        IntegerAnd = 522,
        IntegerDivide = 516,
        IntegerEquals = 528,
        IntegerExclusiveOr = 524,
        IntegerGreaterThan = 535,
        IntegerGreaterThanOrEqual = 534,
        IntegerLeftShift = 520,
        IntegerLessThan = 532,
        IntegerLessThanOrEqual = 533,
        IntegerMultiply = 515,
        IntegerNotEquals = 530,
        IntegerOr = 523,
        IntegerPointerAdd = 3073,
        IntegerRemainder = 518,
        IntegerRightShift = 521,
        IntegerSubtract = 514,
        Invalid = 65535,
        None = 0,
        NullableEquals = 3856,
        NullableNotEquals = 3858,
        ObjectAdd = 2305,
        ObjectAnd = 2314,
        ObjectConcatenate = 2319,
        ObjectConditionalAnd = 2317,
        ObjectConditionalOr = 2318,
        ObjectDivide = 2308,
        ObjectEquals = 2320,
        ObjectExclusiveOr = 2316,
        ObjectGreaterThan = 2327,
        ObjectGreaterThanOrEqual = 2326,
        ObjectIntegerDivide = 2309,
        ObjectLeftShift = 2312,
        ObjectLessThan = 2324,
        ObjectLessThanOrEqual = 2325,
        ObjectLike = 2328,
        ObjectMultiply = 2307,
        ObjectNotEquals = 2322,
        ObjectOr = 2315,
        ObjectPower = 2311,
        ObjectRemainder = 2310,
        ObjectRightShift = 2313,
        ObjectSubtract = 2306,
        ObjectVBEquals = 2321,
        ObjectVBNotEquals = 2323,
        OperatorMethodAdd = 257,
        OperatorMethodAnd = 266,
        OperatorMethodConditionalAnd = 269,
        OperatorMethodConditionalOr = 270,
        OperatorMethodDivide = 260,
        OperatorMethodEquals = 272,
        OperatorMethodExclusiveOr = 268,
        OperatorMethodGreaterThan = 279,
        OperatorMethodGreaterThanOrEqual = 278,
        OperatorMethodIntegerDivide = 261,
        OperatorMethodLeftShift = 264,
        OperatorMethodLessThan = 276,
        OperatorMethodLessThanOrEqual = 277,
        OperatorMethodMultiply = 259,
        OperatorMethodNotEquals = 274,
        OperatorMethodOr = 267,
        OperatorMethodPower = 263,
        OperatorMethodRemainder = 262,
        OperatorMethodRightShift = 265,
        OperatorMethodSubtract = 258,
        PointerEquals = 2576,
        PointerGreaterThan = 2583,
        PointerGreaterThanOrEqual = 2582,
        PointerIntegerAdd = 2817,
        PointerIntegerSubtract = 2818,
        PointerLessThan = 2580,
        PointerLessThanOrEqual = 2581,
        PointerNotEquals = 2578,
        PointerSubtract = 2562,
        StringConcatenate = 3343,
        StringEquals = 3344,
        StringLike = 3352,
        StringNotEquals = 3346,
        UnsignedAdd = 769,
        UnsignedAnd = 778,
        UnsignedDivide = 772,
        UnsignedExclusiveOr = 780,
        UnsignedGreaterThan = 791,
        UnsignedGreaterThanOrEqual = 790,
        UnsignedLeftShift = 776,
        UnsignedLessThan = 788,
        UnsignedLessThanOrEqual = 789,
        UnsignedMultiply = 771,
        UnsignedOr = 779,
        UnsignedRemainder = 774,
        UnsignedRightShift = 777,
        UnsignedSubtract = 770,
    }
    public enum BranchKind
    {
        Break = 2,
        Continue = 1,
        GoTo = 3,
        None = 0,
    }
    public enum CaseKind
    {
        Default = 4,
        None = 0,
        Range = 3,
        Relational = 2,
        SingleValue = 1,
    }
    public enum ConversionKind
    {
        Basic = 3,
        Cast = 1,
        CSharp = 4,
        Invalid = 15,
        None = 0,
        OperatorMethod = 5,
        TryCast = 2,
    }
    public partial interface IAddressOfExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation Reference { get; }
    }
    public partial interface IArgument : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.Semantics.ArgumentKind ArgumentKind { get; }
        Microsoft.CodeAnalysis.IOperation InConversion { get; }
        Microsoft.CodeAnalysis.IOperation OutConversion { get; }
        Microsoft.CodeAnalysis.IParameterSymbol Parameter { get; }
        Microsoft.CodeAnalysis.IOperation Value { get; }
    }
    public partial interface IArrayCreationExpression : Microsoft.CodeAnalysis.IOperation
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IOperation> DimensionSizes { get; }
        Microsoft.CodeAnalysis.ITypeSymbol ElementType { get; }
        Microsoft.CodeAnalysis.Semantics.IArrayInitializer Initializer { get; }
    }
    public partial interface IArrayElementReferenceExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation ArrayReference { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IOperation> Indices { get; }
    }
    public partial interface IArrayInitializer : Microsoft.CodeAnalysis.IOperation
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IOperation> ElementValues { get; }
    }
    public partial interface IAssignmentExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation Target { get; }
        Microsoft.CodeAnalysis.IOperation Value { get; }
    }
    public partial interface IAwaitExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation AwaitedValue { get; }
    }
    public partial interface IBinaryOperatorExpression : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression
    {
        Microsoft.CodeAnalysis.Semantics.BinaryOperationKind BinaryOperationKind { get; }
        Microsoft.CodeAnalysis.IOperation LeftOperand { get; }
        Microsoft.CodeAnalysis.IOperation RightOperand { get; }
    }
    public partial interface IBlockStatement : Microsoft.CodeAnalysis.IOperation
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ILocalSymbol> Locals { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IOperation> Statements { get; }
    }
    public partial interface IBranchStatement : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.Semantics.BranchKind BranchKind { get; }
        Microsoft.CodeAnalysis.ILabelSymbol Target { get; }
    }
    public partial interface ICaseClause : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.Semantics.CaseKind CaseKind { get; }
    }
    public partial interface ICatchClause : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.ITypeSymbol CaughtType { get; }
        Microsoft.CodeAnalysis.ILocalSymbol ExceptionLocal { get; }
        Microsoft.CodeAnalysis.IOperation Filter { get; }
        Microsoft.CodeAnalysis.Semantics.IBlockStatement Handler { get; }
    }
    public partial interface ICompoundAssignmentExpression : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.IAssignmentExpression, Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression
    {
        Microsoft.CodeAnalysis.Semantics.BinaryOperationKind BinaryOperationKind { get; }
    }
    public partial interface IConditionalAccessExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation ConditionalInstance { get; }
        Microsoft.CodeAnalysis.IOperation ConditionalValue { get; }
    }
    public partial interface IConditionalAccessInstanceExpression : Microsoft.CodeAnalysis.IOperation
    {
    }
    public partial interface IConditionalChoiceExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation Condition { get; }
        Microsoft.CodeAnalysis.IOperation IfFalseValue { get; }
        Microsoft.CodeAnalysis.IOperation IfTrueValue { get; }
    }
    public partial interface IConversionExpression : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression
    {
        Microsoft.CodeAnalysis.Semantics.ConversionKind ConversionKind { get; }
        bool IsExplicit { get; }
        Microsoft.CodeAnalysis.IOperation Operand { get; }
    }
    public partial interface IDefaultValueExpression : Microsoft.CodeAnalysis.IOperation
    {
    }
    public partial interface IEmptyStatement : Microsoft.CodeAnalysis.IOperation
    {
    }
    public partial interface IEndStatement : Microsoft.CodeAnalysis.IOperation
    {
    }
    public partial interface IEventAssignmentExpression : Microsoft.CodeAnalysis.IOperation
    {
        bool Adds { get; }
        Microsoft.CodeAnalysis.IEventSymbol Event { get; }
        Microsoft.CodeAnalysis.IOperation EventInstance { get; }
        Microsoft.CodeAnalysis.IOperation HandlerValue { get; }
    }
    public partial interface IEventReferenceExpression : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression
    {
        Microsoft.CodeAnalysis.IEventSymbol Event { get; }
    }
    public partial interface IExpressionStatement : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation Expression { get; }
    }
    public partial interface IFieldInitializer : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.ISymbolInitializer
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IFieldSymbol> InitializedFields { get; }
    }
    public partial interface IFieldReferenceExpression : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression
    {
        Microsoft.CodeAnalysis.IFieldSymbol Field { get; }
    }
    public partial interface IFixedStatement : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation Body { get; }
        Microsoft.CodeAnalysis.Semantics.IVariableDeclarationStatement Variables { get; }
    }
    public partial interface IForEachLoopStatement : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.ILoopStatement
    {
        Microsoft.CodeAnalysis.IOperation Collection { get; }
        Microsoft.CodeAnalysis.ILocalSymbol IterationVariable { get; }
    }
    public partial interface IForLoopStatement : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.IForWhileUntilLoopStatement, Microsoft.CodeAnalysis.Semantics.ILoopStatement
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IOperation> AtLoopBottom { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IOperation> Before { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ILocalSymbol> Locals { get; }
    }
    public partial interface IForWhileUntilLoopStatement : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.ILoopStatement
    {
        Microsoft.CodeAnalysis.IOperation Condition { get; }
    }
    public partial interface IHasArgumentsExpression : Microsoft.CodeAnalysis.IOperation
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Semantics.IArgument> ArgumentsInParameterOrder { get; }
        Microsoft.CodeAnalysis.Semantics.IArgument GetArgumentMatchingParameter(Microsoft.CodeAnalysis.IParameterSymbol parameter);
    }
    public partial interface IHasOperatorMethodExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IMethodSymbol OperatorMethod { get; }
        bool UsesOperatorMethod { get; }
    }
    public partial interface IIfStatement : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation Condition { get; }
        Microsoft.CodeAnalysis.IOperation IfFalseStatement { get; }
        Microsoft.CodeAnalysis.IOperation IfTrueStatement { get; }
    }
    public partial interface IIncrementExpression : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.IAssignmentExpression, Microsoft.CodeAnalysis.Semantics.ICompoundAssignmentExpression, Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression
    {
        Microsoft.CodeAnalysis.Semantics.UnaryOperationKind IncrementOperationKind { get; }
    }
    public partial interface IIndexedPropertyReferenceExpression : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression, Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression, Microsoft.CodeAnalysis.Semantics.IPropertyReferenceExpression
    {
    }
    public partial interface IInstanceReferenceExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.Semantics.InstanceReferenceKind InstanceReferenceKind { get; }
    }
    public partial interface IInvalidExpression : Microsoft.CodeAnalysis.IOperation
    {
    }
    public partial interface IInvalidStatement : Microsoft.CodeAnalysis.IOperation
    {
    }
    public partial interface IInvocationExpression : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Semantics.IArgument> ArgumentsInSourceOrder { get; }
        Microsoft.CodeAnalysis.IOperation Instance { get; }
        bool IsVirtual { get; }
        Microsoft.CodeAnalysis.IMethodSymbol TargetMethod { get; }
    }
    public partial interface IIsTypeExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.ITypeSymbol IsType { get; }
        Microsoft.CodeAnalysis.IOperation Operand { get; }
    }
    public partial interface ILabelStatement : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.ILabelSymbol Label { get; }
        Microsoft.CodeAnalysis.IOperation LabeledStatement { get; }
    }
    public partial interface ILambdaExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.Semantics.IBlockStatement Body { get; }
        Microsoft.CodeAnalysis.IMethodSymbol Signature { get; }
    }
    public partial interface ILateBoundMemberReferenceExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation Instance { get; }
        string MemberName { get; }
    }
    public partial interface ILiteralExpression : Microsoft.CodeAnalysis.IOperation
    {
        string Text { get; }
    }
    public partial interface ILocalReferenceExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.ILocalSymbol Local { get; }
    }
    public partial interface ILockStatement : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation Body { get; }
        Microsoft.CodeAnalysis.IOperation LockedObject { get; }
    }
    public partial interface ILoopStatement : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation Body { get; }
        Microsoft.CodeAnalysis.Semantics.LoopKind LoopKind { get; }
    }
    public partial interface IMemberReferenceExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation Instance { get; }
        Microsoft.CodeAnalysis.ISymbol Member { get; }
    }
    public partial interface IMethodBindingExpression : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression
    {
        bool IsVirtual { get; }
        Microsoft.CodeAnalysis.IMethodSymbol Method { get; }
    }
    public enum InstanceReferenceKind
    {
        BaseClass = 3,
        Explicit = 2,
        Implicit = 1,
        None = 0,
        ThisClass = 4,
    }
    public partial interface INullCoalescingExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation PrimaryOperand { get; }
        Microsoft.CodeAnalysis.IOperation SecondaryOperand { get; }
    }
    public partial interface IObjectCreationExpression : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression
    {
        Microsoft.CodeAnalysis.IMethodSymbol Constructor { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Semantics.ISymbolInitializer> MemberInitializers { get; }
    }
    public partial interface IOmittedArgumentExpression : Microsoft.CodeAnalysis.IOperation
    {
    }
    public partial interface IParameterInitializer : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.ISymbolInitializer
    {
        Microsoft.CodeAnalysis.IParameterSymbol Parameter { get; }
    }
    public partial interface IParameterReferenceExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IParameterSymbol Parameter { get; }
    }
    public partial interface IParenthesizedExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation Operand { get; }
    }
    public partial interface IPlaceholderExpression : Microsoft.CodeAnalysis.IOperation
    {
    }
    public partial interface IPointerIndirectionReferenceExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation Pointer { get; }
    }
    public partial interface IPropertyInitializer : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.ISymbolInitializer
    {
        Microsoft.CodeAnalysis.IPropertySymbol InitializedProperty { get; }
    }
    public partial interface IPropertyReferenceExpression : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression
    {
        Microsoft.CodeAnalysis.IPropertySymbol Property { get; }
    }
    public partial interface IRangeCaseClause : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.ICaseClause
    {
        Microsoft.CodeAnalysis.IOperation MaximumValue { get; }
        Microsoft.CodeAnalysis.IOperation MinimumValue { get; }
    }
    public partial interface IRelationalCaseClause : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.ICaseClause
    {
        Microsoft.CodeAnalysis.Semantics.BinaryOperationKind Relation { get; }
        Microsoft.CodeAnalysis.IOperation Value { get; }
    }
    public partial interface IReturnStatement : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation ReturnedValue { get; }
    }
    public partial interface ISingleValueCaseClause : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.ICaseClause
    {
        Microsoft.CodeAnalysis.Semantics.BinaryOperationKind Equality { get; }
        Microsoft.CodeAnalysis.IOperation Value { get; }
    }
    public partial interface ISizeOfExpression : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.ITypeOperationExpression
    {
    }
    public partial interface IStopStatement : Microsoft.CodeAnalysis.IOperation
    {
    }
    public partial interface ISwitchCase : Microsoft.CodeAnalysis.IOperation
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IOperation> Body { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Semantics.ICaseClause> Clauses { get; }
    }
    public partial interface ISwitchStatement : Microsoft.CodeAnalysis.IOperation
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Semantics.ISwitchCase> Cases { get; }
        Microsoft.CodeAnalysis.IOperation Value { get; }
    }
    public partial interface ISymbolInitializer : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation Value { get; }
    }
    public partial interface ISyntheticLocalReferenceExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation ContainingStatement { get; }
        Microsoft.CodeAnalysis.Semantics.SyntheticLocalKind SyntheticLocalKind { get; }
    }
    public partial interface IThrowStatement : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation ThrownObject { get; }
    }
    public partial interface ITryStatement : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.Semantics.IBlockStatement Body { get; }
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Semantics.ICatchClause> Catches { get; }
        Microsoft.CodeAnalysis.Semantics.IBlockStatement FinallyHandler { get; }
    }
    public partial interface ITypeOfExpression : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.ITypeOperationExpression
    {
    }
    public partial interface ITypeOperationExpression : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.ITypeSymbol TypeOperand { get; }
    }
    public partial interface ITypeParameterObjectCreationExpression : Microsoft.CodeAnalysis.IOperation
    {
    }
    public partial interface IUnaryOperatorExpression : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression
    {
        Microsoft.CodeAnalysis.IOperation Operand { get; }
        Microsoft.CodeAnalysis.Semantics.UnaryOperationKind UnaryOperationKind { get; }
    }
    public partial interface IUnboundLambdaExpression : Microsoft.CodeAnalysis.IOperation
    {
    }
    public partial interface IUsingStatement : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation Body { get; }
        Microsoft.CodeAnalysis.Semantics.IVariableDeclarationStatement Declaration { get; }
        Microsoft.CodeAnalysis.IOperation Value { get; }
    }
    public partial interface IVariableDeclaration : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation InitialValue { get; }
        Microsoft.CodeAnalysis.ILocalSymbol Variable { get; }
    }
    public partial interface IVariableDeclarationStatement : Microsoft.CodeAnalysis.IOperation
    {
        System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Semantics.IVariableDeclaration> Variables { get; }
    }
    public partial interface IWhileUntilLoopStatement : Microsoft.CodeAnalysis.IOperation, Microsoft.CodeAnalysis.Semantics.IForWhileUntilLoopStatement, Microsoft.CodeAnalysis.Semantics.ILoopStatement
    {
        bool IsTopTest { get; }
        bool IsWhile { get; }
    }
    public partial interface IWithStatement : Microsoft.CodeAnalysis.IOperation
    {
        Microsoft.CodeAnalysis.IOperation Body { get; }
        Microsoft.CodeAnalysis.IOperation Value { get; }
    }
    public enum LoopKind
    {
        For = 2,
        ForEach = 3,
        None = 0,
        WhileUntil = 1,
    }
    public static partial class OperationExtensions
    {
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.IOperation> Descendants(this Microsoft.CodeAnalysis.IOperation operation) { throw null; }
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.IOperation> DescendantsAndSelf(this Microsoft.CodeAnalysis.IOperation operation) { throw null; }
        public static Microsoft.CodeAnalysis.IOperation GetRootOperation(this Microsoft.CodeAnalysis.ISymbol symbol, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
    }
    public abstract partial class OperationVisitor
    {
        protected OperationVisitor() { }
        public virtual void DefaultVisit(Microsoft.CodeAnalysis.IOperation operation) { }
        public virtual void Visit(Microsoft.CodeAnalysis.IOperation operation) { }
        public virtual void VisitAddressOfExpression(Microsoft.CodeAnalysis.Semantics.IAddressOfExpression operation) { }
        public virtual void VisitArgument(Microsoft.CodeAnalysis.Semantics.IArgument operation) { }
        public virtual void VisitArrayCreationExpression(Microsoft.CodeAnalysis.Semantics.IArrayCreationExpression operation) { }
        public virtual void VisitArrayElementReferenceExpression(Microsoft.CodeAnalysis.Semantics.IArrayElementReferenceExpression operation) { }
        public virtual void VisitArrayInitializer(Microsoft.CodeAnalysis.Semantics.IArrayInitializer operation) { }
        public virtual void VisitAssignmentExpression(Microsoft.CodeAnalysis.Semantics.IAssignmentExpression operation) { }
        public virtual void VisitAwaitExpression(Microsoft.CodeAnalysis.Semantics.IAwaitExpression operation) { }
        public virtual void VisitBinaryOperatorExpression(Microsoft.CodeAnalysis.Semantics.IBinaryOperatorExpression operation) { }
        public virtual void VisitBlockStatement(Microsoft.CodeAnalysis.Semantics.IBlockStatement operation) { }
        public virtual void VisitBranchStatement(Microsoft.CodeAnalysis.Semantics.IBranchStatement operation) { }
        public virtual void VisitCatch(Microsoft.CodeAnalysis.Semantics.ICatchClause operation) { }
        public virtual void VisitCompoundAssignmentExpression(Microsoft.CodeAnalysis.Semantics.ICompoundAssignmentExpression operation) { }
        public virtual void VisitConditionalAccessExpression(Microsoft.CodeAnalysis.Semantics.IConditionalAccessExpression operation) { }
        public virtual void VisitConditionalAccessInstanceExpression(Microsoft.CodeAnalysis.Semantics.IConditionalAccessInstanceExpression operation) { }
        public virtual void VisitConditionalChoiceExpression(Microsoft.CodeAnalysis.Semantics.IConditionalChoiceExpression operation) { }
        public virtual void VisitConversionExpression(Microsoft.CodeAnalysis.Semantics.IConversionExpression operation) { }
        public virtual void VisitDefaultValueExpression(Microsoft.CodeAnalysis.Semantics.IDefaultValueExpression operation) { }
        public virtual void VisitEmptyStatement(Microsoft.CodeAnalysis.Semantics.IEmptyStatement operation) { }
        public virtual void VisitEndStatement(Microsoft.CodeAnalysis.Semantics.IEndStatement operation) { }
        public virtual void VisitEventAssignmentExpression(Microsoft.CodeAnalysis.Semantics.IEventAssignmentExpression operation) { }
        public virtual void VisitEventReferenceExpression(Microsoft.CodeAnalysis.Semantics.IEventReferenceExpression operation) { }
        public virtual void VisitExpressionStatement(Microsoft.CodeAnalysis.Semantics.IExpressionStatement operation) { }
        public virtual void VisitFieldInitializer(Microsoft.CodeAnalysis.Semantics.IFieldInitializer operation) { }
        public virtual void VisitFieldReferenceExpression(Microsoft.CodeAnalysis.Semantics.IFieldReferenceExpression operation) { }
        public virtual void VisitFixedStatement(Microsoft.CodeAnalysis.Semantics.IFixedStatement operation) { }
        public virtual void VisitForEachLoopStatement(Microsoft.CodeAnalysis.Semantics.IForEachLoopStatement operation) { }
        public virtual void VisitForLoopStatement(Microsoft.CodeAnalysis.Semantics.IForLoopStatement operation) { }
        public virtual void VisitIfStatement(Microsoft.CodeAnalysis.Semantics.IIfStatement operation) { }
        public virtual void VisitIncrementExpression(Microsoft.CodeAnalysis.Semantics.IIncrementExpression operation) { }
        public virtual void VisitIndexedPropertyReferenceExpression(Microsoft.CodeAnalysis.Semantics.IIndexedPropertyReferenceExpression operation) { }
        public virtual void VisitInstanceReferenceExpression(Microsoft.CodeAnalysis.Semantics.IInstanceReferenceExpression operation) { }
        public virtual void VisitInvalidExpression(Microsoft.CodeAnalysis.Semantics.IInvalidExpression operation) { }
        public virtual void VisitInvalidStatement(Microsoft.CodeAnalysis.Semantics.IInvalidStatement operation) { }
        public virtual void VisitInvocationExpression(Microsoft.CodeAnalysis.Semantics.IInvocationExpression operation) { }
        public virtual void VisitIsTypeExpression(Microsoft.CodeAnalysis.Semantics.IIsTypeExpression operation) { }
        public virtual void VisitLabelStatement(Microsoft.CodeAnalysis.Semantics.ILabelStatement operation) { }
        public virtual void VisitLambdaExpression(Microsoft.CodeAnalysis.Semantics.ILambdaExpression operation) { }
        public virtual void VisitLateBoundMemberReferenceExpression(Microsoft.CodeAnalysis.Semantics.ILateBoundMemberReferenceExpression operation) { }
        public virtual void VisitLiteralExpression(Microsoft.CodeAnalysis.Semantics.ILiteralExpression operation) { }
        public virtual void VisitLocalReferenceExpression(Microsoft.CodeAnalysis.Semantics.ILocalReferenceExpression operation) { }
        public virtual void VisitLockStatement(Microsoft.CodeAnalysis.Semantics.ILockStatement operation) { }
        public virtual void VisitMethodBindingExpression(Microsoft.CodeAnalysis.Semantics.IMethodBindingExpression operation) { }
        public virtual void VisitNullCoalescingExpression(Microsoft.CodeAnalysis.Semantics.INullCoalescingExpression operation) { }
        public virtual void VisitObjectCreationExpression(Microsoft.CodeAnalysis.Semantics.IObjectCreationExpression operation) { }
        public virtual void VisitOmittedArgumentExpression(Microsoft.CodeAnalysis.Semantics.IOmittedArgumentExpression operation) { }
        public virtual void VisitParameterInitializer(Microsoft.CodeAnalysis.Semantics.IParameterInitializer operation) { }
        public virtual void VisitParameterReferenceExpression(Microsoft.CodeAnalysis.Semantics.IParameterReferenceExpression operation) { }
        public virtual void VisitParenthesizedExpression(Microsoft.CodeAnalysis.Semantics.IParenthesizedExpression operation) { }
        public virtual void VisitPlaceholderExpression(Microsoft.CodeAnalysis.Semantics.IPlaceholderExpression operation) { }
        public virtual void VisitPointerIndirectionReferenceExpression(Microsoft.CodeAnalysis.Semantics.IPointerIndirectionReferenceExpression operation) { }
        public virtual void VisitPropertyInitializer(Microsoft.CodeAnalysis.Semantics.IPropertyInitializer operation) { }
        public virtual void VisitPropertyReferenceExpression(Microsoft.CodeAnalysis.Semantics.IPropertyReferenceExpression operation) { }
        public virtual void VisitRangeCaseClause(Microsoft.CodeAnalysis.Semantics.IRangeCaseClause operation) { }
        public virtual void VisitRelationalCaseClause(Microsoft.CodeAnalysis.Semantics.IRelationalCaseClause operation) { }
        public virtual void VisitReturnStatement(Microsoft.CodeAnalysis.Semantics.IReturnStatement operation) { }
        public virtual void VisitSingleValueCaseClause(Microsoft.CodeAnalysis.Semantics.ISingleValueCaseClause operation) { }
        public virtual void VisitSizeOfExpression(Microsoft.CodeAnalysis.Semantics.ISizeOfExpression operation) { }
        public virtual void VisitStopStatement(Microsoft.CodeAnalysis.Semantics.IStopStatement operation) { }
        public virtual void VisitSwitchCase(Microsoft.CodeAnalysis.Semantics.ISwitchCase operation) { }
        public virtual void VisitSwitchStatement(Microsoft.CodeAnalysis.Semantics.ISwitchStatement operation) { }
        public virtual void VisitSyntheticLocalReferenceExpression(Microsoft.CodeAnalysis.Semantics.ISyntheticLocalReferenceExpression operation) { }
        public virtual void VisitThrowStatement(Microsoft.CodeAnalysis.Semantics.IThrowStatement operation) { }
        public virtual void VisitTryStatement(Microsoft.CodeAnalysis.Semantics.ITryStatement operation) { }
        public virtual void VisitTypeOfExpression(Microsoft.CodeAnalysis.Semantics.ITypeOfExpression operation) { }
        public virtual void VisitTypeParameterObjectCreationExpression(Microsoft.CodeAnalysis.Semantics.ITypeParameterObjectCreationExpression operation) { }
        public virtual void VisitUnaryOperatorExpression(Microsoft.CodeAnalysis.Semantics.IUnaryOperatorExpression operation) { }
        public virtual void VisitUnboundLambdaExpression(Microsoft.CodeAnalysis.Semantics.IUnboundLambdaExpression operation) { }
        public virtual void VisitUsingStatement(Microsoft.CodeAnalysis.Semantics.IUsingStatement operation) { }
        public virtual void VisitVariableDeclaration(Microsoft.CodeAnalysis.Semantics.IVariableDeclaration operation) { }
        public virtual void VisitVariableDeclarationStatement(Microsoft.CodeAnalysis.Semantics.IVariableDeclarationStatement operation) { }
        public virtual void VisitWhileUntilLoopStatement(Microsoft.CodeAnalysis.Semantics.IWhileUntilLoopStatement operation) { }
        public virtual void VisitWithStatement(Microsoft.CodeAnalysis.Semantics.IWithStatement operation) { }
        public virtual void VisitYieldBreakStatement(Microsoft.CodeAnalysis.Semantics.IReturnStatement operation) { }
    }
    public abstract partial class OperationVisitor<TArgument, TResult>
    {
        protected OperationVisitor() { }
        public virtual TResult DefaultVisit(Microsoft.CodeAnalysis.IOperation operation, TArgument argument) { throw null; }
        public virtual TResult Visit(Microsoft.CodeAnalysis.IOperation operation, TArgument argument) { throw null; }
        public virtual TResult VisitAddressOfExpression(Microsoft.CodeAnalysis.Semantics.IAddressOfExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitArgument(Microsoft.CodeAnalysis.Semantics.IArgument operation, TArgument argument) { throw null; }
        public virtual TResult VisitArrayCreationExpression(Microsoft.CodeAnalysis.Semantics.IArrayCreationExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitArrayElementReferenceExpression(Microsoft.CodeAnalysis.Semantics.IArrayElementReferenceExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitArrayInitializer(Microsoft.CodeAnalysis.Semantics.IArrayInitializer operation, TArgument argument) { throw null; }
        public virtual TResult VisitAssignmentExpression(Microsoft.CodeAnalysis.Semantics.IAssignmentExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitAwaitExpression(Microsoft.CodeAnalysis.Semantics.IAwaitExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitBinaryOperatorExpression(Microsoft.CodeAnalysis.Semantics.IBinaryOperatorExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitBlockStatement(Microsoft.CodeAnalysis.Semantics.IBlockStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitBranchStatement(Microsoft.CodeAnalysis.Semantics.IBranchStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitCatch(Microsoft.CodeAnalysis.Semantics.ICatchClause operation, TArgument argument) { throw null; }
        public virtual TResult VisitCompoundAssignmentExpression(Microsoft.CodeAnalysis.Semantics.ICompoundAssignmentExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitConditionalAccessExpression(Microsoft.CodeAnalysis.Semantics.IConditionalAccessExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitConditionalAccessInstanceExpression(Microsoft.CodeAnalysis.Semantics.IConditionalAccessInstanceExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitConditionalChoiceExpression(Microsoft.CodeAnalysis.Semantics.IConditionalChoiceExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitConversionExpression(Microsoft.CodeAnalysis.Semantics.IConversionExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitDefaultValueExpression(Microsoft.CodeAnalysis.Semantics.IDefaultValueExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitEmptyStatement(Microsoft.CodeAnalysis.Semantics.IEmptyStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitEndStatement(Microsoft.CodeAnalysis.Semantics.IEndStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitEventAssignmentExpression(Microsoft.CodeAnalysis.Semantics.IEventAssignmentExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitEventReferenceExpression(Microsoft.CodeAnalysis.Semantics.IEventReferenceExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitExpressionStatement(Microsoft.CodeAnalysis.Semantics.IExpressionStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitFieldInitializer(Microsoft.CodeAnalysis.Semantics.IFieldInitializer operation, TArgument argument) { throw null; }
        public virtual TResult VisitFieldReferenceExpression(Microsoft.CodeAnalysis.Semantics.IFieldReferenceExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitFixedStatement(Microsoft.CodeAnalysis.Semantics.IFixedStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitForEachLoopStatement(Microsoft.CodeAnalysis.Semantics.IForEachLoopStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitForLoopStatement(Microsoft.CodeAnalysis.Semantics.IForLoopStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitIfStatement(Microsoft.CodeAnalysis.Semantics.IIfStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitIncrementExpression(Microsoft.CodeAnalysis.Semantics.IIncrementExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitIndexedPropertyReferenceExpression(Microsoft.CodeAnalysis.Semantics.IIndexedPropertyReferenceExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitInstanceReferenceExpression(Microsoft.CodeAnalysis.Semantics.IInstanceReferenceExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitInvalidExpression(Microsoft.CodeAnalysis.Semantics.IInvalidExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitInvalidStatement(Microsoft.CodeAnalysis.Semantics.IInvalidStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitInvocationExpression(Microsoft.CodeAnalysis.Semantics.IInvocationExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitIsTypeExpression(Microsoft.CodeAnalysis.Semantics.IIsTypeExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitLabelStatement(Microsoft.CodeAnalysis.Semantics.ILabelStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitLambdaExpression(Microsoft.CodeAnalysis.Semantics.ILambdaExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitLateBoundMemberReferenceExpression(Microsoft.CodeAnalysis.Semantics.ILateBoundMemberReferenceExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitLiteralExpression(Microsoft.CodeAnalysis.Semantics.ILiteralExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitLocalReferenceExpression(Microsoft.CodeAnalysis.Semantics.ILocalReferenceExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitLockStatement(Microsoft.CodeAnalysis.Semantics.ILockStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitMethodBindingExpression(Microsoft.CodeAnalysis.Semantics.IMethodBindingExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitNullCoalescingExpression(Microsoft.CodeAnalysis.Semantics.INullCoalescingExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitObjectCreationExpression(Microsoft.CodeAnalysis.Semantics.IObjectCreationExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitOmittedArgumentExpression(Microsoft.CodeAnalysis.Semantics.IOmittedArgumentExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitParameterInitializer(Microsoft.CodeAnalysis.Semantics.IParameterInitializer operation, TArgument argument) { throw null; }
        public virtual TResult VisitParameterReferenceExpression(Microsoft.CodeAnalysis.Semantics.IParameterReferenceExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitParenthesizedExpression(Microsoft.CodeAnalysis.Semantics.IParenthesizedExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitPlaceholderExpression(Microsoft.CodeAnalysis.Semantics.IPlaceholderExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitPointerIndirectionReferenceExpression(Microsoft.CodeAnalysis.Semantics.IPointerIndirectionReferenceExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitPropertyInitializer(Microsoft.CodeAnalysis.Semantics.IPropertyInitializer operation, TArgument argument) { throw null; }
        public virtual TResult VisitPropertyReferenceExpression(Microsoft.CodeAnalysis.Semantics.IPropertyReferenceExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitRangeCaseClause(Microsoft.CodeAnalysis.Semantics.IRangeCaseClause operation, TArgument argument) { throw null; }
        public virtual TResult VisitRelationalCaseClause(Microsoft.CodeAnalysis.Semantics.IRelationalCaseClause operation, TArgument argument) { throw null; }
        public virtual TResult VisitReturnStatement(Microsoft.CodeAnalysis.Semantics.IReturnStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitSingleValueCaseClause(Microsoft.CodeAnalysis.Semantics.ISingleValueCaseClause operation, TArgument argument) { throw null; }
        public virtual TResult VisitSizeOfExpression(Microsoft.CodeAnalysis.Semantics.ISizeOfExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitStopStatement(Microsoft.CodeAnalysis.Semantics.IStopStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitSwitchCase(Microsoft.CodeAnalysis.Semantics.ISwitchCase operation, TArgument argument) { throw null; }
        public virtual TResult VisitSwitchStatement(Microsoft.CodeAnalysis.Semantics.ISwitchStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitSyntheticLocalReferenceExpression(Microsoft.CodeAnalysis.Semantics.ISyntheticLocalReferenceExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitThrowStatement(Microsoft.CodeAnalysis.Semantics.IThrowStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitTryStatement(Microsoft.CodeAnalysis.Semantics.ITryStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitTypeOfExpression(Microsoft.CodeAnalysis.Semantics.ITypeOfExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitTypeParameterObjectCreationExpression(Microsoft.CodeAnalysis.Semantics.ITypeParameterObjectCreationExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitUnaryOperatorExpression(Microsoft.CodeAnalysis.Semantics.IUnaryOperatorExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitUnboundLambdaExpression(Microsoft.CodeAnalysis.Semantics.IUnboundLambdaExpression operation, TArgument argument) { throw null; }
        public virtual TResult VisitUsingStatement(Microsoft.CodeAnalysis.Semantics.IUsingStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitVariableDeclaration(Microsoft.CodeAnalysis.Semantics.IVariableDeclaration operation, TArgument argument) { throw null; }
        public virtual TResult VisitVariableDeclarationStatement(Microsoft.CodeAnalysis.Semantics.IVariableDeclarationStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitWhileUntilLoopStatement(Microsoft.CodeAnalysis.Semantics.IWhileUntilLoopStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitWithStatement(Microsoft.CodeAnalysis.Semantics.IWithStatement operation, TArgument argument) { throw null; }
        public virtual TResult VisitYieldBreakStatement(Microsoft.CodeAnalysis.Semantics.IReturnStatement operation, TArgument argument) { throw null; }
    }
    public abstract partial class OperationWalker : Microsoft.CodeAnalysis.Semantics.OperationVisitor
    {
        protected OperationWalker() { }
        public override void Visit(Microsoft.CodeAnalysis.IOperation operation) { }
        public override void VisitAddressOfExpression(Microsoft.CodeAnalysis.Semantics.IAddressOfExpression operation) { }
        public override void VisitArgument(Microsoft.CodeAnalysis.Semantics.IArgument operation) { }
        public override void VisitArrayCreationExpression(Microsoft.CodeAnalysis.Semantics.IArrayCreationExpression operation) { }
        public override void VisitArrayElementReferenceExpression(Microsoft.CodeAnalysis.Semantics.IArrayElementReferenceExpression operation) { }
        public override void VisitArrayInitializer(Microsoft.CodeAnalysis.Semantics.IArrayInitializer operation) { }
        public override void VisitAssignmentExpression(Microsoft.CodeAnalysis.Semantics.IAssignmentExpression operation) { }
        public override void VisitAwaitExpression(Microsoft.CodeAnalysis.Semantics.IAwaitExpression operation) { }
        public override void VisitBinaryOperatorExpression(Microsoft.CodeAnalysis.Semantics.IBinaryOperatorExpression operation) { }
        public override void VisitBlockStatement(Microsoft.CodeAnalysis.Semantics.IBlockStatement operation) { }
        public override void VisitBranchStatement(Microsoft.CodeAnalysis.Semantics.IBranchStatement operation) { }
        public override void VisitCatch(Microsoft.CodeAnalysis.Semantics.ICatchClause operation) { }
        public override void VisitCompoundAssignmentExpression(Microsoft.CodeAnalysis.Semantics.ICompoundAssignmentExpression operation) { }
        public override void VisitConditionalAccessExpression(Microsoft.CodeAnalysis.Semantics.IConditionalAccessExpression operation) { }
        public override void VisitConditionalAccessInstanceExpression(Microsoft.CodeAnalysis.Semantics.IConditionalAccessInstanceExpression operation) { }
        public override void VisitConditionalChoiceExpression(Microsoft.CodeAnalysis.Semantics.IConditionalChoiceExpression operation) { }
        public override void VisitConversionExpression(Microsoft.CodeAnalysis.Semantics.IConversionExpression operation) { }
        public override void VisitDefaultValueExpression(Microsoft.CodeAnalysis.Semantics.IDefaultValueExpression operation) { }
        public override void VisitEmptyStatement(Microsoft.CodeAnalysis.Semantics.IEmptyStatement operation) { }
        public override void VisitEndStatement(Microsoft.CodeAnalysis.Semantics.IEndStatement operation) { }
        public override void VisitEventAssignmentExpression(Microsoft.CodeAnalysis.Semantics.IEventAssignmentExpression operation) { }
        public override void VisitEventReferenceExpression(Microsoft.CodeAnalysis.Semantics.IEventReferenceExpression operation) { }
        public override void VisitExpressionStatement(Microsoft.CodeAnalysis.Semantics.IExpressionStatement operation) { }
        public override void VisitFieldInitializer(Microsoft.CodeAnalysis.Semantics.IFieldInitializer operation) { }
        public override void VisitFieldReferenceExpression(Microsoft.CodeAnalysis.Semantics.IFieldReferenceExpression operation) { }
        public override void VisitFixedStatement(Microsoft.CodeAnalysis.Semantics.IFixedStatement operation) { }
        public override void VisitForEachLoopStatement(Microsoft.CodeAnalysis.Semantics.IForEachLoopStatement operation) { }
        public override void VisitForLoopStatement(Microsoft.CodeAnalysis.Semantics.IForLoopStatement operation) { }
        public override void VisitIfStatement(Microsoft.CodeAnalysis.Semantics.IIfStatement operation) { }
        public override void VisitIncrementExpression(Microsoft.CodeAnalysis.Semantics.IIncrementExpression operation) { }
        public override void VisitIndexedPropertyReferenceExpression(Microsoft.CodeAnalysis.Semantics.IIndexedPropertyReferenceExpression operation) { }
        public override void VisitInstanceReferenceExpression(Microsoft.CodeAnalysis.Semantics.IInstanceReferenceExpression operation) { }
        public override void VisitInvalidExpression(Microsoft.CodeAnalysis.Semantics.IInvalidExpression operation) { }
        public override void VisitInvalidStatement(Microsoft.CodeAnalysis.Semantics.IInvalidStatement operation) { }
        public override void VisitInvocationExpression(Microsoft.CodeAnalysis.Semantics.IInvocationExpression operation) { }
        public override void VisitIsTypeExpression(Microsoft.CodeAnalysis.Semantics.IIsTypeExpression operation) { }
        public override void VisitLabelStatement(Microsoft.CodeAnalysis.Semantics.ILabelStatement operation) { }
        public override void VisitLambdaExpression(Microsoft.CodeAnalysis.Semantics.ILambdaExpression operation) { }
        public override void VisitLateBoundMemberReferenceExpression(Microsoft.CodeAnalysis.Semantics.ILateBoundMemberReferenceExpression operation) { }
        public override void VisitLiteralExpression(Microsoft.CodeAnalysis.Semantics.ILiteralExpression operation) { }
        public override void VisitLocalReferenceExpression(Microsoft.CodeAnalysis.Semantics.ILocalReferenceExpression operation) { }
        public override void VisitLockStatement(Microsoft.CodeAnalysis.Semantics.ILockStatement operation) { }
        public override void VisitMethodBindingExpression(Microsoft.CodeAnalysis.Semantics.IMethodBindingExpression operation) { }
        public override void VisitNullCoalescingExpression(Microsoft.CodeAnalysis.Semantics.INullCoalescingExpression operation) { }
        public override void VisitObjectCreationExpression(Microsoft.CodeAnalysis.Semantics.IObjectCreationExpression operation) { }
        public override void VisitOmittedArgumentExpression(Microsoft.CodeAnalysis.Semantics.IOmittedArgumentExpression operation) { }
        public override void VisitParameterInitializer(Microsoft.CodeAnalysis.Semantics.IParameterInitializer operation) { }
        public override void VisitParameterReferenceExpression(Microsoft.CodeAnalysis.Semantics.IParameterReferenceExpression operation) { }
        public override void VisitParenthesizedExpression(Microsoft.CodeAnalysis.Semantics.IParenthesizedExpression operation) { }
        public override void VisitPlaceholderExpression(Microsoft.CodeAnalysis.Semantics.IPlaceholderExpression operation) { }
        public override void VisitPointerIndirectionReferenceExpression(Microsoft.CodeAnalysis.Semantics.IPointerIndirectionReferenceExpression operation) { }
        public override void VisitPropertyInitializer(Microsoft.CodeAnalysis.Semantics.IPropertyInitializer operation) { }
        public override void VisitPropertyReferenceExpression(Microsoft.CodeAnalysis.Semantics.IPropertyReferenceExpression operation) { }
        public override void VisitRangeCaseClause(Microsoft.CodeAnalysis.Semantics.IRangeCaseClause operation) { }
        public override void VisitRelationalCaseClause(Microsoft.CodeAnalysis.Semantics.IRelationalCaseClause operation) { }
        public override void VisitReturnStatement(Microsoft.CodeAnalysis.Semantics.IReturnStatement operation) { }
        public override void VisitSingleValueCaseClause(Microsoft.CodeAnalysis.Semantics.ISingleValueCaseClause operation) { }
        public override void VisitSizeOfExpression(Microsoft.CodeAnalysis.Semantics.ISizeOfExpression operation) { }
        public override void VisitStopStatement(Microsoft.CodeAnalysis.Semantics.IStopStatement operation) { }
        public override void VisitSwitchCase(Microsoft.CodeAnalysis.Semantics.ISwitchCase operation) { }
        public override void VisitSwitchStatement(Microsoft.CodeAnalysis.Semantics.ISwitchStatement operation) { }
        public override void VisitSyntheticLocalReferenceExpression(Microsoft.CodeAnalysis.Semantics.ISyntheticLocalReferenceExpression operation) { }
        public override void VisitThrowStatement(Microsoft.CodeAnalysis.Semantics.IThrowStatement operation) { }
        public override void VisitTryStatement(Microsoft.CodeAnalysis.Semantics.ITryStatement operation) { }
        public override void VisitTypeOfExpression(Microsoft.CodeAnalysis.Semantics.ITypeOfExpression operation) { }
        public override void VisitTypeParameterObjectCreationExpression(Microsoft.CodeAnalysis.Semantics.ITypeParameterObjectCreationExpression operation) { }
        public override void VisitUnaryOperatorExpression(Microsoft.CodeAnalysis.Semantics.IUnaryOperatorExpression operation) { }
        public override void VisitUnboundLambdaExpression(Microsoft.CodeAnalysis.Semantics.IUnboundLambdaExpression operation) { }
        public override void VisitUsingStatement(Microsoft.CodeAnalysis.Semantics.IUsingStatement operation) { }
        public override void VisitVariableDeclaration(Microsoft.CodeAnalysis.Semantics.IVariableDeclaration operation) { }
        public override void VisitVariableDeclarationStatement(Microsoft.CodeAnalysis.Semantics.IVariableDeclarationStatement operation) { }
        public override void VisitWhileUntilLoopStatement(Microsoft.CodeAnalysis.Semantics.IWhileUntilLoopStatement operation) { }
        public override void VisitWithStatement(Microsoft.CodeAnalysis.Semantics.IWithStatement operation) { }
        public override void VisitYieldBreakStatement(Microsoft.CodeAnalysis.Semantics.IReturnStatement operation) { }
    }
    public enum SimpleBinaryOperationKind
    {
        Add = 1,
        And = 10,
        Concatenate = 15,
        ConditionalAnd = 13,
        ConditionalOr = 14,
        Divide = 4,
        Equals = 16,
        ExclusiveOr = 12,
        GreaterThan = 23,
        GreaterThanOrEqual = 22,
        IntegerDivide = 5,
        Invalid = 255,
        LeftShift = 8,
        LessThan = 20,
        LessThanOrEqual = 21,
        Like = 24,
        Multiply = 3,
        None = 0,
        NotEquals = 18,
        ObjectValueEquals = 17,
        ObjectValueNotEquals = 19,
        Or = 11,
        Power = 7,
        Remainder = 6,
        RightShift = 9,
        Subtract = 2,
    }
    public enum SimpleUnaryOperationKind
    {
        BitwiseNegation = 1,
        BitwiseOrLogicalNot = 11,
        False = 10,
        Invalid = 255,
        LogicalNot = 2,
        Minus = 8,
        None = 0,
        Plus = 7,
        PostfixDecrement = 4,
        PostfixIncrement = 3,
        PrefixDecrement = 6,
        PrefixIncrement = 5,
        True = 9,
    }
    public enum SyntheticLocalKind
    {
        ForLoopLimitValue = 2,
        ForLoopStepValue = 1,
        None = 0,
    }
    public static partial class UnaryAndBinaryOperationExtensions
    {
        public static Microsoft.CodeAnalysis.Semantics.BinaryOperandsKind GetBinaryOperandsKind(Microsoft.CodeAnalysis.Semantics.BinaryOperationKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.Semantics.BinaryOperandsKind GetBinaryOperandsKind(this Microsoft.CodeAnalysis.Semantics.IBinaryOperatorExpression binary) { throw null; }
        public static Microsoft.CodeAnalysis.Semantics.BinaryOperandsKind GetBinaryOperandsKind(this Microsoft.CodeAnalysis.Semantics.ICompoundAssignmentExpression compoundAssignment) { throw null; }
        public static Microsoft.CodeAnalysis.Semantics.SimpleBinaryOperationKind GetSimpleBinaryOperationKind(Microsoft.CodeAnalysis.Semantics.BinaryOperationKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.Semantics.SimpleBinaryOperationKind GetSimpleBinaryOperationKind(this Microsoft.CodeAnalysis.Semantics.IBinaryOperatorExpression binary) { throw null; }
        public static Microsoft.CodeAnalysis.Semantics.SimpleBinaryOperationKind GetSimpleBinaryOperationKind(this Microsoft.CodeAnalysis.Semantics.ICompoundAssignmentExpression compoundAssignment) { throw null; }
        public static Microsoft.CodeAnalysis.Semantics.SimpleUnaryOperationKind GetSimpleUnaryOperationKind(this Microsoft.CodeAnalysis.Semantics.IIncrementExpression increment) { throw null; }
        public static Microsoft.CodeAnalysis.Semantics.SimpleUnaryOperationKind GetSimpleUnaryOperationKind(this Microsoft.CodeAnalysis.Semantics.IUnaryOperatorExpression unary) { throw null; }
        public static Microsoft.CodeAnalysis.Semantics.SimpleUnaryOperationKind GetSimpleUnaryOperationKind(Microsoft.CodeAnalysis.Semantics.UnaryOperationKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.Semantics.UnaryOperandKind GetUnaryOperandKind(this Microsoft.CodeAnalysis.Semantics.IIncrementExpression increment) { throw null; }
        public static Microsoft.CodeAnalysis.Semantics.UnaryOperandKind GetUnaryOperandKind(this Microsoft.CodeAnalysis.Semantics.IUnaryOperatorExpression unary) { throw null; }
        public static Microsoft.CodeAnalysis.Semantics.UnaryOperandKind GetUnaryOperandKind(Microsoft.CodeAnalysis.Semantics.UnaryOperationKind kind) { throw null; }
    }
    public enum UnaryOperandKind
    {
        Boolean = 1536,
        Decimal = 1280,
        Dynamic = 2048,
        Enum = 1792,
        Floating = 1024,
        Integer = 512,
        Invalid = 65280,
        None = 0,
        Object = 2304,
        OperatorMethod = 256,
        Pointer = 2560,
        Unsigned = 768,
    }
    public enum UnaryOperationKind
    {
        BooleanBitwiseNegation = 1537,
        BooleanLogicalNot = 1538,
        DecimalMinus = 1288,
        DecimalPlus = 1287,
        DecimalPostfixDecrement = 1284,
        DecimalPostfixIncrement = 1283,
        DecimalPrefixDecrement = 1286,
        DecimalPrefixIncrement = 1285,
        DynamicBitwiseNegation = 2049,
        DynamicFalse = 2058,
        DynamicLogicalNot = 2050,
        DynamicMinus = 2056,
        DynamicPlus = 2055,
        DynamicPostfixDecrement = 2052,
        DynamicPostfixIncrement = 2051,
        DynamicPrefixDecrement = 2054,
        DynamicPrefixIncrement = 2053,
        DynamicTrue = 2057,
        EnumPostfixDecrement = 1796,
        EnumPostfixIncrement = 1795,
        EnumPrefixDecrement = 1798,
        EnumPrefixIncrement = 1797,
        FloatingMinus = 1032,
        FloatingPlus = 1031,
        FloatingPostfixDecrement = 1028,
        FloatingPostfixIncrement = 1027,
        FloatingPrefixDecrement = 1030,
        FloatingPrefixIncrement = 1029,
        IntegerBitwiseNegation = 513,
        IntegerMinus = 520,
        IntegerPlus = 519,
        IntegerPostfixDecrement = 516,
        IntegerPostfixIncrement = 515,
        IntegerPrefixDecrement = 518,
        IntegerPrefixIncrement = 517,
        Invalid = 65535,
        None = 0,
        ObjectMinus = 2312,
        ObjectNot = 2315,
        ObjectPlus = 2311,
        OperatorMethodBitwiseNegation = 257,
        OperatorMethodFalse = 266,
        OperatorMethodLogicalNot = 258,
        OperatorMethodMinus = 264,
        OperatorMethodPlus = 263,
        OperatorMethodPostfixDecrement = 260,
        OperatorMethodPostfixIncrement = 259,
        OperatorMethodPrefixDecrement = 262,
        OperatorMethodPrefixIncrement = 261,
        OperatorMethodTrue = 265,
        PointerPostfixDecrement = 2564,
        PointerPostfixIncrement = 2563,
        PointerPrefixDecrement = 2566,
        PointerPrefixIncrement = 2565,
        UnsignedPostfixDecrement = 772,
        UnsignedPostfixIncrement = 771,
        UnsignedPrefixDecrement = 774,
        UnsignedPrefixIncrement = 773,
    }
}
namespace Microsoft.CodeAnalysis.Text
{
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct LinePosition : System.IComparable<Microsoft.CodeAnalysis.Text.LinePosition>, System.IEquatable<Microsoft.CodeAnalysis.Text.LinePosition>
    {
        public LinePosition(int line, int character) { throw null;}
        public int Character { get { throw null; } }
        public int Line { get { throw null; } }
        public static Microsoft.CodeAnalysis.Text.LinePosition Zero { get { throw null; } }
        public int CompareTo(Microsoft.CodeAnalysis.Text.LinePosition other) { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.Text.LinePosition other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.Text.LinePosition left, Microsoft.CodeAnalysis.Text.LinePosition right) { throw null; }
        public static bool operator >(Microsoft.CodeAnalysis.Text.LinePosition left, Microsoft.CodeAnalysis.Text.LinePosition right) { throw null; }
        public static bool operator >=(Microsoft.CodeAnalysis.Text.LinePosition left, Microsoft.CodeAnalysis.Text.LinePosition right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.Text.LinePosition left, Microsoft.CodeAnalysis.Text.LinePosition right) { throw null; }
        public static bool operator <(Microsoft.CodeAnalysis.Text.LinePosition left, Microsoft.CodeAnalysis.Text.LinePosition right) { throw null; }
        public static bool operator <=(Microsoft.CodeAnalysis.Text.LinePosition left, Microsoft.CodeAnalysis.Text.LinePosition right) { throw null; }
        public override string ToString() { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct LinePositionSpan : System.IEquatable<Microsoft.CodeAnalysis.Text.LinePositionSpan>
    {
        public LinePositionSpan(Microsoft.CodeAnalysis.Text.LinePosition start, Microsoft.CodeAnalysis.Text.LinePosition end) { throw null;}
        public Microsoft.CodeAnalysis.Text.LinePosition End { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.LinePosition Start { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.Text.LinePositionSpan other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.Text.LinePositionSpan left, Microsoft.CodeAnalysis.Text.LinePositionSpan right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.Text.LinePositionSpan left, Microsoft.CodeAnalysis.Text.LinePositionSpan right) { throw null; }
        public override string ToString() { throw null; }
    }
    public enum SourceHashAlgorithm
    {
        None = 0,
        Sha1 = 1,
        Sha256 = 2,
    }
    public abstract partial class SourceText
    {
        protected SourceText(System.Collections.Immutable.ImmutableArray<byte> checksum=default(System.Collections.Immutable.ImmutableArray<byte>), Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm=(Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)(1), Microsoft.CodeAnalysis.Text.SourceTextContainer container=null) { }
        public Microsoft.CodeAnalysis.Text.SourceHashAlgorithm ChecksumAlgorithm { get { throw null; } }
        public virtual Microsoft.CodeAnalysis.Text.SourceTextContainer Container { get { throw null; } }
        public abstract System.Text.Encoding Encoding { get; }
        public abstract char this[int position] { get; }
        public abstract int Length { get; }
        public Microsoft.CodeAnalysis.Text.TextLineCollection Lines { get { throw null; } }
        public bool ContentEquals(Microsoft.CodeAnalysis.Text.SourceText other) { throw null; }
        protected virtual bool ContentEqualsImpl(Microsoft.CodeAnalysis.Text.SourceText other) { throw null; }
        public abstract void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count);
        public static Microsoft.CodeAnalysis.Text.SourceText From(byte[] buffer, int length, System.Text.Encoding encoding=null, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm=(Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)(1), bool throwIfBinaryDetected=false) { throw null; }
        public static Microsoft.CodeAnalysis.Text.SourceText From(System.IO.Stream stream, System.Text.Encoding encoding=null, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm=(Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)(1), bool throwIfBinaryDetected=false) { throw null; }
        public static Microsoft.CodeAnalysis.Text.SourceText From(string text, System.Text.Encoding encoding=null, Microsoft.CodeAnalysis.Text.SourceHashAlgorithm checksumAlgorithm=(Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)(1)) { throw null; }
        public virtual System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Text.TextChangeRange> GetChangeRanges(Microsoft.CodeAnalysis.Text.SourceText oldText) { throw null; }
        protected virtual Microsoft.CodeAnalysis.Text.TextLineCollection GetLinesCore() { throw null; }
        public virtual Microsoft.CodeAnalysis.Text.SourceText GetSubText(Microsoft.CodeAnalysis.Text.TextSpan span) { throw null; }
        public Microsoft.CodeAnalysis.Text.SourceText GetSubText(int start) { throw null; }
        public virtual System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Text.TextChange> GetTextChanges(Microsoft.CodeAnalysis.Text.SourceText oldText) { throw null; }
        public Microsoft.CodeAnalysis.Text.SourceText Replace(Microsoft.CodeAnalysis.Text.TextSpan span, string newText) { throw null; }
        public Microsoft.CodeAnalysis.Text.SourceText Replace(int start, int length, string newText) { throw null; }
        public override string ToString() { throw null; }
        public virtual string ToString(Microsoft.CodeAnalysis.Text.TextSpan span) { throw null; }
        public Microsoft.CodeAnalysis.Text.SourceText WithChanges(params Microsoft.CodeAnalysis.Text.TextChange[] changes) { throw null; }
        public virtual Microsoft.CodeAnalysis.Text.SourceText WithChanges(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextChange> changes) { throw null; }
        public virtual void Write(System.IO.TextWriter writer, Microsoft.CodeAnalysis.Text.TextSpan span, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { }
        public void Write(System.IO.TextWriter textWriter, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { }
    }
    public abstract partial class SourceTextContainer
    {
        protected SourceTextContainer() { }
        public abstract Microsoft.CodeAnalysis.Text.SourceText CurrentText { get; }
        public abstract event System.EventHandler<Microsoft.CodeAnalysis.Text.TextChangeEventArgs> TextChanged;
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct TextChange : System.IEquatable<Microsoft.CodeAnalysis.Text.TextChange>
    {
        public TextChange(Microsoft.CodeAnalysis.Text.TextSpan span, string newText) { throw null;}
        public string NewText { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Text.TextChange> NoChanges { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan Span { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.Text.TextChange other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.Text.TextChange left, Microsoft.CodeAnalysis.Text.TextChange right) { throw null; }
        public static implicit operator Microsoft.CodeAnalysis.Text.TextChangeRange (Microsoft.CodeAnalysis.Text.TextChange change) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.Text.TextChange left, Microsoft.CodeAnalysis.Text.TextChange right) { throw null; }
        public override string ToString() { throw null; }
    }
    public partial class TextChangeEventArgs : System.EventArgs
    {
        public TextChangeEventArgs(Microsoft.CodeAnalysis.Text.SourceText oldText, Microsoft.CodeAnalysis.Text.SourceText newText, params Microsoft.CodeAnalysis.Text.TextChangeRange[] changes) { }
        public TextChangeEventArgs(Microsoft.CodeAnalysis.Text.SourceText oldText, Microsoft.CodeAnalysis.Text.SourceText newText, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextChangeRange> changes) { }
        public System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Text.TextChangeRange> Changes { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.Text.SourceText NewText { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public Microsoft.CodeAnalysis.Text.SourceText OldText { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct TextChangeRange : System.IEquatable<Microsoft.CodeAnalysis.Text.TextChangeRange>
    {
        public TextChangeRange(Microsoft.CodeAnalysis.Text.TextSpan span, int newLength) { throw null;}
        public int NewLength { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Text.TextChangeRange> NoChanges { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan Span { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public static Microsoft.CodeAnalysis.Text.TextChangeRange Collapse(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextChangeRange> changes) { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.Text.TextChangeRange other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.Text.TextChangeRange left, Microsoft.CodeAnalysis.Text.TextChangeRange right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.Text.TextChangeRange left, Microsoft.CodeAnalysis.Text.TextChangeRange right) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct TextLine : System.IEquatable<Microsoft.CodeAnalysis.Text.TextLine>
    {
        public int End { get { throw null; } }
        public int EndIncludingLineBreak { get { throw null; } }
        public int LineNumber { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan Span { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.TextSpan SpanIncludingLineBreak { get { throw null; } }
        public int Start { get { throw null; } }
        public Microsoft.CodeAnalysis.Text.SourceText Text { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.Text.TextLine other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public static Microsoft.CodeAnalysis.Text.TextLine FromSpan(Microsoft.CodeAnalysis.Text.SourceText text, Microsoft.CodeAnalysis.Text.TextSpan span) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.Text.TextLine left, Microsoft.CodeAnalysis.Text.TextLine right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.Text.TextLine left, Microsoft.CodeAnalysis.Text.TextLine right) { throw null; }
        public override string ToString() { throw null; }
    }
    public abstract partial class TextLineCollection : System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextLine>, System.Collections.Generic.IReadOnlyCollection<Microsoft.CodeAnalysis.Text.TextLine>, System.Collections.Generic.IReadOnlyList<Microsoft.CodeAnalysis.Text.TextLine>, System.Collections.IEnumerable
    {
        protected TextLineCollection() { }
        public abstract int Count { get; }
        public abstract Microsoft.CodeAnalysis.Text.TextLine this[int index] { get; }
        public Microsoft.CodeAnalysis.Text.TextLineCollection.Enumerator GetEnumerator() { throw null; }
        public virtual Microsoft.CodeAnalysis.Text.TextLine GetLineFromPosition(int position) { throw null; }
        public virtual Microsoft.CodeAnalysis.Text.LinePosition GetLinePosition(int position) { throw null; }
        public Microsoft.CodeAnalysis.Text.LinePositionSpan GetLinePositionSpan(Microsoft.CodeAnalysis.Text.TextSpan span) { throw null; }
        public int GetPosition(Microsoft.CodeAnalysis.Text.LinePosition position) { throw null; }
        public Microsoft.CodeAnalysis.Text.TextSpan GetTextSpan(Microsoft.CodeAnalysis.Text.LinePositionSpan span) { throw null; }
        public abstract int IndexOf(int position);
        System.Collections.Generic.IEnumerator<Microsoft.CodeAnalysis.Text.TextLine> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextLine>.GetEnumerator() { throw null; }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public partial struct Enumerator : System.Collections.Generic.IEnumerator<Microsoft.CodeAnalysis.Text.TextLine>, System.Collections.IEnumerator, System.IDisposable
        {
            public Microsoft.CodeAnalysis.Text.TextLine Current { get { throw null; } }
            object System.Collections.IEnumerator.Current { get { throw null; } }
            public override bool Equals(object obj) { throw null; }
            public override int GetHashCode() { throw null; }
            public bool MoveNext() { throw null; }
            bool System.Collections.IEnumerator.MoveNext() { throw null; }
            void System.Collections.IEnumerator.Reset() { }
            void System.IDisposable.Dispose() { }
        }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct TextSpan : System.IComparable<Microsoft.CodeAnalysis.Text.TextSpan>, System.IEquatable<Microsoft.CodeAnalysis.Text.TextSpan>
    {
        public TextSpan(int start, int length) { throw null;}
        public int End { get { throw null; } }
        public bool IsEmpty { get { throw null; } }
        public int Length { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public int Start { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
        public int CompareTo(Microsoft.CodeAnalysis.Text.TextSpan other) { throw null; }
        public bool Contains(Microsoft.CodeAnalysis.Text.TextSpan span) { throw null; }
        public bool Contains(int position) { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.Text.TextSpan other) { throw null; }
        public override bool Equals(object obj) { throw null; }
        public static Microsoft.CodeAnalysis.Text.TextSpan FromBounds(int start, int end) { throw null; }
        public override int GetHashCode() { throw null; }
        public System.Nullable<Microsoft.CodeAnalysis.Text.TextSpan> Intersection(Microsoft.CodeAnalysis.Text.TextSpan span) { throw null; }
        public bool IntersectsWith(Microsoft.CodeAnalysis.Text.TextSpan span) { throw null; }
        public bool IntersectsWith(int position) { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.Text.TextSpan left, Microsoft.CodeAnalysis.Text.TextSpan right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.Text.TextSpan left, Microsoft.CodeAnalysis.Text.TextSpan right) { throw null; }
        public System.Nullable<Microsoft.CodeAnalysis.Text.TextSpan> Overlap(Microsoft.CodeAnalysis.Text.TextSpan span) { throw null; }
        public bool OverlapsWith(Microsoft.CodeAnalysis.Text.TextSpan span) { throw null; }
        public override string ToString() { throw null; }
    }
}
